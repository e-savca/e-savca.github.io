<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[EUGENIU2]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>lib/media/favicon.png</url><title>EUGENIU2</title><link></link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Thu, 09 May 2024 15:41:54 GMT</lastBuildDate><atom:link href="lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Thu, 09 May 2024 15:41:16 GMT</pubDate><ttl>60</ttl><dc:creator></dc:creator><item><title><![CDATA[АБСТРАКТНАЯ ФАБРИКА (Abstract Factory)]]></title><description><![CDATA[ 
 <br><br>Бизнес-логика программы должна работать с разными видами связанных друг с другом продуктов, не завися от конкретных классов продуктов.<br><br>Создать интерфейс абстрактной фабрики, определяющий фабричные методы для создания каждого из типов продуктов. Создать конкретные фабрики, реализующие интерфейс абстрактной фабрики. Каждая конкретная фабрика относится к своей вариации продуктов и реализует методы абстрактной фабрики, позволяя создавать все продукты определённой вариации.<br><br>
<br>Абстрактная фабрика
<br>Конкретная фабрика
<br>Абстрактный продукт
<br>Конкретный продукт
<br><br>Когда бизнес-логика программы должна работать с разными видами связанных друг с другом продуктов, не завися от конкретных классов продуктов.<br><br>
<br>Создать таблицу соотношений типов продуктов к вариациям семейств продуктов.
<br>Свести все вариации продуктов к общим интерфейсам.
<br>Определить интерфейс абстрактной фабрики.
<br>Создать классы конкретных фабрик, реализовав интерфейс абстрактной фабрики.
<br>Изменить код инициализации программы так, чтобы она создавала определённую фабрику и передавала её в клиентский код.
<br><br><br>
<br>Гарантирует сочетаемость создаваемых продуктов.
<br>Избавляет клиентский код от привязки к конкретным классам продуктов.
<br>Выделяет код производства продуктов в одно место, упрощая поддержку кода.
<br>Упрощает добавление новых продуктов в программу.
<br>Реализует принцип открытости/закрытости.
<br><br>
<br>Усложняет код программы из-за введения множества дополнительных классов.
<br>Требует наличия всех типов продуктов в каждой вариации.
<br><br>
<br>Многие архитектуры начинаются с применения Фабричного метода и эволюционируют в сторону Абстрактной фабрики, Прототипа или Строителя.
<br>Строитель концентрируется на построении сложных объектов шаг за шагом. Абстрактная фабрика специализируется
<br><br><br>// Паттерн Абстрактная Фабрика
//
// Назначение: Предоставляет интерфейс для создания семейств связанных или
// зависимых объектов без привязки к их конкретным классам.

using System;

namespace RefactoringGuru.DesignPatterns.AbstractFactory.Conceptual
{
    // Интерфейс Абстрактной Фабрики объявляет набор методов, которые возвращают
    // различные абстрактные продукты.  Эти продукты называются семейством и
    // связаны темой или концепцией высокого уровня. Продукты одного семейства
    // обычно могут взаимодействовать между собой. Семейство продуктов может
    // иметь несколько вариаций,  но продукты одной вариации несовместимы с
    // продуктами другой.
    public interface IAbstractFactory
    {
        IAbstractProductA CreateProductA();

        IAbstractProductB CreateProductB();
    }

    // Конкретная Фабрика производит семейство продуктов одной вариации. Фабрика
    // гарантирует совместимость полученных продуктов.  Обратите внимание, что
    // сигнатуры методов Конкретной Фабрики возвращают абстрактный продукт, в то
    // время как внутри метода создается экземпляр  конкретного продукта.
    class ConcreteFactory1 : IAbstractFactory
    {
        public IAbstractProductA CreateProductA()
        {
            return new ConcreteProductA1();
        }

        public IAbstractProductB CreateProductB()
        {
            return new ConcreteProductB1();
        }
    }

    // Каждая Конкретная Фабрика имеет соответствующую вариацию продукта.
    class ConcreteFactory2 : IAbstractFactory
    {
        public IAbstractProductA CreateProductA()
        {
            return new ConcreteProductA2();
        }

        public IAbstractProductB CreateProductB()
        {
            return new ConcreteProductB2();
        }
    }

    // Каждый отдельный продукт семейства продуктов должен иметь базовый
    // интерфейс. Все вариации продукта должны реализовывать этот интерфейс.
    public interface IAbstractProductA
    {
        string UsefulFunctionA();
    }

    // Конкретные продукты создаются соответствующими Конкретными Фабриками.
    class ConcreteProductA1 : IAbstractProductA
    {
        public string UsefulFunctionA()
        {
            return "The result of the product A1.";
        }
    }

    class ConcreteProductA2 : IAbstractProductA
    {
        public string UsefulFunctionA()
        {
            return "The result of the product A2.";
        }
    }

    // Базовый интерфейс другого продукта. Все продукты могут взаимодействовать
    // друг с другом, но правильное взаимодействие возможно только между
    // продуктами одной и той же конкретной вариации.
    public interface IAbstractProductB
    {
        // Продукт B способен работать самостоятельно...
        string UsefulFunctionB();

        // ...а также взаимодействовать с Продуктами А той же вариации.
        //
        // Абстрактная Фабрика гарантирует, что все продукты, которые она
        // создает, имеют одинаковую вариацию и, следовательно, совместимы.
        string AnotherUsefulFunctionB(IAbstractProductA collaborator);
    }

    // Конкретные Продукты создаются соответствующими Конкретными Фабриками.
    class ConcreteProductB1 : IAbstractProductB
    {
        public string UsefulFunctionB()
        {
            return "The result of the product B1.";
        }

        // Продукт B1 может корректно работать только с Продуктом A1. Тем не
        // менее, он принимает любой экземпляр Абстрактного Продукта А в
        // качестве аргумента.
        public string AnotherUsefulFunctionB(IAbstractProductA collaborator)
        {
            var result = collaborator.UsefulFunctionA();

            return $"The result of the B1 collaborating with the ({result})";
        }
    }

    class ConcreteProductB2 : IAbstractProductB
    {
        public string UsefulFunctionB()
        {
            return "The result of the product B2.";
        }

       // Продукт B2 может корректно работать только с Продуктом A2. Тем не
       // менее, он принимает любой экземпляр Абстрактного Продукта А в качестве
       // аргумента.
        public string AnotherUsefulFunctionB(IAbstractProductA collaborator)
        {
            var result = collaborator.UsefulFunctionA();

            return $"The result of the B2 collaborating with the ({result})";
        }
    }

    // Клиентский код работает с фабриками и продуктами только через абстрактные
    // типы: Абстрактная Фабрика и Абстрактный Продукт. Это позволяет передавать
    // любой подкласс фабрики или продукта клиентскому коду, не нарушая его.
    class Client
    {
        public void Main()
        {
            // Клиентский код может работать с любым конкретным классом фабрики.
            Console.WriteLine("Client: Testing client code with the first factory type...");
            ClientMethod(new ConcreteFactory1());
            Console.WriteLine();

            Console.WriteLine("Client: Testing the same client code with the second factory type...");
            ClientMethod(new ConcreteFactory2());
        }

        public void ClientMethod(IAbstractFactory factory)
        {
            var productA = factory.CreateProductA();
            var productB = factory.CreateProductB();

            Console.WriteLine(productB.UsefulFunctionB());
            Console.WriteLine(productB.AnotherUsefulFunctionB(productA));
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            new Client().Main();
        }
    }
}
Copy]]></description><link>04.-literature-notes/погружение-в-паттерны-проектирования-by-alexander-shvets/абстрактная-фабрика-(abstract-factory).html</link><guid isPermaLink="false">04. Literature Notes/Погружение в ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ by Alexander Shvets/АБСТРАКТНАЯ ФАБРИКА (Abstract Factory).md</guid><pubDate>Wed, 08 May 2024 15:47:44 GMT</pubDate></item><item><title><![CDATA[АДАПТЕР (Wrapper, Обёртка, Adapter)]]></title><description><![CDATA[ 
 <br><br>Несовместимые интерфейсы классов могут мешать их использованию вместе.<br><br>Адаптер преобразует интерфейс объекта к нужному для клиента.<br><br>Адаптер для розетки, который позволяет подключать иностранные устройства к российской розетке.<br><br>Адаптер может быть реализован как класс или как функция.<br><br>Используйте Адаптер, когда:<br>
<br>вы хотите использовать сторонний класс, но его интерфейс не соответствует остальному коду приложения;
<br>вам нужно использовать несколько существующих подклассов, но в них не хватает какой-то общей функциональности, причём расширить суперкласс вы не можете.
<br><br>
<br>Определите два класса с несовместимыми интерфейсами: сервис и клиент.
<br>Определите интерфейс клиента, через который он будет использовать сервис.
<br>Создайте класс-адаптер, реализуя клиентский интерфейс.
<br>Поместите в адаптер поле, которое будет хранить ссылку на объект сервиса.
<br>Реализуйте методы клиентского интерфейса в адаптере, делегируя основную работу сервису.
<br><br><br>
<br>Отделяет и скрывает от клиента подробности преобразования различных интерфейсов.
<br><br>
<br>Усложняет код программы из-за введения дополнительных классов.
<br><br>
<br>Мост проектируют загодя, чтобы развивать большие части приложения отдельно друг от друга. Адаптер применяется постфактум, чтобы заставить несовместимые классы работать вместе.
<br>Адаптер меняет интерфейс существующего объекта. Декоратор улучшает другой объект без изменения его интерфейса. Причём Декоратор поддерживает рекурсивную вложенность, чего не скажешь об Адаптере.
<br>Адаптер предоставляет классу альтернативный интерфейс. Декоратор предоставляет расширенный интерфейс. Заместитель предоставляет тот же интерфейс.
<br>Фасад задаёт новый интерфейс, тогда как Адаптер повторно использует старый. Адаптер оборачивает только один класс, а Фасад оборачивает целую подсистему. Кроме того, Адаптер позволяет двум существующим интерфейсам работать сообща, вместо того, чтобы задать
<br><br><br>// Паттерн Адаптер
//
// Назначение: Позволяет объектам с несовместимыми интерфейсами работать вместе.

using System;

namespace RefactoringGuru.DesignPatterns.Adapter.Conceptual
{
    // Целевой класс объявляет интерфейс, с которым может работать клиентский
    // код.
    public interface ITarget
    {
        string GetRequest();
    }

    // Адаптируемый класс содержит некоторое полезное поведение, но его
    // интерфейс несовместим  с существующим клиентским кодом. Адаптируемый
    // класс нуждается в некоторой доработке,  прежде чем клиентский код сможет
    // его использовать.
    class Adaptee
    {
        public string GetSpecificRequest()
        {
            return "Specific request.";
        }
    }

    // Адаптер делает интерфейс Адаптируемого класса совместимым с целевым
    // интерфейсом.
    class Adapter : ITarget
    {
        private readonly Adaptee _adaptee;

        public Adapter(Adaptee adaptee)
        {
            this._adaptee = adaptee;
        }

        public string GetRequest()
        {
            return $"This is '{this._adaptee.GetSpecificRequest()}'";
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            Adaptee adaptee = new Adaptee();
            ITarget target = new Adapter(adaptee);

            Console.WriteLine("Adaptee interface is incompatible with the client.");
            Console.WriteLine("But with adapter client can call it's method.");

            Console.WriteLine(target.GetRequest());
        }
    }
}
Copy]]></description><link>04.-literature-notes/погружение-в-паттерны-проектирования-by-alexander-shvets/адаптер-(wrapper,-обёртка,-adapter).html</link><guid isPermaLink="false">04. Literature Notes/Погружение в ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ by Alexander Shvets/АДАПТЕР (Wrapper, Обёртка, Adapter).md</guid><pubDate>Wed, 08 May 2024 21:47:17 GMT</pubDate></item><item><title><![CDATA[ДЕКОРАТОР (Decorator)]]></title><description><![CDATA[ 
 <br><br>Этот документ описывает проблему, возникшую при добавлении новых типов оповещений в библиотеку, и рассматривает возможность комбинирования нескольких типов оповещений сразу. Автор пытался реализовать все возможные комбинации подклассов, но это привело к раздуванию кода программы, поэтому нужен другой способ комбинирования поведения объектов.<br><br>Использование паттерна Декоратор. Он позволяет добавлять функциональность объекту на лету, не изменяя его класс.<br><br>Можно сравнить с покупкой машины: вы можете добавлять дополнительные опции, такие как камера заднего хода или кожаные сиденья, но это не изменит саму конструкцию машины.<br><br>
<br>Интерфейс Компонента
<br>Конкретный Компонент
<br>Базовый Декоратор
<br>Конкретный Декоратор
<br><br>
<br>Когда нужно добавить функциональность объекту на лету
<br>Когда нельзя использовать наследование, чтобы изменить обязанности объекта
<br><br>
<br>Определите основной компонент и дополнения к нему
<br>Создайте интерфейс компонента
<br>Создайте класс конкретного компонента
<br>Создайте базовый декоратор с полем, хранящим ссылку на вложенный объект-компонент, и делегированием действия вложенному объекту
<br>Оба класса должны следовать одному интерфейсу компонента
<br>Создайте конкретные декораторы, добавляющие функциональность и вызывающие операцию обёрнутого объекта
<br>Клиент конфигурирует и порядок обёртывания объектов
<br><br><br>
<br>Большая гибкость, чем у наследования
<br>Позволяет добавлять обязанности на лету
<br>Можно добавлять несколько новых обязанностей сразу
<br>Позволяет иметь несколько мелких объектов вместо одного объекта на все случаи жизни
<br><br>
<br>Трудно конфигурировать многократно обёрнутые объекты
<br>Обилие крошечных классов
<br><br>
<br>Адаптер меняет интерфейс существующего объекта. Декоратор улучшает другой объект без изменения его интерфейса. Причём Декоратор поддерживает рекурсивную вложенность, чего не скажешь об Адаптере.
<br>Цепочка обязанностей и Декоратор имеют очень похожие структуры. Оба паттерна базируются на принципе рекурсивного выполнения операции через серию связанных объектов. Но есть и несколько важных отличий.
<br>Компоновщик и Декоратор имеют по
<br><br><br>// Паттерн Декоратор
//
// Назначение: Позволяет динамически добавлять объектам новую функциональность,
// оборачивая их в полезные «обёртки».

using System;

namespace RefactoringGuru.DesignPatterns.Composite.Conceptual
{
    // Базовый интерфейс Компонента определяет поведение, которое изменяется
    // декораторами.
    public abstract class Component
    {
        public abstract string Operation();
    }

    // Конкретные Компоненты предоставляют реализации поведения по умолчанию.
    // Может быть несколько вариаций этих классов.
    class ConcreteComponent : Component
    {
        public override string Operation()
        {
            return "ConcreteComponent";
        }
    }

    // Базовый класс Декоратора следует тому же интерфейсу, что и другие
    // компоненты. Основная цель этого класса - определить интерфейс обёртки для
    // всех конкретных декораторов. Реализация кода обёртки по умолчанию может
    // включать в себя  поле для хранения завёрнутого компонента и средства его
    // инициализации.
    abstract class Decorator : Component
    {
        protected Component _component;

        public Decorator(Component component)
        {
            this._component = component;
        }

        public void SetComponent(Component component)
        {
            this._component = component;
        }

        // Декоратор делегирует всю работу обёрнутому компоненту.
        public override string Operation()
        {
            if (this._component != null)
            {
                return this._component.Operation();
            }
            else
            {
                return string.Empty;
            }
        }
    }

    // Конкретные Декораторы вызывают обёрнутый объект и изменяют его результат
    // некоторым образом.
    class ConcreteDecoratorA : Decorator
    {
        public ConcreteDecoratorA(Component comp) : base(comp)
        {
        }

        // Декораторы могут вызывать родительскую реализацию операции, вместо
        // того, чтобы вызвать обёрнутый объект напрямую. Такой подход упрощает
        // расширение классов декораторов.
        public override string Operation()
        {
            return $"ConcreteDecoratorA({base.Operation()})";
        }
    }

    // Декораторы могут выполнять своё поведение до или после вызова обёрнутого
    // объекта.
    class ConcreteDecoratorB : Decorator
    {
        public ConcreteDecoratorB(Component comp) : base(comp)
        {
        }

        public override string Operation()
        {
            return $"ConcreteDecoratorB({base.Operation()})";
        }
    }
    
    public class Client
    {
        // Клиентский код работает со всеми объектами, используя интерфейс
        // Компонента. Таким образом, он остаётся независимым от конкретных
        // классов компонентов, с которыми работает.
        public void ClientCode(Component component)
        {
            Console.WriteLine("RESULT: " + component.Operation());
        }
    }
    
    class Program
    {
        static void Main(string[] args)
        {
            Client client = new Client();

            var simple = new ConcreteComponent();
            Console.WriteLine("Client: I get a simple component:");
            client.ClientCode(simple);
            Console.WriteLine();

            // ...так и декорированные.
            //
            // Обратите внимание, что декораторы могут обёртывать не только
            // простые компоненты, но и другие декораторы.
            ConcreteDecoratorA decorator1 = new ConcreteDecoratorA(simple);
            ConcreteDecoratorB decorator2 = new ConcreteDecoratorB(decorator1);
            Console.WriteLine("Client: Now I've got a decorated component:");
            client.ClientCode(decorator2);
        }
    }
}
Copy]]></description><link>04.-literature-notes/погружение-в-паттерны-проектирования-by-alexander-shvets/декоратор-(decorator).html</link><guid isPermaLink="false">04. Literature Notes/Погружение в ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ by Alexander Shvets/ДЕКОРАТОР (Decorator).md</guid><pubDate>Wed, 08 May 2024 15:53:36 GMT</pubDate></item><item><title><![CDATA[ЗАМЕСТИТЕЛЬ (Proxy)]]></title><description><![CDATA[ 
 <br><br>Есть сложный объект, загружающийся из базы данных или файловой системы. Необходимо оптимизировать его создание и загрузку.<br><br>Создаем заместителя (Proxy), который изначально не инициализирует сложный объект, а создает его только при необходимости. Это позволяет сэкономить ресурсы и ускорить загрузку.<br><br>Заместитель - это как заказ еды в ресторане. Вы не идете в кухню за едой, а заказываете ее через официанта. Он не только берет заказ, но и может проверить, есть ли необходимые ингредиенты, и сообщить вам об этом.<br><br>Вместо сложного объекта используется заместитель, который предоставляет тот же интерфейс. Заместитель содержит ссылку на служебный объект и может сам его инициализировать.<br><br>
<br>Ленивая инициализация (виртуальный прокси)
<br>Защита доступа (защищающий прокси)
<br>Локальный запуск сервиса (удалённый прокси)
<br>Логирование запросов (логирующий прокси)
<br>Кеширование объектов («умная» ссылка)
<br><br>
<br>Определить интерфейс заместителя и оригинального объекта взаимозаменяемыми.
<br>Создать класс заместителя. Он должен содержать ссылку на сервисный объект. Обычно сервисный объект создаётся самим заместителем.
<br>Реализовать методы заместителя в зависимости от его предназначения.
<br>Подумать об использовании фабрики для определения, какой объект создать.
<br>Реализовать ленивую инициализацию сервисного объекта при первом обращении клиента к методам заместителя.
<br><br><br>
<br>Позволяет контролировать сервисный объект незаметно для клиента.
<br>Может работать, даже если сервисный объект ещё не создан.
<br>Может контролировать жизненный цикл служебного объекта.
<br><br>
<br>Усложняет код программы из-за введения дополнительных классов.
<br>Увеличивает время отклика от сервиса.
<br><br>
<br>Адаптер, Декоратор и Заместитель построены на принципе композиции и делегируют работу другим объектам.
<br>Фасад похож на Заместитель тем, что замещает сложную подсистему и может сам её инициализировать. Но в отличие от Фасада, Заместитель им
<br><br><br>// Паттерн Заместитель
//
// Назначение: Позволяет подставлять вместо реальных объектов специальные
// объекты-заменители. Эти объекты перехватывают вызовы к оригинальному объекту,
// позволяя сделать что-то до или после передачи вызова оригиналу.

using System;

namespace RefactoringGuru.DesignPatterns.Proxy.Conceptual
{
    // Интерфейс Субъекта объявляет общие операции как для Реального Субъекта,
    // так и для Заместителя. Пока клиент работает с Реальным Субъектом,
    // используя этот интерфейс, вы сможете передать ему заместителя вместо
    // реального субъекта.
    public interface ISubject
    {
        void Request();
    }
    
    // Реальный Субъект содержит некоторую базовую бизнес-логику. Как правило,
    // Реальные Субъекты способны выполнять некоторую полезную работу, которая к
    // тому же может быть очень медленной или точной – например, коррекция
    // входных данных. Заместитель может решить эти задачи без каких-либо
    // изменений в коде Реального Субъекта.
    class RealSubject : ISubject
    {
        public void Request()
        {
            Console.WriteLine("RealSubject: Handling Request.");
        }
    }
    
    // Интерфейс Заместителя идентичен интерфейсу Реального Субъекта.
    class Proxy : ISubject
    {
        private RealSubject _realSubject;
        
        public Proxy(RealSubject realSubject)
        {
            this._realSubject = realSubject;
        }
        
        // Наиболее распространёнными областями применения паттерна Заместитель
        // являются ленивая загрузка, кэширование, контроль доступа, ведение
        // журнала и т.д. Заместитель может выполнить одну из этих задач, а
        // затем, в зависимости от результата, передать выполнение одноимённому
        // методу в связанном объекте класса Реального Субъект.
        public void Request()
        {
            if (this.CheckAccess())
            {
                this._realSubject.Request();

                this.LogAccess();
            }
        }
		
        public bool CheckAccess()
        {
            // Некоторые реальные проверки должны проходить здесь.
            Console.WriteLine("Proxy: Checking access prior to firing a real request.");

            return true;
        }
		
        public void LogAccess()
        {
            Console.WriteLine("Proxy: Logging the time of request.");
        }
    }
    
    public class Client
    {
        // Клиентский код должен работать со всеми объектами (как с реальными,
        // так и заместителями) через интерфейс Субъекта, чтобы поддерживать как
        // реальные субъекты, так и заместителей. В реальной жизни, однако,
        // клиенты в основном работают с реальными субъектами напрямую. В этом
        // случае, для более простой реализации паттерна, можно расширить
        // заместителя из класса реального субъекта.
        public void ClientCode(ISubject subject)
        {
            // ...
            
            subject.Request();
            
            // ...
        }
    }
    
    class Program
    {
        static void Main(string[] args)
        {
            Client client = new Client();
            
            Console.WriteLine("Client: Executing the client code with a real subject:");
            RealSubject realSubject = new RealSubject();
            client.ClientCode(realSubject);

            Console.WriteLine();

            Console.WriteLine("Client: Executing the same client code with a proxy:");
            Proxy proxy = new Proxy(realSubject);
            client.ClientCode(proxy);
        }
    }
}
Copy]]></description><link>04.-literature-notes/погружение-в-паттерны-проектирования-by-alexander-shvets/заместитель-(proxy).html</link><guid isPermaLink="false">04. Literature Notes/Погружение в ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ by Alexander Shvets/ЗАМЕСТИТЕЛЬ (Proxy).md</guid><pubDate>Wed, 08 May 2024 15:48:22 GMT</pubDate></item><item><title><![CDATA[ИТЕРАТОР (Iterator)]]></title><description><![CDATA[ 
 <br><br>Как обойти сложные структуры данных без раскрытия деталей их реализации?<br><br>Используйте паттерн Итератор. Он предоставляет простой интерфейс для обхода элементов коллекции, скрывая детали её реализации.<br><br>Итератор - это как тележка в магазине. Вы не знаете, как все продукты расположены на полках, но можете легко пройти по всему магазину и собрать нужные вам товары.<br><br>Итератор взаимодействует с коллекцией, скрывая её реализацию. Конкретные итераторы реализуют обход для определенных типов коллекций.<br><br>Используйте Итератор, когда:<br>
<br>у вас есть сложные структуры данных, и вы хотите скрыть от клиента детали её реализации
<br>вы хотите иметь несколько вариантов обхода одной и той же структуры данных
<br>вам нужно иметь единый интерфейс обхода различных структур данных
<br><br>
<br>Создайте общий интерфейс итераторов.
<br>Создайте интерфейс коллекции и опишите в нём метод получения итератора.
<br>Создайте классы конкретных итераторов для тех коллекций, которые нужно обходить с помощью паттерна.
<br>Реализуйте методы получения итератора в конкретных классах коллекций.
<br>В клиентском коде и в классах коллекций не должно оставаться кода обхода элементов.
<br><br><br>
<br>Упрощает классы хранения данных.
<br>Позволяет реализовать различные способы обхода структуры данных.
<br>Позволяет одновременно перемещаться по структуре данных в разные стороны.
<br><br>
<br>Не оправдан, если можно обойтись простым циклом.
<br><br>Вы можете использовать Итератор совместно с другими паттернами, такими как Фабричный метод, Снимок и Посетитель, чтобы улучшить архитектуру вашей программы.<br><br><br>// Паттерн Итератор
//
// Назначение: Даёт возможность последовательно обходить элементы составных
// объектов, не раскрывая их внутреннего представления.

using System;
using System.Collections;
using System.Collections.Generic;

namespace RefactoringGuru.DesignPatterns.Iterator.Conceptual
{
    abstract class Iterator : IEnumerator
    {
        object IEnumerator.Current =&gt; Current();

        // Возвращает ключ текущего элемента
        public abstract int Key();
		
        // Возвращает текущий элемент.
        public abstract object Current();
		
        // Переходит к следующему элементу.
        public abstract bool MoveNext();
		
        // Перематывает Итератор к первому элементу.
        public abstract void Reset();
    }

    abstract class IteratorAggregate : IEnumerable
    {
        // Возвращает Iterator или другой IteratorAggregate для реализующего
        // объекта.
        public abstract IEnumerator GetEnumerator();
    }

    // Конкретные Итераторы реализуют различные алгоритмы обхода. Эти классы
    // постоянно хранят текущее положение обхода.
    class AlphabeticalOrderIterator : Iterator
    {
        private WordsCollection _collection;
		
        // Хранит текущее положение обхода. У итератора может быть множество
        // других полей для хранения состояния итерации, особенно когда он
        // должен работать с определённым типом коллекции.
        private int _position = -1;
		
        private bool _reverse = false;

        public AlphabeticalOrderIterator(WordsCollection collection, bool reverse = false)
        {
            this._collection = collection;
            this._reverse = reverse;

            if (reverse)
            {
                this._position = collection.getItems().Count;
            }
        }
		
        public override object Current()
        {
            return this._collection.getItems()[_position];
        }

        public override int Key()
        {
            return this._position;
        }
		
        public override bool MoveNext()
        {
            int updatedPosition = this._position + (this._reverse ? -1 : 1);

            if (updatedPosition &gt;= 0 &amp;&amp; updatedPosition &lt; this._collection.getItems().Count)
            {
                this._position = updatedPosition;
                return true;
            }
            else
            {
                return false;
            }
        }
		
        public override void Reset()
        {
            this._position = this._reverse ? this._collection.getItems().Count - 1 : 0;
        }
    }

    // Конкретные Коллекции предоставляют один или несколько методов для
    // получения новых экземпляров итератора, совместимых с классом коллекции.
    class WordsCollection : IteratorAggregate
    {
        List&lt;string&gt; _collection = new List&lt;string&gt;();
		
        bool _direction = false;
        
        public void ReverseDirection()
        {
            _direction = !_direction;
        }
		
        public List&lt;string&gt; getItems()
        {
            return _collection;
        }
		
        public void AddItem(string item)
        {
            this._collection.Add(item);
        }
		
        public override IEnumerator GetEnumerator()
        {
            return new AlphabeticalOrderIterator(this, _direction);
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            // Клиентский код может знать или не знать о Конкретном Итераторе
            // или классах Коллекций, в зависимости от уровня косвенности,
            // который вы хотите сохранить в своей программе.
            var collection = new WordsCollection();
            collection.AddItem("First");
            collection.AddItem("Second");
            collection.AddItem("Third");

            Console.WriteLine("Straight traversal:");

            foreach (var element in collection)
            {
                Console.WriteLine(element);
            }

            Console.WriteLine("\nReverse traversal:");

            collection.ReverseDirection();

            foreach (var element in collection)
            {
                Console.WriteLine(element);
            }
        }
    }
}
Copy]]></description><link>04.-literature-notes/погружение-в-паттерны-проектирования-by-alexander-shvets/итератор-(iterator).html</link><guid isPermaLink="false">04. Literature Notes/Погружение в ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ by Alexander Shvets/ИТЕРАТОР (Iterator).md</guid><pubDate>Wed, 08 May 2024 15:50:13 GMT</pubDate></item><item><title><![CDATA[КОМАНДА (Действие, Транзакция, Action, Command)]]></title><description><![CDATA[ 
 <br><br>Как управлять запросами на выполнение операций без жесткой связи между отправителями и получателями?<br><br>Создать общий интерфейс для команд и определить в нём метод запуска. Создавать классы конкретных команд и использовать их для выполнения действий, не связывая отправителей напрямую с получателями.<br><br>Команда поваров, работающих на кухне, получает команды от официантов и выполняет их без прямой связи с клиентами.<br><br>Основными элементами паттерна являются отправитель, команда и получатель.<br><br>
<br>Когда нужно отделить запросы на выполнение операций от их получателей.
<br>Когда нужно поддерживать отмену операций.
<br>Когда нужно поддерживать отложенный запуск операций.
<br>Когда нужно собирать сложные команды из простых.
<br><br>
<br>Создать общий интерфейс команд и определить в нём метод запуска.
<br>Создавать классы конкретных команд и использовать их для выполнения действий.
<br>Создать объекты отправителей и связать их с командами.
<br>Создать объекты получателей.
<br>Инициализировать объекты в правильном порядке.
<br><br><br>
<br>Убирает прямую зависимость между объектами, вызывающими операции, и объектами, которые их непосредственно выполняют.
<br>Позволяет реализовать простую отмену и повтор операций.
<br>Позволяет реализовать отложенный запуск операций.
<br>Позволяет собирать сложные команды из простых.
<br>Реализует принцип открытости/закрытости.
<br><br>
<br>Усложняет код программы из-за введения множества дополнительных классов.
<br><br>
<br>Цепочка обязанностей, Посредник и Наблюдатель показывают различные способы работы отправителей запросов с их получателями.
<br>Команду и Снимок можно использовать сообща для реализации отмены операций.
<br>Команду и Стратегию можно использовать вместе, чтобы превратить любые разнородные действия в объекты.
<br>Если Команду нужно копировать перед вставкой в историю выполненных команд, вам может помочь Прототип.
<br>Посетитель можно рассматривать как расширенный аналог Команды.
<br><br><br>// Паттерн Команда
//
// Назначение: Превращает запросы в объекты, позволяя передавать их как
// аргументы при вызове методов, ставить запросы в очередь, логировать их, а
// также поддерживать отмену операций.

using System;

namespace RefactoringGuru.DesignPatterns.Command.Conceptual
{
    // Интерфейс Команды объявляет метод для выполнения команд.
    public interface ICommand
    {
        void Execute();
    }

    // Некоторые команды способны выполнять простые операции самостоятельно.
    class SimpleCommand : ICommand
    {
        private string _payload = string.Empty;

        public SimpleCommand(string payload)
        {
            this._payload = payload;
        }

        public void Execute()
        {
            Console.WriteLine($"SimpleCommand: See, I can do simple things like printing ({this._payload})");
        }
    }

    // Но есть и команды, которые делегируют более сложные операции другим
    // объектам, называемым «получателями».
    class ComplexCommand : ICommand
    {
        private Receiver _receiver;

        // Данные о контексте, необходимые для запуска методов получателя.
        private string _a;

        private string _b;

        // Сложные команды могут принимать один или несколько объектов-
        // получателей вместе с любыми данными о контексте через конструктор.
        public ComplexCommand(Receiver receiver, string a, string b)
        {
            this._receiver = receiver;
            this._a = a;
            this._b = b;
        }

        // Команды могут делегировать выполнение любым методам получателя.
        public void Execute()
        {
            Console.WriteLine("ComplexCommand: Complex stuff should be done by a receiver object.");
            this._receiver.DoSomething(this._a);
            this._receiver.DoSomethingElse(this._b);
        }
    }

    // Классы Получателей содержат некую важную бизнес-логику. Они умеют
    // выполнять все виды операций, связанных с выполнением запроса. Фактически,
    // любой класс может выступать Получателем.
    class Receiver
    {
        public void DoSomething(string a)
        {
            Console.WriteLine($"Receiver: Working on ({a}.)");
        }

        public void DoSomethingElse(string b)
        {
            Console.WriteLine($"Receiver: Also working on ({b}.)");
        }
    }

    // Отправитель связан с одной или несколькими командами. Он отправляет
    // запрос команде.
    class Invoker
    {
        private ICommand _onStart;

        private ICommand _onFinish;

        // Инициализация команд
        public void SetOnStart(ICommand command)
        {
            this._onStart = command;
        }

        public void SetOnFinish(ICommand command)
        {
            this._onFinish = command;
        }

        // Отправитель не зависит от классов конкретных команд и получателей.
        // Отправитель передаёт запрос получателю косвенно, выполняя команду.
        public void DoSomethingImportant()
        {
            Console.WriteLine("Invoker: Does anybody want something done before I begin?");
            if (this._onStart is ICommand)
            {
                this._onStart.Execute();
            }
            
            Console.WriteLine("Invoker: ...doing something really important...");
            
            Console.WriteLine("Invoker: Does anybody want something done after I finish?");
            if (this._onFinish is ICommand)
            {
                this._onFinish.Execute();
            }
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            // Клиентский код может параметризовать отправителя любыми
            // командами.
            Invoker invoker = new Invoker();
            invoker.SetOnStart(new SimpleCommand("Say Hi!"));
            Receiver receiver = new Receiver();
            invoker.SetOnFinish(new ComplexCommand(receiver, "Send email", "Save report"));

            invoker.DoSomethingImportant();
        }
    }
}
Copy<br><br>Invoker: Does anybody want something done before I begin?
SimpleCommand: See, I can do simple things like printing (Say Hi!)
Invoker: ...doing something really important...
Invoker: Does anybody want something done after I finish?
ComplexCommand: Complex stuff should be done by a receiver object.
Receiver: Working on (Send email.)
Receiver: Also working on (Save report.)
Copy]]></description><link>04.-literature-notes/погружение-в-паттерны-проектирования-by-alexander-shvets/команда-(действие,-транзакция,-action,-command).html</link><guid isPermaLink="false">04. Literature Notes/Погружение в ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ by Alexander Shvets/КОМАНДА (Действие, Транзакция, Action, Command).md</guid><pubDate>Wed, 08 May 2024 15:49:19 GMT</pubDate></item><item><title><![CDATA[КОМПОНОВЩИК (Composite)]]></title><description><![CDATA[ 
 <br><br>Как представить древовидную структуру объектов так, чтобы клиенты могли единообразно работать с простыми и составными объектами?<br><br>Используйте паттерн Компоновщик. Храните в составных объектах ссылки на другие простые или составные объекты. Таким образом, вы можете строить сложную древовидную структуру данных, используя всего две основные разновидности объектов.<br><br>Стебель цветка и сам цветок - простые объекты. Ветки дерева - составные объекты.<br><br>
<br>Интерфейс Компонент
<br>Конкретный Компонент
<br>Контейнер
<br>Клиент
<br><br>
<br>Когда вам нужно представить древовидную структуру объектов.
<br>Когда клиенты должны единообразно трактовать простые и составные объекты.
<br><br>
<br>Разбейте бизнес-логику на простые компоненты и контейнеры.
<br>Создайте общий интерфейс для всех компонентов.
<br>Создайте класс компонентов-листьев и класс компонентов-контейнеров.
<br>Реализуйте методы интерфейса компонентов в контейнере.
<br>Добавьте операции добавления и удаления дочерних компонентов в класс контейнеров.
<br><br><br>
<br>Упрощает архитектуру клиента при работе со сложным деревом компонентов.
<br>Облегчает добавление новых видов компонентов.
<br><br>
<br>Создаёт слишком общий дизайн классов.
<br><br>
<br>Строитель позволяет пошагово сооружать дерево Компоновщика.
<br>Компоновщик и Декоратор имеют похожие структуры классов из-за того, что оба построены на рекурсивной вложенности.
<br>Прототип позволяет клонировать сложные структуры объектов.
<br><br><br>// Паттерн Компоновщик
//
// Назначение: Позволяет сгруппировать объекты в древовидную структуру, а затем
// работать с ними так, как будто это единичный объект.

using System;
using System.Collections.Generic;

namespace RefactoringGuru.DesignPatterns.Composite.Conceptual
{
    // Базовый класс Компонент объявляет общие операции как для простых, так и
    // для сложных объектов структуры.
    abstract class Component
    {
        public Component() { }

        // Базовый Компонент может сам реализовать некоторое поведение по
        // умолчанию или поручить это конкретным классам, объявив метод,
        // содержащий поведение абстрактным.
        public abstract string Operation();

        // В некоторых случаях целесообразно определить операции управления
        // потомками прямо в базовом классе Компонент. Таким образом, вам не
        // нужно будет предоставлять  конкретные классы компонентов клиентскому
        // коду, даже во время сборки дерева объектов. Недостаток такого подхода
        // в том, что эти методы будут пустыми для компонентов уровня листа.
        public virtual void Add(Component component)
        {
            throw new NotImplementedException();
        }

        public virtual void Remove(Component component)
        {
            throw new NotImplementedException();
        }

        // Вы можете предоставить метод, который позволит клиентскому коду
        // понять, может ли компонент иметь вложенные объекты.
        public virtual bool IsComposite()
        {
            return true;
        }
    }

    // Класс Лист представляет собой конечные объекты структуры. Лист не может
    // иметь вложенных компонентов.
    //
    // Обычно объекты Листьев выполняют фактическую работу, тогда как объекты
    // Контейнера лишь делегируют работу своим подкомпонентам.
    class Leaf : Component
    {
        public override string Operation()
        {
            return "Leaf";
        }

        public override bool IsComposite()
        {
            return false;
        }
    }

    // Класс Контейнер содержит сложные компоненты, которые могут иметь
    // вложенные компоненты. Обычно объекты Контейнеры делегируют фактическую
    // работу своим детям, а затем «суммируют» результат.
    class Composite : Component
    {
        protected List&lt;Component&gt; _children = new List&lt;Component&gt;();
        
        public override void Add(Component component)
        {
            this._children.Add(component);
        }

        public override void Remove(Component component)
        {
            this._children.Remove(component);
        }

        // Контейнер выполняет свою основную логику особым образом. Он проходит
        // рекурсивно через всех своих детей, собирая и суммируя их результаты.
        // Поскольку потомки контейнера передают эти вызовы своим потомкам и так
        // далее,  в результате обходится всё дерево объектов.
        public override string Operation()
        {
            int i = 0;
            string result = "Branch(";

            foreach (Component component in this._children)
            {
                result += component.Operation();
                if (i != this._children.Count - 1)
                {
                    result += "+";
                }
                i++;
            }
            
            return result + ")";
        }
    }

    class Client
    {
        // Клиентский код работает со всеми компонентами через базовый
        // интерфейс.
        public void ClientCode(Component leaf)
        {
            Console.WriteLine($"RESULT: {leaf.Operation()}\n");
        }

        // Благодаря тому, что операции управления потомками объявлены в базовом
        // классе Компонента, клиентский код может работать как с простыми, так
        // и со сложными компонентами, вне зависимости от их конкретных классов.
        public void ClientCode2(Component component1, Component component2)
        {
            if (component1.IsComposite())
            {
                component1.Add(component2);
            }
            
            Console.WriteLine($"RESULT: {component1.Operation()}");
        }
    }
    
    class Program
    {
        static void Main(string[] args)
        {
            Client client = new Client();

            // Таким образом, клиентский код может поддерживать простые
            // компоненты-листья...
            Leaf leaf = new Leaf();
            Console.WriteLine("Client: I get a simple component:");
            client.ClientCode(leaf);

            // ...а также сложные контейнеры.
            Composite tree = new Composite();
            Composite branch1 = new Composite();
            branch1.Add(new Leaf());
            branch1.Add(new Leaf());
            Composite branch2 = new Composite();
            branch2.Add(new Leaf());
            tree.Add(branch1);
            tree.Add(branch2);
            Console.WriteLine("Client: Now I've got a composite tree:");
            client.ClientCode(tree);

            Console.Write("Client: I don't need to check the components classes even when managing the tree:\n");
            client.ClientCode2(tree, leaf);
        }
    }
}
Copy]]></description><link>04.-literature-notes/погружение-в-паттерны-проектирования-by-alexander-shvets/компоновщик-(composite).html</link><guid isPermaLink="false">04. Literature Notes/Погружение в ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ by Alexander Shvets/КОМПОНОВЩИК (Composite).md</guid><pubDate>Wed, 08 May 2024 15:57:57 GMT</pubDate></item><item><title><![CDATA[ЛЕГКОВЕС (Приспособленец, Кэш, Flyweight)]]></title><description><![CDATA[ 
 <br><br>Недостаток оперативной памяти при использовании большого количества объектов.<br><br>Паттерн "Легковес" разделяет данные объектов на две части: легковесы и контексты. Легковесы содержат повторяющееся состояние, а контексты — уникальное для каждого объекта состояние.<br><br>Школьный ящик — это легковес, а вещи, которые находятся внутри ящика, — контекст. Все ящики одного типа имеют одинаковый дизайн и свойства, но содержимое каждого ящика может быть уникальным.<br><br>
<br>Легковес содержит повторяющееся состояние.
<br>Контекст содержит уникальное для каждого объекта состояние.
<br>Фабрика легковесов управляет созданием и повторным использованием легковесов.
<br><br>Когда нужно создавать большое количество объектов, но не хватает оперативной памяти.<br><br>
<br>Разделите поля класса на внутреннее состояние и контекст.
<br>Оставьте поля внутреннего состояния в классе, а поля контекста сделайте параметрами методов.
<br>Создайте фабрику, которая кеширует и повторно отдаёт уже созданные объекты.
<br>Клиент должен хранить или вычислять значения контекста и передавать его в методы объекта легковеса.
<br><br>
<br>Экономит оперативную память.
<br>Расходует процессорное время на поиск/вычисление контекста.
<br>Усложняет код программы из-за введения множества дополнительных классов.
<br><br>
<br>Компоновщик часто совмещают с Легковесом, чтобы сэкономить память.
<br>Легковес напоминает Одиночку, но различие заключается в том, что у Легковеса может быть множество объектов, а они должны быть неизменяемыми.
<br><br><br>// Паттерн Легковес
//
// Назначение: Позволяет вместить бóльшее количество объектов в отведённую
// оперативную память. Легковес экономит память, разделяя общее состояние
// объектов между собой, вместо хранения одинаковых данных в каждом объекте.

using System;
using System.Collections.Generic;
using System.Linq;
// Используем библиотеку Json.NET, загрузить можно через NuGet Package Manager
using Newtonsoft.Json;

namespace RefactoringGuru.DesignPatterns.Flyweight.Conceptual
{
    // Легковес хранит общую часть состояния (также называемую внутренним
    // состоянием), которая принадлежит нескольким реальным бизнес-объектам.
    // Легковес принимает оставшуюся часть состояния (внешнее состояние,
    // уникальное для каждого объекта) через его параметры метода.
    public class Flyweight
    {
        private Car _sharedState;

        public Flyweight(Car car)
        {
            this._sharedState = car;
        }

        public void Operation(Car uniqueState)
        {
            string s = JsonConvert.SerializeObject(this._sharedState);
            string u = JsonConvert.SerializeObject(uniqueState);
            Console.WriteLine($"Flyweight: Displaying shared {s} and unique {u} state.");
        }
    }

    // Фабрика Легковесов создает объекты-Легковесы и управляет ими. Она
    // обеспечивает правильное разделение легковесов. Когда клиент запрашивает
    // легковес, фабрика либо возвращает существующий экземпляр, либо создает
    // новый, если он ещё не существует.
    public class FlyweightFactory
    {
        private List&lt;Tuple&lt;Flyweight, string&gt;&gt; flyweights = new List&lt;Tuple&lt;Flyweight, string&gt;&gt;();

        public FlyweightFactory(params Car[] args)
        {
            foreach (var elem in args)
            {
                flyweights.Add(new Tuple&lt;Flyweight, string&gt;(new Flyweight(elem), this.getKey(elem)));
            }
        }

        // Возвращает хеш строки Легковеса для данного состояния.
        public string getKey(Car key)
        {
            List&lt;string&gt; elements = new List&lt;string&gt;();

            elements.Add(key.Model);
            elements.Add(key.Color);
            elements.Add(key.Company);

            if (key.Owner != null &amp;&amp; key.Number != null)
            {
                elements.Add(key.Number);
                elements.Add(key.Owner);
            }

            elements.Sort();

            return string.Join("_", elements);
        }

        // Возвращает существующий Легковес с заданным состоянием или создает
        // новый.
        public Flyweight GetFlyweight(Car sharedState)
        {
            string key = this.getKey(sharedState);

            if (flyweights.Where(t =&gt; t.Item2 == key).Count() == 0)
            {
                Console.WriteLine("FlyweightFactory: Can't find a flyweight, creating new one.");
                this.flyweights.Add(new Tuple&lt;Flyweight, string&gt;(new Flyweight(sharedState), key));
            }
            else
            {
                Console.WriteLine("FlyweightFactory: Reusing existing flyweight.");
            }
            return this.flyweights.Where(t =&gt; t.Item2 == key).FirstOrDefault().Item1;
        }

        public void listFlyweights()
        {
            var count = flyweights.Count;
            Console.WriteLine($"\nFlyweightFactory: I have {count} flyweights:");
            foreach (var flyweight in flyweights)
            {
                Console.WriteLine(flyweight.Item2);
            }
        }
    }

    public class Car
    {
        public string Owner { get; set; }

        public string Number { get; set; }

        public string Company { get; set; }

        public string Model { get; set; }

        public string Color { get; set; }
    }

    class Program
    {
        static void Main(string[] args)
        {
            // Клиентский код обычно создает кучу предварительно заполненных
            // легковесов на этапе инициализации приложения.
            var factory = new FlyweightFactory(
                new Car { Company = "Chevrolet", Model = "Camaro2018", Color = "pink" },
                new Car { Company = "Mercedes Benz", Model = "C300", Color = "black" },
                new Car { Company = "Mercedes Benz", Model = "C500", Color = "red" },
                new Car { Company = "BMW", Model = "M5", Color = "red" },
                new Car { Company = "BMW", Model = "X6", Color = "white" }
            );
            factory.listFlyweights();

            addCarToPoliceDatabase(factory, new Car {
                Number = "CL234IR",
                Owner = "James Doe",
                Company = "BMW",
                Model = "M5",
                Color = "red"
            });

            addCarToPoliceDatabase(factory, new Car {
                Number = "CL234IR",
                Owner = "James Doe",
                Company = "BMW",
                Model = "X1",
                Color = "red"
            });

            factory.listFlyweights();
        }

        public static void addCarToPoliceDatabase(FlyweightFactory factory, Car car)
        {
            Console.WriteLine("\nClient: Adding a car to database.");

            var flyweight = factory.GetFlyweight(new Car {
                Color = car.Color,
                Model = car.Model,
                Company = car.Company
            });

            // Клиентский код либо сохраняет, либо вычисляет внешнее состояние и
            // передает его методам легковеса.
            flyweight.Operation(car);
        }
    }
}
Copy]]></description><link>04.-literature-notes/погружение-в-паттерны-проектирования-by-alexander-shvets/легковес-(приспособленец,-кэш,-flyweight).html</link><guid isPermaLink="false">04. Literature Notes/Погружение в ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ by Alexander Shvets/ЛЕГКОВЕС (Приспособленец, Кэш, Flyweight).md</guid><pubDate>Wed, 08 May 2024 15:53:46 GMT</pubDate></item><item><title><![CDATA[МОСТ (Bridge)]]></title><description><![CDATA[ 
 <br><br>Монолитные классы с несколькими реализациями функциональности могут быть трудными для понимания и редактирования.<br><br>Мост разделяет монолитный класс на несколько иерархий, позволяя менять их код независимо друг от друга.<br><br>Мост похож на мост, который разделяет дорогу на две части.<br><br>Абстракция делегирует свою работу объекту реализации через ссылку на него.<br><br>Когда нужно расширять класс в двух независимых плоскостях, или менять реализацию во время выполнения программы.<br><br>
<br>Определить непересекающиеся измерения в классах.
<br>Определить операции, которые нужны клиентам.
<br>Определить общий интерфейс реализации.
<br>Создать классы конкретной реализации.
<br>Добавить ссылку на объект реализации в абстракцию и делегировать ему работу.
<br>Создать подклассы абстракции, если нужно.
<br>Подать объект реализации в конструктор абстракции.
<br><br>
<br>Позволяет строить платформо-независимые программы.
<br>Скрывает ненужные детали реализации от клиентского кода.
<br>Реализует принцип открытости/закрытости.
<br>Усложняет код программы из-за введения дополнительных классов.
<br><br>
<br>Мост проектируется заранее, чтобы делать большие части приложения отдельно друг от друга. Адаптер применяется после того, чтобы заставить несовместимые классы работать вместе.
<br>Мост, Стратегия, Состояние и Адаптер используют похожие структуры классов, основанные на принципе "композиции" - делегирования работы другим объектам. Однако, они решают разные проблемы, так как описывают различные сценарии использования.
<br>Абстрактная фабрика может работать вместе с Мостом, особенно если у вас есть абстракции, которые могут работать только с некоторыми реализациями. В этом случае фабрика будет определять типы создаваемых абстракций и реализаций.
<br>Паттерн Строитель может быть выполнен в виде Моста: директор будет играть роль абстракции, а строители - реализации.
<br><br><br>// Паттерн Мост
//
// Назначение: Разделяет один или несколько классов на две отдельные иерархии —
// абстракцию и реализацию, позволяя изменять их независимо друг от друга.
//
//               A
//            /     \                        A         N
//          Aa      Ab        ===&gt;        /     \     / \
//         / \     /  \                 Aa(N) Ab(N)  1   2
//       Aa1 Aa2  Ab1 Ab2

using System;

namespace RefactoringGuru.DesignPatterns.Bridge.Conceptual
{
    // Абстракция устанавливает интерфейс для «управляющей» части двух иерархий
    // классов. Она содержит ссылку на объект из иерархии Реализации и
    // делегирует ему всю настоящую работу.
    class Abstraction
    {
        protected IImplementation _implementation;
		
        public Abstraction(IImplementation implementation)
        {
            this._implementation = implementation;
        }
		
        public virtual string Operation()
        {
            return "Abstract: Base operation with:\n" + 
                _implementation.OperationImplementation();
        }
    }

    // Можно расширить Абстракцию без изменения классов Реализации.
    class ExtendedAbstraction : Abstraction
    {
        public ExtendedAbstraction(IImplementation implementation) : base(implementation)
        {
		}
		
        public override string Operation()
        {
            return "ExtendedAbstraction: Extended operation with:\n" +
                base._implementation.OperationImplementation();
        }
    }

    // Реализация устанавливает интерфейс для всех классов реализации. Он не
    // должен соответствовать интерфейсу Абстракции. На практике оба интерфейса
    // могут быть совершенно разными. Как правило, интерфейс Реализации
    // предоставляет только примитивные операции, в то время как Абстракция
    // определяет операции более высокого уровня, основанные на этих примитивах.
    public interface IImplementation
    {
        string OperationImplementation();
    }

    // Каждая Конкретная Реализация соответствует определённой платформе и
    // реализует интерфейс Реализации с использованием API этой платформы.
    class ConcreteImplementationA : IImplementation
    {
        public string OperationImplementation()
        {
            return "ConcreteImplementationA: The result in platform A.\n";
        }
    }

    class ConcreteImplementationB : IImplementation
    {
        public string OperationImplementation()
        {
            return "ConcreteImplementationA: The result in platform B.\n";
        }
    }

    class Client
    {
        // За исключением этапа инициализации, когда объект Абстракции
        // связывается с определённым объектом Реализации, клиентский код должен
        // зависеть только от класса Абстракции. Таким образом, клиентский код
        // может поддерживать любую комбинацию абстракции и реализации.
        public void ClientCode(Abstraction abstraction)
        {
            Console.Write(abstraction.Operation());
        }
    }
    
    class Program
    {
        static void Main(string[] args)
        {
            Client client = new Client();

            Abstraction abstraction;
            // Клиентский код должен работать с любой предварительно
            // сконфигурированной комбинацией абстракции и реализации.
            abstraction = new Abstraction(new ConcreteImplementationA());
            client.ClientCode(abstraction);
            
            Console.WriteLine();
            
            abstraction = new ExtendedAbstraction(new ConcreteImplementationB());
            client.ClientCode(abstraction);
        }
    }
}
Copy]]></description><link>04.-literature-notes/погружение-в-паттерны-проектирования-by-alexander-shvets/мост-(bridge).html</link><guid isPermaLink="false">04. Literature Notes/Погружение в ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ by Alexander Shvets/МОСТ (Bridge).md</guid><pubDate>Wed, 08 May 2024 15:53:26 GMT</pubDate></item><item><title><![CDATA[НАБЛЮДАТЕЛЬ (Издатель-Подписчик, Слушатель, Observer)]]></title><description><![CDATA[ 
 <br><br>Необходимо разделить функциональность на независимые части, которые могут реагировать на изменения друг друга.<br><br>Наблюдатель (Observer) - паттерн, предоставляющий механизм оповещения объектов об изменении состояния других объектов.<br><br>Когда вы подписываетесь на канал в YouTube, вы становитесь наблюдателем за этим каналом. Когда на канале появляется новое видео, YouTube отправляет вам уведомление, чтобы вы могли посмотреть его.<br><br>Издатель и подписчики связаны между собой через общий интерфейс. Издатель хранит список подписчиков и оповещает их об изменениях своего состояния.<br><br>
<br>Когда одни объекты должны быть оповещены о изменении состояния других объектов при этом не зная, кто именно эти объекты.
<br>Когда один объект должен оповещать множество других объектов без предположений об их числе или конкретных типах.
<br><br>
<br>Создайте интерфейс для подписчиков и определите метод оповещения.
<br>Создайте интерфейс для издателя и определите методы управления подпиской.
<br>Создайте конкретные классы издателей и реализуйте их методы изменения состояния и оповещения подписчиков.
<br>Создайте конкретные классы подписчиков и реализуйте их методы обработки оповещений.
<br>Добавьте возможность подписки и отписки подписчиков для издателя.
<br><br>Преимущества:<br>
<br>Уменьшение связанности между объектами.
<br>Издатели не зависят от конкретных классов подписчиков и наоборот.
<br>Подписчики могут подписываться и отписываться на лету.
<br>Реализует принцип открытости/закрытости.
<br>Недостатки:<br>
<br>Подписчики оповещаются в случайном порядке.
<br>Возможны проблемы с производительностью.
<br><br>
<br>Цепочка обязанностей (Chain of Responsibility), Команда (Command), Посредник (Mediator) и Наблюдатель (Observer) показывают различные способы работы отправителей запросов с их получателями.
<br><br><br>// Паттерн Наблюдатель
//
// Назначение: Создаёт механизм подписки, позволяющий одним объектам следить и
// реагировать на события, происходящие в других объектах.
//
// Обратите внимание, что существует множество различных терминов с похожими
// значениями, связанных с этим паттерном. Просто помните, что Субъекта также
// называют Издателем, а Наблюдателя часто называют Подписчиком и наоборот.
// Также глаголы «наблюдать», «слушать» или «отслеживать» обычно означают одно и
// то же.

using System;
using System.Collections.Generic;
using System.Threading;

namespace RefactoringGuru.DesignPatterns.Observer.Conceptual
{
    public interface IObserver
    {
        // Получает обновление от издателя
        void Update(ISubject subject);
    }

    public interface ISubject
    {
        // Присоединяет наблюдателя к издателю.
        void Attach(IObserver observer);

        // Отсоединяет наблюдателя от издателя.
        void Detach(IObserver observer);

        // Уведомляет всех наблюдателей о событии.
        void Notify();
    }

    // Издатель владеет некоторым важным состоянием и оповещает наблюдателей о
    // его изменениях.
    public class Subject : ISubject
    {
        // Для удобства в этой переменной хранится состояние Издателя,
        // необходимое всем подписчикам.
        public int State { get; set; } = -0;

        // Список подписчиков. В реальной жизни список подписчиков может
        // храниться в более подробном виде (классифицируется по типу события и
        // т.д.)
        private List&lt;IObserver&gt; _observers = new List&lt;IObserver&gt;();

        // Методы управления подпиской.
        public void Attach(IObserver observer)
        {
            Console.WriteLine("Subject: Attached an observer.");
            this._observers.Add(observer);
        }

        public void Detach(IObserver observer)
        {
            this._observers.Remove(observer);
            Console.WriteLine("Subject: Detached an observer.");
        }

        // Запуск обновления в каждом подписчике.
        public void Notify()
        {
            Console.WriteLine("Subject: Notifying observers...");

            foreach (var observer in _observers)
            {
                observer.Update(this);
            }
        }

        // Обычно логика подписки – только часть того, что делает Издатель.
        // Издатели часто содержат некоторую важную бизнес-логику, которая
        // запускает метод уведомления всякий раз, когда должно произойти что-то
        // важное (или после этого).
        public void SomeBusinessLogic()
        {
            Console.WriteLine("\nSubject: I'm doing something important.");
            this.State = new Random().Next(0, 10);

            Thread.Sleep(15);

            Console.WriteLine("Subject: My state has just changed to: " + this.State);
            this.Notify();
        }
    }

    // Конкретные Наблюдатели реагируют на обновления, выпущенные Издателем, к
    // которому они прикреплены.
    class ConcreteObserverA : IObserver
    {
        public void Update(ISubject subject)
        {            
            if ((subject as Subject).State &lt; 3)
            {
                Console.WriteLine("ConcreteObserverA: Reacted to the event.");
            }
        }
    }

    class ConcreteObserverB : IObserver
    {
        public void Update(ISubject subject)
        {
            if ((subject as Subject).State == 0 || (subject as Subject).State &gt;= 2)
            {
                Console.WriteLine("ConcreteObserverB: Reacted to the event.");
            }
        }
    }
    
    class Program
    {
        static void Main(string[] args)
        {
            // Клиентский код.
            var subject = new Subject();
            var observerA = new ConcreteObserverA();
            subject.Attach(observerA);

            var observerB = new ConcreteObserverB();
            subject.Attach(observerB);

            subject.SomeBusinessLogic();
            subject.SomeBusinessLogic();

            subject.Detach(observerB);

            subject.SomeBusinessLogic();
        }
    }
}
Copy<br><br>Subject: Attached an observer.
Subject: Attached an observer.

Subject: I'm doing something important.
Subject: My state has just changed to: 2
Subject: Notifying observers...
ConcreteObserverA: Reacted to the event.
ConcreteObserverB: Reacted to the event.

Subject: I'm doing something important.
Subject: My state has just changed to: 1
Subject: Notifying observers...
ConcreteObserverA: Reacted to the event.
Subject: Detached an observer.

Subject: I'm doing something important.
Subject: My state has just changed to: 5
Subject: Notifying observers...
Copy]]></description><link>04.-literature-notes/погружение-в-паттерны-проектирования-by-alexander-shvets/наблюдатель-(издатель-подписчик,-слушатель,-observer).html</link><guid isPermaLink="false">04. Literature Notes/Погружение в ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ by Alexander Shvets/НАБЛЮДАТЕЛЬ (Издатель-Подписчик, Слушатель, Observer).md</guid><pubDate>Wed, 08 May 2024 15:51:26 GMT</pubDate></item><item><title><![CDATA[ОДИНОЧКА]]></title><description><![CDATA[ 
 <br><br>Как создать класс, который имеет только один экземпляр и обеспечить к нему глобальную точку доступа?<br><br>Скрыть конструктор по умолчанию и создать публичный статический метод, который и будет контролировать жизненный цикл объекта-одиночки.<br><br>Правительство государства - хороший пример одиночества. В государстве может быть только одно официальное правительство. Независимо от того, кто конкретно заседает в правительстве, оно имеет глобальную точку доступа "Правительство страны N".<br><br>Одиночка определяет статический метод getInstance, который возвращает единственный экземпляр своего класса. Конструктор одиночки должен быть скрыт от клиентов. Вызов метода getInstance должен стать единственным способом получить объект этого класса.<br><br>Когда в программе должен быть единственный экземпляр какого-то класса, доступный всем клиентам (например, общий доступ к базе данных из разных частей программы).<br><br>
<br>Добавьте в класс приватное статическое поле, которое будет содержать одиночный объект.
<br>Объявите статический создающий метод, который будет использоваться для получения одиночки.
<br>Добавьте «ленивую инициализацию» (создание объекта при первом вызове метода) в создающий метод одиночки.
<br>Сделайте конструктор класса приватным.
<br>В клиентском коде замените вызовы конструктора одиночка вызовами его создающего метода.
<br><br><br>
<br>Гарантирует наличие единственного экземпляра класса.
<br>Предоставляет к нему глобальную точку доступа.
<br>Реализует отложенную инициализацию объекта-одиночки.
<br><br>
<br>Нарушает принцип единственной ответственности класса.
<br>Маскирует плохой дизайн.
<br>Проблемы многопоточности.
<br>Требует постоянного создания Mock-объектов при юнит-тестировании.
<br><br>
<br>Фасад можно сделать Одиночкой, так как обычно нужен только один объект-фасад.
<br>Легковес может напоминать Одиночку, если для конкретной задачи у вас получилось свести количество объектов к одному. Но помните, что между паттернами есть два кардинальных отличия: 1) В отличие от Одиночки, вы можете иметь множество объектов-легковесов. 2) Объекты-легковесы должны быть неизменяемыми, тогда как объект-одиночка допускает изменение своего состояния.
<br>Абстрактная фабрика, Строитель
<br><br><br>NonThreadSafe<br>// Паттерн Одиночка
//
// Назначение: Гарантирует, что у класса есть только один экземпляр, и
// предоставляет к нему глобальную точку доступа.

using System;

namespace RefactoringGuru.DesignPatterns.Singleton.Conceptual.NonThreadSafe
{
    // Класс Одиночка предоставляет метод `GetInstance`, который ведёт себя как
    // альтернативный конструктор и позволяет клиентам получать один и тот же
    // экземпляр класса при каждом вызове.

    // EN : The Singleton should always be a 'sealed' class to prevent class
    // inheritance through external classes and also through nested classes.
    public sealed class Singleton
    {
        // Конструктор Одиночки всегда должен быть скрытым, чтобы предотвратить
        // создание объекта через оператор new.
        private Singleton() { }

        // Объект одиночки храниться в статичном поле класса. Существует
        // несколько способов инициализировать это поле, и все они имеют разные
        // достоинства и недостатки. В этом примере мы рассмотрим простейший из
        // них, недостатком которого является полная неспособность правильно
        // работать в многопоточной среде.
        private static Singleton _instance;

        // Это статический метод, управляющий доступом к экземпляру одиночки.
        // При первом запуске, он создаёт экземпляр одиночки и помещает его в
        // статическое поле. При последующих запусках, он возвращает клиенту
        // объект, хранящийся в статическом поле.
        public static Singleton GetInstance()
        {
            if (_instance == null)
            {
                _instance = new Singleton();
            }
            return _instance;
        }

        // Наконец, любой одиночка должен содержать некоторую бизнес-логику,
        // которая может быть выполнена на его экземпляре.
        public void someBusinessLogic()
        {
            // ...
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            // Клиентский код.
            Singleton s1 = Singleton.GetInstance();
            Singleton s2 = Singleton.GetInstance();

            if (s1 == s2)
            {
                Console.WriteLine("Singleton works, both variables contain the same instance.");
            }
            else
            {
                Console.WriteLine("Singleton failed, variables contain different instances.");
            }
        }
    }
}
Copy<br>ThreadSafe<br>// Паттерн Одиночка
//
// Назначение: Гарантирует, что у класса есть только один экземпляр, и
// предоставляет к нему глобальную точку доступа.

using System;
using System.Threading;

namespace Singleton
{
    // Эта реализация Одиночки называется "блокировка с двойной проверкой"
    // (double check lock). Она безопасна в многопоточной среде, а также
    // позволяет отложенную инициализацию объекта Одиночки.
    class Singleton
    {
        private Singleton() { }

        private static Singleton _instance;

        // У нас теперь есть объект-блокировка для синхронизации потоков во
        // время первого доступа к Одиночке.
        private static readonly object _lock = new object();

        public static Singleton GetInstance(string value)
        {
            // Это условие нужно для того, чтобы не стопорить потоки блокировкой
            // после того как объект-одиночка уже создан.
            if (_instance == null)
            {
                // Теперь представьте, что программа была только-только
                // запущена. Объекта-одиночки ещё никто не создавал, поэтому
                // несколько потоков вполне могли одновременно пройти через
                // предыдущее условие и достигнуть блокировки. Самый быстрый
                // поток поставит блокировку и двинется внутрь секции, пока
                // другие будут здесь его ожидать.
                lock (_lock)
                {
                    // Первый поток достигает этого условия и проходит внутрь,
                    // создавая объект-одиночку. Как только этот поток покинет
                    // секцию и освободит блокировку, следующий поток может
                    // снова установить блокировку и зайти внутрь. Однако теперь
                    // экземпляр одиночки уже будет создан и поток не сможет
                    // пройти через это условие, а значит новый объект не будет
                    // создан.
                    if (_instance == null)
                    {
                        _instance = new Singleton();
                        _instance.Value = value;
                    }
                }
            }
            return _instance;
        }

        // Мы используем это поле, чтобы доказать, что наш Одиночка
        // действительно работает.
        public string Value { get; set; }
    }

    class Program
    {
        static void Main(string[] args)
        {
            // Клиентский код.
            
            Console.WriteLine(
                "{0}\n{1}\n\n{2}\n",
                "If you see the same value, then singleton was reused (yay!)",
                "If you see different values, then 2 singletons were created (booo!!)",
                "RESULT:"
            );
            
            Thread process1 = new Thread(() =&gt;
            {
                TestSingleton("FOO");
            });
            Thread process2 = new Thread(() =&gt;
            {
                TestSingleton("BAR");
            });
            
            process1.Start();
            process2.Start();
            
            process1.Join();
            process2.Join();
        }
        
        public static void TestSingleton(string value)
        {
            Singleton singleton = Singleton.GetInstance(value);
            Console.WriteLine(singleton.Value);
        } 
    }
}
Copy]]></description><link>04.-literature-notes/погружение-в-паттерны-проектирования-by-alexander-shvets/одиночка.html</link><guid isPermaLink="false">04. Literature Notes/Погружение в ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ by Alexander Shvets/ОДИНОЧКА.md</guid><pubDate>Thu, 09 May 2024 11:17:39 GMT</pubDate></item><item><title><![CDATA[ОСНОВЫ ПАТТЕРНОВ]]></title><description><![CDATA[ 
 ]]></description><link>04.-literature-notes/погружение-в-паттерны-проектирования-by-alexander-shvets/основы-паттернов.html</link><guid isPermaLink="false">04. Literature Notes/Погружение в ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ by Alexander Shvets/ОСНОВЫ ПАТТЕРНОВ.md</guid><pubDate>Wed, 08 May 2024 16:12:39 GMT</pubDate></item><item><title><![CDATA[Погружение в ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ by Alexander Shvets]]></title><description><![CDATA[ 
 <br><br><br>Объектно-ориентированное программирование (ООП) — это методология программирования, в которой все важные вещи представлены объектами, каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования. В этой методологии: <br>
<br>Объекты имеют набор свойств, таких как имя, пол, возраст, вес, цвет, любимая еда и прочее, называемый полями класса.
<br>Объекты могут выполнять различные действия, такие как бегать, дышать, спать, есть и мурчать, называемые методами класса.
<br><img alt="Погружение в ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ by Alexander Shvets-240509-1.png" src="lib/media/погружение-в-паттерны-проектирования-by-alexander-shvets-240509-1.png"><br>Существуют иерархии классов, где классы называемые подклассами наследуют свойства и методы от родительских классов, называемых суперклассами. Например, классы Кот и Собака могут быть подклассами класса Животные, а классы Животные и Рыбы могут быть подклассами класса Организмы.<br><img alt="Погружение в ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ by Alexander Shvets-240509-2.png" src="lib/media/погружение-в-паттерны-проектирования-by-alexander-shvets-240509-2.png"><br><img alt="Погружение в ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ by Alexander Shvets-240509-3.png" src="lib/media/погружение-в-паттерны-проектирования-by-alexander-shvets-240509-3.png"><br>Классы могут переопределять поведение методов, которые им достались от суперкласса, добавляя что-то к результату выполнения родительского метода.<br><br><img alt="Погружение в ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ by Alexander Shvets-240509-4.png" src="lib/media/погружение-в-паттерны-проектирования-by-alexander-shvets-240509-4.png"><br>ООП имеет 4 главные концепции: абстракция, инкапсуляция, наследование и полиморфизм.<br>Абстракция позволяет моделировать свойства и поведение объектов программы, игнорируя незначительные детали.<br>Инкапсуляция скрывает часть состояния и поведения объектов от других объектов, предоставляя доступ только к интерфейсу взаимодействия.<br>Наследование позволяет создавать новые классы на основе существующих, повторно используя код.<br>Полиморфизм позволяет общим методам, объявленным в родительском классе, быть переопределенными и реализованными в подклассах.<br>Программирование в стиле ООП отличается от других методологий программирования именно этими концепциями.<br><br><br>Кроме наследования и реализации, есть ещё несколько видов отношений между объектами:<br><br><img alt="Погружение в ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ by Alexander Shvets-240509-5.png" src="lib/media/погружение-в-паттерны-проектирования-by-alexander-shvets-240509-5.png"><br>
Зависимость в UML-диаграммах. Профессор зависит от учебного курса.<br>Зависимость — это базовая связь между классами, которая показывает, что один класс скорее всего придётся менять при изменении названия или сигнатуры методов второго. Степень зависимости можно ослабить, если вместо конкретных классов ссылаться на абстрактные классы или интерфейсы.<br><br><img alt="Погружение в ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ by Alexander Shvets-240509-6.png" src="lib/media/погружение-в-паттерны-проектирования-by-alexander-shvets-240509-6.png"><br>
Ассоциация в UML-диаграммах. Профессор взаимодействует со студентом.<br>Ассоциация — это когда один объект взаимодействует с другим. Ассоциацию можно рассматривать как строгий вариант зависимости, при котором один объект всегда имеет доступ к объекту, с которым он взаимодействует, в то время как при простой зависимости связь может быть не постоянной и не такой явной.<br><br><img alt="Погружение в ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ by Alexander Shvets-240509-7.png" src="lib/media/погружение-в-паттерны-проектирования-by-alexander-shvets-240509-7.png"><br>
Агрегация в UML-диаграммах. Кафедра содержит профессоров.<br>Агрегация — это специализированная разновидность ассоциации, которая описывает отношения один-ко-многим, многие-ко-многим, часть-целое между несколькими объектами. Обычно при агрегации один объект содержит другие, то есть выступает контейнером или коллекцией.<br><br><img alt="Погружение в ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ by Alexander Shvets-240509-8.png" src="lib/media/погружение-в-паттерны-проектирования-by-alexander-shvets-240509-8.png"><br>
Композиция в UML-диаграммах. Университет состоит из кафедр.<br>Композиция - это более строгий вид агрегации, когда один объект содержит другие и компонент может существовать только как часть контейнера.<br><br><img alt="Погружение в ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ by Alexander Shvets-240509-9.png" src="lib/media/погружение-в-паттерны-проектирования-by-alexander-shvets-240509-9.png"><br>Связи между объектами и классами — от самой слабой, до самой сильной.<br><br>Прежде чем перейти к изучению паттернов, давайте поговорим о самом процессе проектирования и о том, к чему надо стремиться, а также о том, чего надо избегать.<br>Использование старых наработок в новых проектах помогает снизить стоимость и время разработки. Однако, не всегда можно приспособить код к новым условиям. Паттерны проектирования помогают повысить гибкость архитектуры и упростить дальнейшее повторное использование кода.<br>Важно учитывать будущие изменения при проектировании архитектуры и написании кода, так как изменения неизбежны и могут прийти как извне, так и из-за улучшенного понимания проблемы в процессе её решения.<br><br><br>Что такое хороший дизайн? Как его оценивать и какие правила придерживаться при разработке? Как обеспечить гибкость, связанность, управляемость, стабильность и понятность кода?<br>Давайте рассмотрим универсальные принципы проектирования, которые помогут ответить на эти вопросы самостоятельно.<br><br>Изолируя изменчивые части программы в отдельных модулях, классах или методах, вы уменьшаете количество кода, который затронут последующие изменения. Также уменьшится стоимость разработки и увеличится ваше преимущество перед конкурентами.<br>Пример инкапсуляции на уровне метода<br>Перенесите логику вычисления налогов в собственный метод, скрыв детали от оригинального метода. Теперь изменения налогов будут изолированы в рамках одного метода. Если логика вычисления налогов станет ещё более сложной, вам будет легче извлечь этот метод в собственный класс.<br>method getOrderTotal(order) is
    total = 0
    foreach item in order.lineItems
        total += item.price * item.quantity
    if order.country == "US"
        total += total * 0.07 // US sales tax
    else if order.country == "EU"
        total += total * 0.20 // European VAT
    return total
Copy<br>method getOrderTotal(order) is
    total = 0
    foreach item in order.lineItems
        total += item.price * item.quantity
    total += total * getTaxAmount(order.country)
    return total

method getTaxAmount(country) is
    if (country == "US")
        return 0.07 // US sales tax
    else if (country == "EU")
        return 0.20 // European VAT
    else
        return 0
Copy<br>Пример инкапсуляции на уровне класса<br>Объекты заказов станут делегировать вычисление налогов отдельному объекту-калькулятору налогов.<br><br>Important
Программируйте на уровне интерфейса, а не на уровне реализации. Код должен зависеть от абстракций, а не конкретных классов.  
<br>Гибкость архитектуры проявляется в возможности её дальнейшего расширения без необходимости модификации существующего кода. Например, класс Кот, который может есть любую еду, более гибок, чем тот, который может есть только сардельки, но и первый может есть сардельки, поскольку они также являются едой.<br>Для наладки взаимодействия между объектами разных классов можно начать с простой зависимости одного класса от другого. Однако более гибкий способ:<br>
<br>Определите, какие методы одного объекта должен использовать другой объект.
<br>Опишите эти методы в отдельном интерфейсе.
<br>Сделайте так, чтобы зависимость класса следовала этому интерфейсу. Для этого нужно добавить интерфейс в описание класса.
<br>Теперь можно сделать второй класс зависимым от интерфейса, а не от конкретного класса.
<br>Этот подход не обеспечивает немедленной выгоды, но позволяет использовать альтернативные реализации классов без изменения использующего их кода.<br>Пример:<br>Представьте, что вы делаете симулятор софтверной компании. У вас есть различные классы работников, которые выполняют разную работу внутри компании. Вы можете свести методы работы всех классов к одному виду, выделив для всех общий интерфейс Employee. Теперь можно применять полиморфизм в классе компании, рассматривая всех работников через интерфейс.<br>Однако класс компании всё ещё жёстко привязан к конкретным классам работников. Метод получения сотрудников в базовом классе компании можно сделать абстрактным, чтобы каждый тип компаний мог иметь собственный набор сотрудников.<br>После этих изменений код класса компании станет независимым от конкретных классов, и новые виды работников и компаний можно будет добавлять без изменений в основной код базового класса компаний. Это пример одного из паттернов, Фабричного метода.<br><br>Наследование — простой и быстрый способ повторного использования кода между классами. Два класса с дублирующимся кодом можно объединить в один базовый класс и перенести в него общее поведение.<br>Но у наследования есть проблемы, которые становятся очевидными только тогда, когда программа уже обросла классами, и изменить ситуацию трудно. Вот некоторые из возможных проблем с наследованием:<br>
<br>Подкласс не может отказаться от интерфейса или реализации своего родителя, что приводит к реализации не нужных методов.
<br>Переопределяя методы родителя, необходимо не сломать базовое поведение суперкласса, ведь подкласс может быть использован в любом коде, работающим с суперклассом.
<br>Наследование нарушает инкапсуляцию суперкласса, так как подклассам доступны детали родителя. Суперклассы могут сами стать зависимыми от подклассов.
<br>Подклассы слишком тесно связаны с родительским классом. Любое изменение в родителе может сломать поведение в подклассах.
<br>Повторное использование кода через наследование может привести к разрастанию иерархии классов.
<br>У наследования есть альтернатива, называемая композиция. Композиция — более свободный вид композиции, когда два объекта являются равноправными, и ни один из них не управляет жизненным циклом другого.<br>Пример<br>
Предположим, вам нужно смоделировать модельный ряд автопроизводителя. У вас есть легковые автомобили и грузовики. Причём они бывают с электрическим двигателем и с двигателем на бензине. К тому же они отличаются режимами навигации: есть модели с ручным управлением и автопилотом.  <br><img alt="Погружение в ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ by Alexander Shvets-240509-10.png" src="lib/media/погружение-в-паттерны-проектирования-by-alexander-shvets-240509-10.png"><br>Наследование: развитие классов в нескольких плоскостях (тип груза × тип двигателя × тип навигации) приводит к комбинаторному взрыву.<br>Каждый параметр приводит к умножению количества классов. Кроме того, возникает проблема дублирования кода, так как подклассы не могут наследовать нескольких родителей одновременно.<br>Решить проблему можно с помощью композиции. Вместо того, чтобы объекты сами реализовывали то или иное поведение, они могут делегировать его другим объектам. Композиция позволяет заменить тип двигателя автомобиля прямо во время выполнения программы, подставив в объект транспорта другой объект двигателя.<br>
<img alt="Погружение в ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ by Alexander Shvets-240509-11.png" src="lib/media/погружение-в-паттерны-проектирования-by-alexander-shvets-240509-11.png"><br>КОМПОЗИЦИЯ: различные виды функциональности выделены в собственные иерархии классов.<br>Такая структура свойственна паттерну Стратегия.<br><br><br>Рассмотрим ещё 5 принципов проектирования, известных как SOLID. Эти принципы были изложены Робертом Мартином в книге Agile Software Development, Principles, Patterns, and Practices. Цель принципов - повысить гибкость архитектуры, уменьшить связанность между её компонентами и облегчить повторное использование кода. Соблюдение этих принципов усложняет код программы, поэтому помните о балансе и не воспринимайте всё изложенное как догму.<br><br>Принцип единственной ответственности<br>Important
У класса должен быть только один мотив дляизменения.  
<br>Каждый класс должен отвечать только за одну часть функциональности программы, полностью инкапсулированную в нём. Принцип единственной ответственности нужен для борьбы со сложностью. Когда в вашем приложении всего 200 строк, дизайн не нужен: достаточно аккуратно написать 5-7 методов. Проблемы возникают, когда система растёт и класс разрастается, перестаёт помещаться в голове, навигация затрудняется, на глаза попадаются ненужные детали, связанные с другим аспектом, в результате количество понятий начинает превышать мозговой стек, и вы начинаете терять контроль над кодом. Если класс делает слишком много вещей сразу, вам приходится изменять его каждый раз, когда одна из этих вещей изменяется. Хорошо иметь возможность сосредоточиться на сложных аспектах системы по отдельности. Пример: класс Employee имеет сразу несколько причин для изменения — управление данными сотрудника и форматирование отчёта для печати. Проблему можно решить, выделив операцию печати в отдельный класс.<br><img alt="Погружение в ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ by Alexander Shvets-240509-12.png" src="lib/media/погружение-в-паттерны-проектирования-by-alexander-shvets-240509-12.png"><br>ДО: класс сотрудника содержит разнородные поведения.<br><img alt="Погружение в ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ by Alexander Shvets-240509-13.png" src="lib/media/погружение-в-паттерны-проектирования-by-alexander-shvets-240509-13.png"><br>ПОСЛЕ: лишнее поведение переехало в собственный класс.<br><br>Принцип открытости/закрытости<br>Important
Расширяйте классы, но не изменяйте их первоначаль-ный код.  
<br>Классы должны быть открыты для расширения и закрыты для изменения. Это означает, что вы можете расширить набор операций или добавить новые поля, создав собственный подкласс, и не ломать существующий код при внесении изменений в программу.<br>Класс может быть открытым, если он доступен для расширения. Класс может быть закрытым (а лучше сказать, законченным), если он готов к использованию другими классами и интерфейс класса уже окончательно определен и не будет изменяться в будущем.<br>Если класс уже готов к использованию другими классами и включен в проект, не следует пытаться модифицировать его содержимое. Вместо этого вы можете создать подкласс и расширить базовое поведение, не изменяя код родительского класса напрямую.<br>Не следует следовать этому принципу буквально для каждого изменения. Если вам нужно исправить ошибку в исходном классе, просто сделайте это. Нет смысла решать проблему родителя в дочернем классе.<br>Пример: класс заказов имеет метод расчета стоимости доставки, при этом способы доставки "зашиты" непосредственно в метод. Проблему можно решить, применив паттерн Стратегия. Для этого нужно выделить способы доставки в собственные классы с общим интерфейсом. Теперь при добавлении нового способа доставки нужно будет реализовать новый класс интерфейса доставки, не трогая класс заказов. Бонус этого решения в том, что расчет времени и даты доставки также можно поместить в новые классы, следуя принципу единственной ответственности.<br><img alt="Погружение в ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ by Alexander Shvets-240509-14.png" src="lib/media/погружение-в-паттерны-проектирования-by-alexander-shvets-240509-14.png"><br>ДО: код класса заказа нужно будет изменять при добавлении нового способа доставки.<br>
<img alt="Погружение в ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ by Alexander Shvets-240509-15.png" src="lib/media/погружение-в-паттерны-проектирования-by-alexander-shvets-240509-15.png"><br>ПОСЛЕ: новые способы доставки можно добавить, не трогая класс заказов.<br><br>Принцип подстановки Лисков<br>Important
Подклассы должны дополнять, а не замещать поведение базового класса.  
<br>Стремитесь создавать подклассы так, чтобы их объекты можно было подставлять вместо объектов базового класса, не ломая при этом функциональности клиентского кода. Принцип подстановки — это ряд проверок, которые помогают предсказать, останется ли подкласс совместим с остальным кодом программы, который до этого успешно работал, используя объекты базового класса. Это особенно важно при разработке библиотек и фреймворков, когда ваши классы используются другими людьми, и вы не можете повлиять на чужой клиентский код, даже если бы хотели.<br>Кратко о требованиях к подклассам:<br>
<br>Типы параметров метода подкласса должны совпадать или быть более абстрактными, чем типы параметров базового метода.
<br>Тип возвращаемого значения метода подкласса должен совпадать или быть подтипом возвращаемого значения базового метода.
<br>Метод не должен выбрасывать исключения, которые не свойственны базовому методу.
<br>Метод не должен ужесточать предусловия.
<br>Метод не должен ослаблять пост-условия.
<br>Инварианты класса должны остаться без изменений.
<br>Подкласс не должен изменять значения приватных полей базового класса.
<br>При наследовании очень важно следить за нарушением этих требований, чтобы не сломать работу существующего кода.<br>Пример неудачной иерархии классов документов: метод сохранения в подклассе ReadOnlyDocuments выбрасывает исключение, что вынуждает клиентский код проверять тип документа при сохранении всех документов. Это нарушает принцип открытости/закрытости. Проблема может быть решена перепроектированием иерархии классов: базовый класс сможет только открывать документы, а подкласс WritableDocument расширит поведение родителя, позволив сохранять документ.<br><img alt="Погружение в ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ by Alexander Shvets-240509-16.png" src="lib/media/погружение-в-паттерны-проектирования-by-alexander-shvets-240509-16.png"><br>ДО: подкласс «обнуляет» работу базового метода.<br>
<img alt="Погружение в ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ by Alexander Shvets-240509-17.png" src="lib/media/погружение-в-паттерны-проектирования-by-alexander-shvets-240509-17.png"><br>ПОСЛЕ: подкласс расширяет базовый класс новым поведением.<br><br>Принцип разделения интерфейса<br>Important
Клиенты не должны зависеть от методов, которые они не используют.  
<br>Чтобы не перегружать классы избыточным поведением, следует создавать узкие интерфейсы. Принцип разделения интерфейсов говорит о том, что необходимо разбивать слишком широкие интерфейсы на более маленькие и специфические, чтобы клиенты маленьких интерфейсов знали только о методах, которые им необходимы. Если меняется метод интерфейса, то не должны меняться клиенты, которые этот метод не используют.<br>Для класса доступен только один суперкласс, но количество интерфейсов, которые он может реализовать, не ограничено. Большинство объектно-ориентированных языков программирования позволяют классам реализовывать несколько интерфейсов, поэтому нет необходимости заталкивать в интерфейс больше поведений, чем он требует. Лучше присваивать классу несколько интерфейсов поменьше.<br>Например, если библиотека предназначена для работы с облачными провайдерами, то в первой версии она могла поддерживать только Amazon, имеющий полный набор облачных услуг. Но позже стало ясно, что получившийся интерфейс облачного провайдера слишком широк, так как есть другие провайдеры, реализующие только часть из всех возможных сервисов. Чтобы не плодить классы с пустой реализацией, раздутый интерфейс можно разбить на части. Классы, которые были способны реализовать все операции старого интерфейса, могут реализовать сразу несколько новых частичных интерфейсов.<br>
<img alt="Погружение в ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ by Alexander Shvets-240509-18.png" src="lib/media/погружение-в-паттерны-проектирования-by-alexander-shvets-240509-18.png"><br>ДО: не все клиенты могут реализовать операции интерфейса.<br>
<img alt="Погружение в ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ by Alexander Shvets-240509-19.png" src="lib/media/погружение-в-паттерны-проектирования-by-alexander-shvets-240509-19.png"><br>ПОСЛЕ: раздутый интерфейс разбит на части.<br><br>Принцип инверсии зависимостей<br>Important
Классы верхних уровней не должны зависеть от классов нижних уровней. Оба должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.  
<br>При проектировании программы можно выделить два уровня классов: классы низкого уровня реализуют базовые операции, а классы высокого уровня содержат бизнес-логику. Обычно проектирование начинается с классов низкого уровня, что может привести к зависимости классов бизнес-логики от примитивных низкоуровневых классов. Принцип инверсии зависимостей предлагает изменить направление проектирования, начав с описания интерфейсов низкоуровневых операций, нужных классу бизнес-логики. Таким образом, можно убрать зависимость класса бизнес-логики от конкретного низкоуровневого класса, заменив её «мягкой» зависимостью от интерфейса. Это также позволит расширять низкоуровневые классы и использовать их с классами бизнес-логики без изменения кода последних. Пример: высокоуровневый класс формирования бюджетных отчётов использует класс базы данных, но можно создать высокоуровневый интерфейс для загрузки/сохранения данных и привязать к нему класс отчётов, чтобы низкоуровневые классы реализовывали этот интерфейс.<br>
<img alt="Погружение в ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ by Alexander Shvets-240509-20.png" src="lib/media/погружение-в-паттерны-проектирования-by-alexander-shvets-240509-20.png"><br>ДО: высокоуровневый класс зависит от низкоуровневого.<br><img alt="Погружение в ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ by Alexander Shvets-240509-21.png" src="lib/media/погружение-в-паттерны-проектирования-by-alexander-shvets-240509-21.png"><br>ПОСЛЕ: низкоуровневые классы зависят от<br>
высокоуровневой абстракции.<br><br><br>Паттерн проектирования — это решение определённой проблемы при проектировании архитектуры программ. В отличие от готовых функций или библиотек, паттерн представляет собой не конкретный код, а общую концепцию решения проблемы, которую нужно будет ещё подстроить под нужды вашей программы.<br>Паттерны часто путают с алгоритмами, ведь оба понятия описывают типовые решения проблем. Но если алгоритм — это чёткий набор действий, то паттерн — это высокоуровневое описание решения, реализация которого может отличаться в двух разных программах.<br>Из чего состоит паттерн?<br>
<br>проблема, которую решает паттерн;
<br>мотивации к решению проблемы способом, который предлагает паттерн;
<br>структуры классов, составляющих решение;
<br>примера на одном из языков программирования;
<br>особенностей реализации в различных контекстах;
<br>связей с другими паттернами.
<br>Классификация паттернов:<br>
<br>Порождающие паттерны беспокоятся о гибком создании объектов без внесения в программу лишних зависимостей.
<br>Структурные паттерны показывают различные способы построения связей между объектами.
<br>Поведенческие паттерны заботятся об эффективной коммуникации между объектами.
<br>Паттерны не придумывают, а, скорее, «открывают». Это не какие-то супер-оригинальные решения, а наоборот, часто встречающиеся, типовые решения одной и той же проблемы. Концепцию паттернов впервые описал Кристофер Александр в книге "Язык шаблонов. Города. Здания. Строительство". Группа авторов - Эрих Гамма, Ричард Хелм, Ральф Джонсон и Джон Влиссидес - написали книгу "Design Patterns: Elements of Reusable Object-Oriented Software", в которую вошли 23 паттерна, решающие различные проблемы объектно-ориентированного дизайна. С тех пор были найдены десятки других объектных паттернов.<br><br><br>Вы можете работать успешно, не зная паттерны. Вы, возможно, уже использовали паттерны, не зная об их наличии. Однако осознанное использование инструментов является признаком профессионализма. Вы можете забить гвоздь молотком или дрелью, но профессионал знает, что главное в дрели - это не в этом.<br>Так зачем же знать паттерны?<br>
<br>Они предлагают проверенные решения, с помощью которых вы экономите время, используя готовые решения вместо повторного изобретения велосипеда. Некоторые решения могут быть открытием для вас.
<br>Они позволяют стандартизировать код, что позволяет сократить количество ошибок, используя типовые унифицированные решения, в которых все скрытые проблемы уже давно найдены.
<br>Они предлагают общий программистский словарь. Вы можете произносить название паттерна, вместо того, чтобы объяснять другим программистам, какой крутой дизайн вы придумали и какие классы для этого нужны.
<br><br>
<br><a data-href="ФАБРИЧНЫЙ МЕТОД (Factory Method)" href="04.-literature-notes/погружение-в-паттерны-проектирования-by-alexander-shvets/фабричный-метод-(factory-method).html" class="internal-link" target="_self" rel="noopener">ФАБРИЧНЫЙ МЕТОД (Factory Method)</a>
<br><a data-href="АБСТРАКТНАЯ ФАБРИКА (Abstract Factory)" href="04.-literature-notes/погружение-в-паттерны-проектирования-by-alexander-shvets/абстрактная-фабрика-(abstract-factory).html" class="internal-link" target="_self" rel="noopener">АБСТРАКТНАЯ ФАБРИКА (Abstract Factory)</a>
<br><a data-href="СТРОИТЕЛЬ (Builder)" href="04.-literature-notes/погружение-в-паттерны-проектирования-by-alexander-shvets/строитель-(builder).html" class="internal-link" target="_self" rel="noopener">СТРОИТЕЛЬ (Builder)</a>
<br><a data-href="ПРОТОТИП (Prototype)" href="04.-literature-notes/погружение-в-паттерны-проектирования-by-alexander-shvets/прототип-(prototype).html" class="internal-link" target="_self" rel="noopener">ПРОТОТИП (Prototype)</a>
<br><a data-href="ОДИНОЧКА" href="04.-literature-notes/погружение-в-паттерны-проектирования-by-alexander-shvets/одиночка.html" class="internal-link" target="_self" rel="noopener">ОДИНОЧКА</a>
<br><br>
<br><a data-href="АДАПТЕР (Wrapper, Обёртка, Adapter)" href="04.-literature-notes/погружение-в-паттерны-проектирования-by-alexander-shvets/адаптер-(wrapper,-обёртка,-adapter).html" class="internal-link" target="_self" rel="noopener">АДАПТЕР (Wrapper, Обёртка, Adapter)</a>
<br><a data-href="МОСТ (Bridge)" href="04.-literature-notes/погружение-в-паттерны-проектирования-by-alexander-shvets/мост-(bridge).html" class="internal-link" target="_self" rel="noopener">МОСТ (Bridge)</a>
<br><a data-href="КОМПОНОВЩИК (Composite)" href="04.-literature-notes/погружение-в-паттерны-проектирования-by-alexander-shvets/компоновщик-(composite).html" class="internal-link" target="_self" rel="noopener">КОМПОНОВЩИК (Composite)</a>
<br><a data-href="ДЕКОРАТОР (Decorator)" href="04.-literature-notes/погружение-в-паттерны-проектирования-by-alexander-shvets/декоратор-(decorator).html" class="internal-link" target="_self" rel="noopener">ДЕКОРАТОР (Decorator)</a>
<br><a data-href="ФАСАД (Facade)" href="04.-literature-notes/погружение-в-паттерны-проектирования-by-alexander-shvets/фасад-(facade).html" class="internal-link" target="_self" rel="noopener">ФАСАД (Facade)</a>
<br><a data-href="ЛЕГКОВЕС (Приспособленец, Кэш, Flyweight)" href="04.-literature-notes/погружение-в-паттерны-проектирования-by-alexander-shvets/легковес-(приспособленец,-кэш,-flyweight).html" class="internal-link" target="_self" rel="noopener">ЛЕГКОВЕС (Приспособленец, Кэш, Flyweight)</a>
<br><a data-href="ЗАМЕСТИТЕЛЬ (Proxy)" href="04.-literature-notes/погружение-в-паттерны-проектирования-by-alexander-shvets/заместитель-(proxy).html" class="internal-link" target="_self" rel="noopener">ЗАМЕСТИТЕЛЬ (Proxy)</a>
<br><br>
<br><a data-href="ЦЕПОЧКА ОБЯЗАННОСТЕЙ (CoR, Chain of Command, Chain of Responsibility)" href="04.-literature-notes/погружение-в-паттерны-проектирования-by-alexander-shvets/цепочка-обязанностей-(cor,-chain-of-command,-chain-of-responsibility).html" class="internal-link" target="_self" rel="noopener">ЦЕПОЧКА ОБЯЗАННОСТЕЙ (CoR, Chain of Command, Chain of Responsibility)</a>
<br><a data-href="КОМАНДА (Действие, Транзакция, Action, Command)" href="04.-literature-notes/погружение-в-паттерны-проектирования-by-alexander-shvets/команда-(действие,-транзакция,-action,-command).html" class="internal-link" target="_self" rel="noopener">КОМАНДА (Действие, Транзакция, Action, Command)</a>
<br><a data-href="ИТЕРАТОР (Iterator)" href="04.-literature-notes/погружение-в-паттерны-проектирования-by-alexander-shvets/итератор-(iterator).html" class="internal-link" target="_self" rel="noopener">ИТЕРАТОР (Iterator)</a>
<br><a data-href="ПОСРЕДНИК (Intermediary, Controller, Mediator)" href="04.-literature-notes/погружение-в-паттерны-проектирования-by-alexander-shvets/посредник-(intermediary,-controller,-mediator).html" class="internal-link" target="_self" rel="noopener">ПОСРЕДНИК (Intermediary, Controller, Mediator)</a>
<br><a data-href="СНИМОК (Хранитель, Memento)" href="04.-literature-notes/погружение-в-паттерны-проектирования-by-alexander-shvets/снимок-(хранитель,-memento).html" class="internal-link" target="_self" rel="noopener">СНИМОК (Хранитель, Memento)</a>
<br><a data-href="НАБЛЮДАТЕЛЬ (Издатель-Подписчик, Слушатель, Observer)" href="04.-literature-notes/погружение-в-паттерны-проектирования-by-alexander-shvets/наблюдатель-(издатель-подписчик,-слушатель,-observer).html" class="internal-link" target="_self" rel="noopener">НАБЛЮДАТЕЛЬ (Издатель-Подписчик, Слушатель, Observer)</a>
<br><a data-href="СОСТОЯНИЕ (State)" href="04.-literature-notes/погружение-в-паттерны-проектирования-by-alexander-shvets/состояние-(state).html" class="internal-link" target="_self" rel="noopener">СОСТОЯНИЕ (State)</a>
<br><a data-href="СТРАТЕГИЯ (Strategy)" href="04.-literature-notes/погружение-в-паттерны-проектирования-by-alexander-shvets/стратегия-(strategy).html" class="internal-link" target="_self" rel="noopener">СТРАТЕГИЯ (Strategy)</a>
<br><a data-href="ШАБЛОННЫЙ МЕТОД (Template Method)" href="04.-literature-notes/погружение-в-паттерны-проектирования-by-alexander-shvets/шаблонный-метод-(template-method).html" class="internal-link" target="_self" rel="noopener">ШАБЛОННЫЙ МЕТОД (Template Method)</a>
<br><a data-href="ПОСЕТИТЕЛЬ (Visitor)" href="04.-literature-notes/погружение-в-паттерны-проектирования-by-alexander-shvets/посетитель-(visitor).html" class="internal-link" target="_self" rel="noopener">ПОСЕТИТЕЛЬ (Visitor)</a>
]]></description><link>04.-literature-notes/погружение-в-паттерны-проектирования-by-alexander-shvets/погружение-в-паттерны-проектирования-by-alexander-shvets.html</link><guid isPermaLink="false">04. Literature Notes/Погружение в ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ by Alexander Shvets/Погружение в ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ by Alexander Shvets.md</guid><pubDate>Thu, 09 May 2024 11:47:41 GMT</pubDate><enclosure url="lib/media/погружение-в-паттерны-проектирования-by-alexander-shvets-240509-1.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/погружение-в-паттерны-проектирования-by-alexander-shvets-240509-1.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[ПОСЕТИТЕЛЬ (Visitor)]]></title><description><![CDATA[ 
 <br><br>Как выполнить операцию над всеми элементами сложной структуры объектов?<br><br>Паттерн Посетитель предлагает создать объект, который будет обходить структуру и выполнять нужную операцию для каждого элемента.<br><br>Представьте, что вы - гид в музее. Вы обходите все залы и рассказываете о каждой экспонате. Каждая экспоната - это элемент структуры, а ваша речь - это операция, выполняемая Посетителем.<br><br>
<br>Посетитель описывает интерфейс операции для каждого элемента структуры.
<br>Элементы реализуют метод accept(visitor), который переадресует вызов одному из методов интерфейса посетителя.
<br>Клиент создает объект посетителя и передает его в элементы, вызывая их метод accept(visitor).
<br><br>
<br>Когда нужно выполнить операцию над всеми элементами сложной структуры объектов.
<br>Когда объекты структуры имеют различные классы, но нужно применить одну и ту же операцию.
<br>Когда над объектами структуры надо выполнить несколько не связанных операций.
<br><br>
<br>Создайте интерфейс посетителя и объявите в нем методы "посещения" для каждого класса элемента.
<br>Опишите интерфейс элементов и реализуйте метод accept(visitor) во всех конкретных элементах.
<br>Создайте конкретные классы посетителей и реализуйте все методы интерфейса посетителя.
<br><br><br>
<br>Упрощает добавление операций, работающих со сложными структурами объектов.
<br>Объединяет родственные операции в одном классе.
<br><br>
<br>Паттерн не оправдан, если иерархия элементов часто меняется.
<br>Может привести к нарушению инкапсуляции элементов.
<br><br>
<br>Посетитель можно рассматривать как расширенный аналог Команды, который способен работать сразу с несколькими видами получателей.
<br>Посетитель можно использовать совместно с Итератором. Итератор будет отвечать за обход структуры данных, а Посетитель - за выполнение действий над каждым ее компонентом.
<br><br><br>// Паттерн Посетитель
//
// Назначение: Позволяет создавать новые операции, не меняя классы объектов, над
// которыми эти операции могут выполняться.

using System;
using System.Collections.Generic;

namespace RefactoringGuru.DesignPatterns.Visitor.Conceptual
{
    // Интерфейс Компонента объявляет метод accept, который в качестве аргумента
    // может получать любой объект, реализующий интерфейс посетителя.
    public interface IComponent
    {
        void Accept(IVisitor visitor);
    }

    // Каждый Конкретный Компонент должен реализовать метод Accept таким
    // образом, чтобы он вызывал метод посетителя, соответствующий классу
    // компонента.
    public class ConcreteComponentA : IComponent
    {
        // Обратите внимание, мы вызываем VisitConcreteComponentA, что
        // соответствует названию текущего класса. Таким образом мы позволяем
        // посетителю узнать, с каким классом компонента он работает.
        public void Accept(IVisitor visitor)
        {
            visitor.VisitConcreteComponentA(this);
        }

        // Конкретные Компоненты могут иметь особые методы, не объявленные в их
        // базовом классе или интерфейсе. Посетитель всё же может использовать
        // эти методы, поскольку он знает о конкретном классе компонента.
        public string ExclusiveMethodOfConcreteComponentA()
        {
            return "A";
        }
    }

    public class ConcreteComponentB : IComponent
    {
        // То же самое здесь: VisitConcreteComponentB =&gt; ConcreteComponentB
        public void Accept(IVisitor visitor)
        {
            visitor.VisitConcreteComponentB(this);
        }

        public string SpecialMethodOfConcreteComponentB()
        {
            return "B";
        }
    }

    // Интерфейс Посетителя объявляет набор методов посещения, соответствующих
    // классам компонентов. Сигнатура метода посещения позволяет посетителю
    // определить конкретный класс компонента, с которым он имеет дело.
    public interface IVisitor
    {
        void VisitConcreteComponentA(ConcreteComponentA element);

        void VisitConcreteComponentB(ConcreteComponentB element);
    }

    // Конкретные Посетители реализуют несколько версий одного и того же
    // алгоритма, которые могут работать со всеми классами конкретных
    // компонентов.
    //
    // Максимальную выгоду от паттерна Посетитель вы почувствуете, используя его
    // со сложной структурой объектов, такой как дерево Компоновщика. В этом
    // случае было бы полезно хранить некоторое промежуточное состояние
    // алгоритма при выполнении методов посетителя над различными объектами
    // структуры.
    class ConcreteVisitor1 : IVisitor
    {
        public void VisitConcreteComponentA(ConcreteComponentA element)
        {
            Console.WriteLine(element.ExclusiveMethodOfConcreteComponentA() + " + ConcreteVisitor1");
        }

        public void VisitConcreteComponentB(ConcreteComponentB element)
        {
            Console.WriteLine(element.SpecialMethodOfConcreteComponentB() + " + ConcreteVisitor1");
        }
    }

    class ConcreteVisitor2 : IVisitor
    {
        public void VisitConcreteComponentA(ConcreteComponentA element)
        {
            Console.WriteLine(element.ExclusiveMethodOfConcreteComponentA() + " + ConcreteVisitor2");
        }

        public void VisitConcreteComponentB(ConcreteComponentB element)
        {
            Console.WriteLine(element.SpecialMethodOfConcreteComponentB() + " + ConcreteVisitor2");
        }
    }

    public class Client
    {
        // Клиентский код может выполнять операции посетителя над любым набором
        // элементов, не выясняя их конкретных классов. Операция принятия
        // направляет вызов к соответствующей операции в объекте посетителя.
        public static void ClientCode(List&lt;IComponent&gt; components, IVisitor visitor)
        {
            foreach (var component in components)
            {
                component.Accept(visitor);
            }
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            List&lt;IComponent&gt; components = new List&lt;IComponent&gt;
            {
                new ConcreteComponentA(),
                new ConcreteComponentB()
            };

            Console.WriteLine("The client code works with all visitors via the base Visitor interface:");
            var visitor1 = new ConcreteVisitor1();
            Client.ClientCode(components,visitor1);

            Console.WriteLine();

            Console.WriteLine("It allows the same client code to work with different types of visitors:");
            var visitor2 = new ConcreteVisitor2();
            Client.ClientCode(components, visitor2);
        }
    }
}
Copy<br><br>The client code works with all visitors via the base Visitor interface:
A + ConcreteVisitor1
B + ConcreteVisitor1

It allows the same client code to work with different types of visitors:
A + ConcreteVisitor2
B + ConcreteVisitor2
Copy]]></description><link>04.-literature-notes/погружение-в-паттерны-проектирования-by-alexander-shvets/посетитель-(visitor).html</link><guid isPermaLink="false">04. Literature Notes/Погружение в ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ by Alexander Shvets/ПОСЕТИТЕЛЬ (Visitor).md</guid><pubDate>Wed, 08 May 2024 15:52:55 GMT</pubDate></item><item><title><![CDATA[ПОСРЕДНИК (Intermediary, Controller, Mediator)]]></title><description><![CDATA[ 
 <br><br>Компоненты в сложных системах могут сильно переплетаться друг с другом.<br><br>Создать посредника, который будет управлять общением между компонентами и убрать прямые связи между ними.<br><br>Менеджер команды - он централизует коммуникацию и управляет взаимодействием между членами команды.<br><br>Создаётся интерфейс посредника, который описывает методы взаимодействия с компонентами. Конкретный посредник реализует этот интерфейс и содержит ссылки на все компоненты.<br><br>Используется для устранения зависимостей между компонентами и упрощения их взаимодействия.<br><br>
<br>Найдите группу тесно переплетённых классов.
<br>Создайте общий интерфейс посредников и опишите в нём методы для взаимодействия с компонентами.
<br>Реализуйте этот интерфейс в классе конкретного посредника и поместите в него ссылки на все объекты компонентов.
<br>Измените код компонентов так, чтобы они вызывали метод оповещения посредника, вместо методов других компонентов.
<br><br>Устраняет зависимости между компонентами и упрощает их взаимодействие. Централизует управление в одном месте. Может сильно раздуться.<br><br>
<br>Цепочка обязанностей, Команда, Посредник и Наблюдатель показывают различные способы работы отправителей запросов с их получателями.
<br>Посредник и Фасад похожи тем, что пытаются организовать работу множества существующих классов.
<br>Разница между Посредником и Наблюдателем не всегда очевидна, но Посредник имеет и другие реализации, когда отдельные компоненты жёстко привязаны к объекту посредника.
<br><br><br>// Паттерн Посредник
//
// Назначение: Позволяет уменьшить связанность множества классов между собой,
// благодаря перемещению этих связей в один класс-посредник.

using System;

namespace RefactoringGuru.DesignPatterns.Mediator.Conceptual
{
    // Интерфейс Посредника предоставляет метод, используемый компонентами для
    // уведомления посредника о различных событиях. Посредник может реагировать
    // на эти события  и передавать исполнение другим компонентам.
    public interface IMediator
    {
        void Notify(object sender, string ev);
    }

    // Конкретные Посредники реализуют совместное поведение, координируя
    // отдельные компоненты.
    class ConcreteMediator : IMediator
    {
        private Component1 _component1;

        private Component2 _component2;

        public ConcreteMediator(Component1 component1, Component2 component2)
        {
            this._component1 = component1;
            this._component1.SetMediator(this);
            this._component2 = component2;
            this._component2.SetMediator(this);
        } 

        public void Notify(object sender, string ev)
        {
            if (ev == "A")
            {
                Console.WriteLine("Mediator reacts on A and triggers folowing operations:");
                this._component2.DoC();
            }
            if (ev == "D")
            {
                Console.WriteLine("Mediator reacts on D and triggers following operations:");
                this._component1.DoB();
                this._component2.DoC();
            }
        }
    }

    // Базовый Компонент обеспечивает базовую функциональность хранения
    // экземпляра посредника внутри объектов компонентов.
    class BaseComponent
    {
        protected IMediator _mediator;

        public BaseComponent(IMediator mediator = null)
        {
            this._mediator = mediator;
        }

        public void SetMediator(IMediator mediator)
        {
            this._mediator = mediator;
        }
    }

    // Конкретные Компоненты реализуют различную функциональность. Они не
    // зависят от других компонентов. Они также не зависят от каких-либо
    // конкретных классов посредников.
    class Component1 : BaseComponent
    {
        public void DoA()
        {
            Console.WriteLine("Component 1 does A.");

            this._mediator.Notify(this, "A");
        }

        public void DoB()
        {
            Console.WriteLine("Component 1 does B.");

            this._mediator.Notify(this, "B");
        }
    }

    class Component2 : BaseComponent
    {
        public void DoC()
        {
            Console.WriteLine("Component 2 does C.");

            this._mediator.Notify(this, "C");
        }

        public void DoD()
        {
            Console.WriteLine("Component 2 does D.");

            this._mediator.Notify(this, "D");
        }
    }
    
    class Program
    {
        static void Main(string[] args)
        {
            // Клиентский код.
            Component1 component1 = new Component1();
            Component2 component2 = new Component2();
            new ConcreteMediator(component1, component2);

            Console.WriteLine("Client triggers operation A.");
            component1.DoA();

            Console.WriteLine();

            Console.WriteLine("Client triggers operation D.");
            component2.DoD();
        }
    }
}
Copy]]></description><link>04.-literature-notes/погружение-в-паттерны-проектирования-by-alexander-shvets/посредник-(intermediary,-controller,-mediator).html</link><guid isPermaLink="false">04. Literature Notes/Погружение в ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ by Alexander Shvets/ПОСРЕДНИК (Intermediary, Controller, Mediator).md</guid><pubDate>Wed, 08 May 2024 15:50:41 GMT</pubDate></item><item><title><![CDATA[ПРИНЦИПЫ ПРОЕКТИРОВАНИЯ (Design Principles)]]></title><description><![CDATA[ 
 <br><br>Прежде чем перейти к изучению паттернов, давайте поговорим о самом процессе проектирования и о том, к чему надо стремиться, а также о том, чего надо избегать.<br>Использование старых наработок в новых проектах помогает снизить стоимость и время разработки. Однако, не всегда можно приспособить код к новым условиям. Паттерны проектирования помогают повысить гибкость архитектуры и упростить дальнейшее повторное использование кода.<br>Важно учитывать будущие изменения при проектировании архитектуры и написании кода, так как изменения неизбежны и могут прийти как извне, так и из-за улучшенного понимания проблемы в процессе её решения.<br><br><br>Что такое хороший дизайн? Как его оценивать и какие правила придерживаться при разработке? Как обеспечить гибкость, связанность, управляемость, стабильность и понятность кода?<br>Давайте рассмотрим универсальные принципы проектирования, которые помогут ответить на эти вопросы самостоятельно.<br><br>Изолируя изменчивые части программы в отдельных модулях, классах или методах, вы уменьшаете количество кода, который затронут последующие изменения. Также уменьшится стоимость разработки и увеличится ваше преимущество перед конкурентами.<br>Пример инкапсуляции на уровне метода<br>Перенесите логику вычисления налогов в собственный метод, скрыв детали от оригинального метода. Теперь изменения налогов будут изолированы в рамках одного метода. Если логика вычисления налогов станет ещё более сложной, вам будет легче извлечь этот метод в собственный класс.<br>method getOrderTotal(order) is
    total = 0
    foreach item in order.lineItems
        total += item.price * item.quantity
    if order.country == "US"
        total += total * 0.07 // US sales tax
    else if order.country == "EU"
        total += total * 0.20 // European VAT
    return total
Copy<br>method getOrderTotal(order) is
    total = 0
    foreach item in order.lineItems
        total += item.price * item.quantity
    total += total * getTaxAmount(order.country)
    return total

method getTaxAmount(country) is
    if (country == "US")
        return 0.07 // US sales tax
    else if (country == "EU")
        return 0.20 // European VAT
    else
        return 0
Copy<br>Пример инкапсуляции на уровне класса<br>Объекты заказов станут делегировать вычисление налогов отдельному объекту-калькулятору налогов.<br><br>Important
Программируйте на уровне интерфейса, а не на уровне реализации. Код должен зависеть от абстракций, а не конкретных классов.  
<br>Гибкость архитектуры проявляется в возможности её дальнейшего расширения без необходимости модификации существующего кода. Например, класс Кот, который может есть любую еду, более гибок, чем тот, который может есть только сардельки, но и первый может есть сардельки, поскольку они также являются едой.<br>Для наладки взаимодействия между объектами разных классов можно начать с простой зависимости одного класса от другого. Однако более гибкий способ:<br>
<br>Определите, какие методы одного объекта должен использовать другой объект.
<br>Опишите эти методы в отдельном интерфейсе.
<br>Сделайте так, чтобы зависимость класса следовала этому интерфейсу. Для этого нужно добавить интерфейс в описание класса.
<br>Теперь можно сделать второй класс зависимым от интерфейса, а не от конкретного класса.
<br>Этот подход не обеспечивает немедленной выгоды, но позволяет использовать альтернативные реализации классов без изменения использующего их кода.<br>Пример:<br>Представьте, что вы делаете симулятор софтверной компании. У вас есть различные классы работников, которые выполняют разную работу внутри компании. Вы можете свести методы работы всех классов к одному виду, выделив для всех общий интерфейс Employee. Теперь можно применять полиморфизм в классе компании, рассматривая всех работников через интерфейс.<br>Однако класс компании всё ещё жёстко привязан к конкретным классам работников. Метод получения сотрудников в базовом классе компании можно сделать абстрактным, чтобы каждый тип компаний мог иметь собственный набор сотрудников.<br>После этих изменений код класса компании станет независимым от конкретных классов, и новые виды работников и компаний можно будет добавлять без изменений в основной код базового класса компаний. Это пример одного из паттернов, Фабричного метода.<br><br>Наследование — простой и быстрый способ повторного использования кода между классами. Два класса с дублирующимся кодом можно объединить в один базовый класс и перенести в него общее поведение.<br>Но у наследования есть проблемы, которые становятся очевидными только тогда, когда программа уже обросла классами, и изменить ситуацию трудно. Вот некоторые из возможных проблем с наследованием:<br>
<br>Подкласс не может отказаться от интерфейса или реализации своего родителя, что приводит к реализации не нужных методов.
<br>Переопределяя методы родителя, необходимо не сломать базовое поведение суперкласса, ведь подкласс может быть использован в любом коде, работающим с суперклассом.
<br>Наследование нарушает инкапсуляцию суперкласса, так как подклассам доступны детали родителя. Суперклассы могут сами стать зависимыми от подклассов.
<br>Подклассы слишком тесно связаны с родительским классом. Любое изменение в родителе может сломать поведение в подклассах.
<br>Повторное использование кода через наследование может привести к разрастанию иерархии классов.
<br>У наследования есть альтернатива, называемая композиция. Композиция — более свободный вид композиции, когда два объекта являются равноправными, и ни один из них не управляет жизненным циклом другого.<br>Пример<br>
Предположим, вам нужно смоделировать модельный ряд автопроизводителя. У вас есть легковые автомобили и грузовики. Причём они бывают с электрическим двигателем и с двигателем на бензине. К тому же они отличаются режимами навигации: есть модели с ручным управлением и автопилотом.  <br><img alt="Погружение в ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ by Alexander Shvets-240509-10.png" src="lib/media/погружение-в-паттерны-проектирования-by-alexander-shvets-240509-10.png"><br>Наследование: развитие классов в нескольких плоскостях (тип груза × тип двигателя × тип навигации) приводит к комбинаторному взрыву.<br>Каждый параметр приводит к умножению количества классов. Кроме того, возникает проблема дублирования кода, так как подклассы не могут наследовать нескольких родителей одновременно.<br>Решить проблему можно с помощью композиции. Вместо того, чтобы объекты сами реализовывали то или иное поведение, они могут делегировать его другим объектам. Композиция позволяет заменить тип двигателя автомобиля прямо во время выполнения программы, подставив в объект транспорта другой объект двигателя.<br><img alt="Погружение в ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ by Alexander Shvets-240509-11.png" src="lib/media/погружение-в-паттерны-проектирования-by-alexander-shvets-240509-11.png"><br>КОМПОЗИЦИЯ: различные виды функциональности выделены в собственные иерархии классов.<br>Такая структура свойственна паттерну Стратегия.<br><br><br>Рассмотрим ещё 5 принципов проектирования, известных как SOLID. Эти принципы были изложены Робертом Мартином в книге Agile Software Development, Principles, Patterns, and Practices. Цель принципов - повысить гибкость архитектуры, уменьшить связанность между её компонентами и облегчить повторное использование кода. Соблюдение этих принципов усложняет код программы, поэтому помните о балансе и не воспринимайте всё изложенное как догму.<br><br>Принцип единственной ответственности<br>Important
У класса должен быть только один мотив дляизменения.  
<br>Каждый класс должен отвечать только за одну часть функциональности программы, полностью инкапсулированную в нём. Принцип единственной ответственности нужен для борьбы со сложностью. Когда в вашем приложении всего 200 строк, дизайн не нужен: достаточно аккуратно написать 5-7 методов. Проблемы возникают, когда система растёт и класс разрастается, перестаёт помещаться в голове, навигация затрудняется, на глаза попадаются ненужные детали, связанные с другим аспектом, в результате количество понятий начинает превышать мозговой стек, и вы начинаете терять контроль над кодом. Если класс делает слишком много вещей сразу, вам приходится изменять его каждый раз, когда одна из этих вещей изменяется. Хорошо иметь возможность сосредоточиться на сложных аспектах системы по отдельности. Пример: класс Employee имеет сразу несколько причин для изменения — управление данными сотрудника и форматирование отчёта для печати. Проблему можно решить, выделив операцию печати в отдельный класс.<br><img alt="Погружение в ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ by Alexander Shvets-240509-12.png" src="lib/media/погружение-в-паттерны-проектирования-by-alexander-shvets-240509-12.png"><br>ДО: класс сотрудника содержит разнородные поведения.<br><img alt="Погружение в ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ by Alexander Shvets-240509-13.png" src="lib/media/погружение-в-паттерны-проектирования-by-alexander-shvets-240509-13.png"><br>ПОСЛЕ: лишнее поведение переехало в собственный класс.<br><br>Принцип открытости/закрытости<br>Important
Расширяйте классы, но не изменяйте их первоначаль-ный код.  
<br>Классы должны быть открыты для расширения и закрыты для изменения. Это означает, что вы можете расширить набор операций или добавить новые поля, создав собственный подкласс, и не ломать существующий код при внесении изменений в программу.<br>Класс может быть открытым, если он доступен для расширения. Класс может быть закрытым (а лучше сказать, законченным), если он готов к использованию другими классами и интерфейс класса уже окончательно определен и не будет изменяться в будущем.<br>Если класс уже готов к использованию другими классами и включен в проект, не следует пытаться модифицировать его содержимое. Вместо этого вы можете создать подкласс и расширить базовое поведение, не изменяя код родительского класса напрямую.<br>Не следует следовать этому принципу буквально для каждого изменения. Если вам нужно исправить ошибку в исходном классе, просто сделайте это. Нет смысла решать проблему родителя в дочернем классе.<br>Пример: класс заказов имеет метод расчета стоимости доставки, при этом способы доставки "зашиты" непосредственно в метод. Проблему можно решить, применив паттерн Стратегия. Для этого нужно выделить способы доставки в собственные классы с общим интерфейсом. Теперь при добавлении нового способа доставки нужно будет реализовать новый класс интерфейса доставки, не трогая класс заказов. Бонус этого решения в том, что расчет времени и даты доставки также можно поместить в новые классы, следуя принципу единственной ответственности.<br><img alt="Погружение в ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ by Alexander Shvets-240509-14.png" src="lib/media/погружение-в-паттерны-проектирования-by-alexander-shvets-240509-14.png"><br>ДО: код класса заказа нужно будет изменять при добавлении нового способа доставки.<br><img alt="Погружение в ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ by Alexander Shvets-240509-15.png" src="lib/media/погружение-в-паттерны-проектирования-by-alexander-shvets-240509-15.png"><br>ПОСЛЕ: новые способы доставки можно добавить, не трогая класс заказов.<br><br>Принцип подстановки Лисков<br>Important
Подклассы должны дополнять, а не замещать поведение базового класса.  
<br>Стремитесь создавать подклассы так, чтобы их объекты можно было подставлять вместо объектов базового класса, не ломая при этом функциональности клиентского кода. Принцип подстановки — это ряд проверок, которые помогают предсказать, останется ли подкласс совместим с остальным кодом программы, который до этого успешно работал, используя объекты базового класса. Это особенно важно при разработке библиотек и фреймворков, когда ваши классы используются другими людьми, и вы не можете повлиять на чужой клиентский код, даже если бы хотели.<br>Кратко о требованиях к подклассам:<br>
<br>Типы параметров метода подкласса должны совпадать или быть более абстрактными, чем типы параметров базового метода.
<br>Тип возвращаемого значения метода подкласса должен совпадать или быть подтипом возвращаемого значения базового метода.
<br>Метод не должен выбрасывать исключения, которые не свойственны базовому методу.
<br>Метод не должен ужесточать предусловия.
<br>Метод не должен ослаблять пост-условия.
<br>Инварианты класса должны остаться без изменений.
<br>Подкласс не должен изменять значения приватных полей базового класса.
<br>При наследовании очень важно следить за нарушением этих требований, чтобы не сломать работу существующего кода.<br>Пример неудачной иерархии классов документов: метод сохранения в подклассе ReadOnlyDocuments выбрасывает исключение, что вынуждает клиентский код проверять тип документа при сохранении всех документов. Это нарушает принцип открытости/закрытости. Проблема может быть решена перепроектированием иерархии классов: базовый класс сможет только открывать документы, а подкласс WritableDocument расширит поведение родителя, позволив сохранять документ.<br><img alt="Погружение в ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ by Alexander Shvets-240509-16.png" src="lib/media/погружение-в-паттерны-проектирования-by-alexander-shvets-240509-16.png"><br>ДО: подкласс «обнуляет» работу базового метода.<br><img alt="Погружение в ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ by Alexander Shvets-240509-17.png" src="lib/media/погружение-в-паттерны-проектирования-by-alexander-shvets-240509-17.png"><br>ПОСЛЕ: подкласс расширяет базовый класс новым поведением.<br><br>Принцип разделения интерфейса<br>Important
Клиенты не должны зависеть от методов, которые они не используют.  
<br>Чтобы не перегружать классы избыточным поведением, следует создавать узкие интерфейсы. Принцип разделения интерфейсов говорит о том, что необходимо разбивать слишком широкие интерфейсы на более маленькие и специфические, чтобы клиенты маленьких интерфейсов знали только о методах, которые им необходимы. Если меняется метод интерфейса, то не должны меняться клиенты, которые этот метод не используют.<br>Для класса доступен только один суперкласс, но количество интерфейсов, которые он может реализовать, не ограничено. Большинство объектно-ориентированных языков программирования позволяют классам реализовывать несколько интерфейсов, поэтому нет необходимости заталкивать в интерфейс больше поведений, чем он требует. Лучше присваивать классу несколько интерфейсов поменьше.<br>Например, если библиотека предназначена для работы с облачными провайдерами, то в первой версии она могла поддерживать только Amazon, имеющий полный набор облачных услуг. Но позже стало ясно, что получившийся интерфейс облачного провайдера слишком широк, так как есть другие провайдеры, реализующие только часть из всех возможных сервисов. Чтобы не плодить классы с пустой реализацией, раздутый интерфейс можно разбить на части. Классы, которые были способны реализовать все операции старого интерфейса, могут реализовать сразу несколько новых частичных интерфейсов.<br><img alt="Погружение в ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ by Alexander Shvets-240509-18.png" src="lib/media/погружение-в-паттерны-проектирования-by-alexander-shvets-240509-18.png"><br>ДО: не все клиенты могут реализовать операции интерфейса.<br><img alt="Untitled 9 2.png" src="lib/media/untitled-9-2.png"><br>ПОСЛЕ: раздутый интерфейс разбит на части.<br><br>Принцип инверсии зависимостей<br>Important
Классы верхних уровней не должны зависеть от классов нижних уровней. Оба должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.  
<br>При проектировании программы можно выделить два уровня классов: классы низкого уровня реализуют базовые операции, а классы высокого уровня содержат бизнес-логику. Обычно проектирование начинается с классов низкого уровня, что может привести к зависимости классов бизнес-логики от примитивных низкоуровневых классов. Принцип инверсии зависимостей предлагает изменить направление проектирования, начав с описания интерфейсов низкоуровневых операций, нужных классу бизнес-логики. Таким образом, можно убрать зависимость класса бизнес-логики от конкретного низкоуровневого класса, заменив её «мягкой» зависимостью от интерфейса. Это также позволит расширять низкоуровневые классы и использовать их с классами бизнес-логики без изменения кода последних. Пример: высокоуровневый класс формирования бюджетных отчётов использует класс базы данных, но можно создать высокоуровневый интерфейс для загрузки/сохранения данных и привязать к нему класс отчётов, чтобы низкоуровневые классы реализовывали этот интерфейс.<br><img alt="Погружение в ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ by Alexander Shvets-240509-20.png" src="lib/media/погружение-в-паттерны-проектирования-by-alexander-shvets-240509-20.png"><br>ДО: высокоуровневый класс зависит от низкоуровневого.<br><img alt="Погружение в ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ by Alexander Shvets-240509-21.png" src="lib/media/погружение-в-паттерны-проектирования-by-alexander-shvets-240509-21.png"><br>ПОСЛЕ: низкоуровневые классы зависят от<br>
высокоуровневой абстракции.]]></description><link>04.-literature-notes/погружение-в-паттерны-проектирования-by-alexander-shvets/принципы-проектирования-(design-principles).html</link><guid isPermaLink="false">04. Literature Notes/Погружение в ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ by Alexander Shvets/ПРИНЦИПЫ ПРОЕКТИРОВАНИЯ (Design Principles).md</guid><pubDate>Thu, 09 May 2024 11:47:41 GMT</pubDate><enclosure url="lib/media/погружение-в-паттерны-проектирования-by-alexander-shvets-240509-10.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/погружение-в-паттерны-проектирования-by-alexander-shvets-240509-10.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[ПРОТОТИП (Prototype)]]></title><description><![CDATA[ 
 <br><br>Когда у вас есть множество подклассов, отличающихся начальными значениями полей, может быть создано множество классов, чтобы иметь возможность легко порождать объекты с определенной конфигурацией. Это приводит к взрывному росту количества классов в программе и увеличению её сложности.<br><br>Паттерн прототип предлагает использовать набор прототипов, вместо создания подклассов для описания популярных конфигураций объектов. Вместо порождения объектов из подклассов, вы будете копировать существующие объекты-прототипы, в которых уже настроено внутреннее состояние.<br><br>В промышленном производстве прототипы создаются для испытаний перед основной партией продуктов. Прототип не участвует в производстве, отыгрывая пассивную роль. Пример паттерна — деление клеток. После митозного деления образуются две совершенно идентичные клетки. Оригинальная клетка отыгрывает роль прототипа, создавая новый объект.<br><br>Классы-прототипы предоставляют метод клонирования, который копирует объекты. Клиентский код получает объекты-прототипы и запрашивает у них копии, когда ему нужны новые объекты.<br><br>
<br>Когда у вас есть множество подклассов, отличающихся начальными значениями полей, и вы хотите уменьшить их количество.
<br>Когда вы не хотите зависеть от конкретных классов, которые нужно клонировать.
<br>Когда вы хотите уменьшить количество повторяющегося кода инициализации объектов.
<br>Когда вы хотите создавать объекты, независимые от их конкретных классов.
<br><br>
<br>Создайте интерфейс прототипов с единственным методом clone.
<br>Добавьте в классы-прототипы альтернативный конструктор, принимающий в качестве аргумента объект текущего класса. Этот конструктор должен скопировать из поданного объекта значения всех полей, объявленных в рамках текущего класса, а затем передать выполнение родительскому конструктору, чтобы тот позаботился о полях, объявленных в суперклассе.
<br>Метод клонирования обычно состоит всего из одной строки: вызова оператора new с конструктором прототипа.
<br>Опционально, создайте центральное хранилище прототипов.
<br><br><br>
<br>Позволяет клонировать объекты, не привязываясь к их конкретным классам.
<br>Меньше повторяющегося кода инициализации объектов.
<br>Ускоряет создание объектов.
<br>Альтернатива созданию подклассов для конструирования сложных объектов.
<br><br>
<br>Сложно клонировать составные объекты, имеющие ссылки на другие объекты
<br><br>
<br>Паттерн прототип может работать совместно с паттерном фабрика абстрактной или фабричным методом, чтобы создать объекты-прототипы в централизованном месте.
<br>Прототипы могут использоваться вместе с паттерном команда для поддержки отмены и повтора операций.
<br>Прототипы могут использоваться вместе с паттерном строитель, чтобы создавать сложные объекты из простых компонентов-прототипов.
<br><br><br>// Паттерн Прототип
//
// Назначение: Позволяет копировать объекты, не вдаваясь в подробности их
// реализации.

using System;

namespace RefactoringGuru.DesignPatterns.Prototype.Conceptual
{
    public class Person
    {
        public int Age;
        public DateTime BirthDate;
        public string Name;
        public IdInfo IdInfo;

        public Person ShallowCopy()
        {
            return (Person) this.MemberwiseClone();
        }

        public Person DeepCopy()
        {
            Person clone = (Person) this.MemberwiseClone();
            clone.IdInfo = new IdInfo(IdInfo.IdNumber);
            clone.Name = String.Copy(Name);
            return clone;
        }
    }

    public class IdInfo
    {
        public int IdNumber;

        public IdInfo(int idNumber)
        {
            this.IdNumber = idNumber;
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            Person p1 = new Person();
            p1.Age = 42;
            p1.BirthDate = Convert.ToDateTime("1977-01-01");
            p1.Name = "Jack Daniels";
            p1.IdInfo = new IdInfo(666);

            // Выполнить поверхностное копирование p1 и присвоить её p2.
            Person p2 = p1.ShallowCopy();
            // Сделать глубокую копию p1 и присвоить её p3.
            Person p3 = p1.DeepCopy();

            // Вывести значения p1, p2 и p3.
            Console.WriteLine("Original values of p1, p2, p3:");
            Console.WriteLine("   p1 instance values: ");
            DisplayValues(p1);
            Console.WriteLine("   p2 instance values:");
            DisplayValues(p2);
            Console.WriteLine("   p3 instance values:");
            DisplayValues(p3);

            // Изменить значение свойств p1 и отобразить значения p1, p2 и p3.
            p1.Age = 32;
            p1.BirthDate = Convert.ToDateTime("1900-01-01");
            p1.Name = "Frank";
            p1.IdInfo.IdNumber = 7878;
            Console.WriteLine("\nValues of p1, p2 and p3 after changes to p1:");
            Console.WriteLine("   p1 instance values: ");
            DisplayValues(p1);
            Console.WriteLine("   p2 instance values (reference values have changed):");
            DisplayValues(p2);
            Console.WriteLine("   p3 instance values (everything was kept the same):");
            DisplayValues(p3);
        }

        public static void DisplayValues(Person p)
        {
            Console.WriteLine("      Name: {0:s}, Age: {1:d}, BirthDate: {2:MM/dd/yy}",
                p.Name, p.Age, p.BirthDate);
            Console.WriteLine("      ID#: {0:d}", p.IdInfo.IdNumber);
        }
    }
}
Copy]]></description><link>04.-literature-notes/погружение-в-паттерны-проектирования-by-alexander-shvets/прототип-(prototype).html</link><guid isPermaLink="false">04. Literature Notes/Погружение в ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ by Alexander Shvets/ПРОТОТИП (Prototype).md</guid><pubDate>Wed, 08 May 2024 15:53:14 GMT</pubDate></item><item><title><![CDATA[СНИМОК (Хранитель, Memento)]]></title><description><![CDATA[ 
 <br><br>Как сохранить состояние объекта и восстановить его в будущем?<br><br>Шаблон Memento позволяет сохранять мгновенные снимки состояния объекта, чтобы впоследствии его можно было восстановить в том же состоянии.<br><br>Представьте, что вы делаете резервную копию своих фотографий на жесткий диск. Вы можете сохранять любое количество снимков и хранить их независимо от вашей фотокамеры.<br><br>Шаблон состоит из трех основных компонентов: Создатель, Опекун и Снимок. Создатель создает снимки состояния объекта, Опекун заботится о хранении и восстановлении снимков, а Снимок содержит копию состояния объекта.<br><br>Используйте шаблон Memento, когда вам нужно сохранять мгновенные снимки состояния объекта (или его части), чтобы впоследствии объект можно было восстановить в том же состоянии.<br><br>
<br>Определите класс создателя, объекты которого должны создавать снимки своего состояния.
<br>Создайте класс снимка и опишите в нём все те же поля, которые имеются в оригинальном классе-создателе.
<br>Сделайте объекты снимков неизменяемыми. Они должны получать начальные значения только один раз, через свой конструктор.
<br>Добавьте в класс создателя метод получения снимков и метод восстановления из снимка.
<br>Опекуны должны знать о том, когда запрашивать снимки у создателя, где их хранить и когда восстанавливать.
<br><br><br>
<br>Не нарушает инкапсуляции исходного объекта.
<br>Упрощает структуру исходного объекта. Ему не нужно хранить историю версий своего состояния.
<br><br>
<br>Требует много памяти, если клиенты слишком часто создают снимки.
<br>Может повлечь дополнительные издержки памяти, если объекты, хранящие историю, не освобождают ресурсы, занятые устаревшими снимками.
<br><br>
<br>Команда и Снимок можно использовать сообща для реализации отмены операций.
<br>Снимок можно использовать вместе с Итератором, чтобы сохранить текущее состояние обхода структуры данных и вернуться к нему в будущем
<br><br><br>// Паттерн Снимок
//
// Назначение: Позволяет делать снимки состояния объектов, не раскрывая
// подробностей их реализации. Затем снимки можно использовать, чтобы
// восстановить прошлое состояние объектов.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;

namespace RefactoringGuru.DesignPatterns.Memento.Conceptual
{
    // Создатель содержит некоторое важное состояние, которое может со временем
    // меняться. Он также объявляет метод сохранения состояния внутри снимка и
    // метод восстановления состояния из него.
    class Originator
    {
        // Для удобства состояние создателя хранится внутри одной переменной.
        private string _state;

        public Originator(string state)
        {
            this._state = state;
            Console.WriteLine("Originator: My initial state is: " + state);
        }

        // Бизнес-логика Создателя может повлиять на его внутреннее состояние.
        // Поэтому клиент должен выполнить резервное копирование состояния с
        // помощью метода save перед запуском методов бизнес-логики.
        public void DoSomething()
        {
            Console.WriteLine("Originator: I'm doing something important.");
            this._state = this.GenerateRandomString(30);
            Console.WriteLine($"Originator: and my state has changed to: {_state}");
        }

        private string GenerateRandomString(int length = 10)
        {
            string allowedSymbols = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
            string result = string.Empty;

            while (length &gt; 0)
            {
                result += allowedSymbols[new Random().Next(0, allowedSymbols.Length)];

                Thread.Sleep(12);

                length--;
            }

            return result;
        }

        // Сохраняет текущее состояние внутри снимка.
        public IMemento Save()
        {
            return new ConcreteMemento(this._state);
        }

        // Восстанавливает состояние Создателя из объекта снимка.
        public void Restore(IMemento memento)
        {
            if (!(memento is ConcreteMemento))
            {
                throw new Exception("Unknown memento class " + memento.ToString());
            }

            this._state = memento.GetState();
            Console.Write($"Originator: My state has changed to: {_state}");
        }
    }

    // Интерфейс Снимка предоставляет способ извлечения метаданных снимка, таких
    // как дата создания или название. Однако он не раскрывает состояние
    // Создателя.
    public interface IMemento
    {
        string GetName();

        string GetState();

        DateTime GetDate();
    }

    // Конкретный снимок содержит инфраструктуру для хранения состояния
    // Создателя.
    class ConcreteMemento : IMemento
    {
        private string _state;

        private DateTime _date;

        public ConcreteMemento(string state)
        {
            this._state = state;
            this._date = DateTime.Now;
        }

        // Создатель использует этот метод, когда восстанавливает своё
        // состояние.
        public string GetState()
        {
            return this._state;
        }
        
        // Остальные методы используются Опекуном для отображения метаданных.
        public string GetName()
        {
            return $"{this._date} / ({this._state.Substring(0, 9)})...";
        }

        public DateTime GetDate()
        {
            return this._date;
        }
    }

    // Опекун не зависит от класса Конкретного Снимка. Таким образом, он не
    // имеет доступа к состоянию создателя, хранящемуся внутри снимка. Он
    // работает со всеми снимками через базовый интерфейс Снимка.
    class Caretaker
    {
        private List&lt;IMemento&gt; _mementos = new List&lt;IMemento&gt;();

        private Originator _originator = null;

        public Caretaker(Originator originator)
        {
            this._originator = originator;
        }

        public void Backup()
        {
            Console.WriteLine("\nCaretaker: Saving Originator's state...");
            this._mementos.Add(this._originator.Save());
        }

        public void Undo()
        {
            if (this._mementos.Count == 0)
            {
                return;
            }

            var memento = this._mementos.Last();
            this._mementos.Remove(memento);

            Console.WriteLine("Caretaker: Restoring state to: " + memento.GetName());

            try
            {
                this._originator.Restore(memento);
            }
            catch (Exception)
            {
                this.Undo();
            }
        }

        public void ShowHistory()
        {
            Console.WriteLine("Caretaker: Here's the list of mementos:");

            foreach (var memento in this._mementos)
            {
                Console.WriteLine(memento.GetName());
            }
        }
    }
    
    class Program
    {
        static void Main(string[] args)
        {
            // Клиентский код.
            Originator originator = new Originator("Super-duper-super-puper-super.");
            Caretaker caretaker = new Caretaker(originator);

            caretaker.Backup();
            originator.DoSomething();

            caretaker.Backup();
            originator.DoSomething();

            caretaker.Backup();
            originator.DoSomething();

            Console.WriteLine();
            caretaker.ShowHistory();

            Console.WriteLine("\nClient: Now, let's rollback!\n");
            caretaker.Undo();

            Console.WriteLine("\n\nClient: Once more!\n");
            caretaker.Undo();

            Console.WriteLine();
        }
    }
}
Copy]]></description><link>04.-literature-notes/погружение-в-паттерны-проектирования-by-alexander-shvets/снимок-(хранитель,-memento).html</link><guid isPermaLink="false">04. Literature Notes/Погружение в ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ by Alexander Shvets/СНИМОК (Хранитель, Memento).md</guid><pubDate>Wed, 08 May 2024 15:51:06 GMT</pubDate></item><item><title><![CDATA[СОСТОЯНИЕ (State)]]></title><description><![CDATA[ 
 <br><br>Когда у объекта множество состояний и поведение объекта кардинально меняется в зависимости от состояния, требуется решение, которое позволит избавиться от большого количества условных операторов.<br><br>Паттерн Состояние позволяет выделить каждое состояние в собственный класс, где его методы и поля будут содержать поведение, свойственное данному состоянию. Объект, который имеет различные состояния, будет постоянно ссылаться на один из объектов-состояний, делегируя ему часть работы. Чтобы изменить состояние, нужно подать другой объект-состояние в контекст.<br><br>Работа в банке: когда клиент приходит в банк, его запросы обрабатываются в зависимости от текущего состояния банковского счёта клиента. Если на счету недостаточно средств, клиент не может снять деньги.<br><br>
<br>Контекст определяет интерфейс, предназначенный для клиентов и хранит ссылку на экземпляр состояния, которое оно может менять во время выполнения.
<br>Состояние определяет интерфейс для классов, представляющих состояния, и реализует поведение, связанное с состоянием.
<br><br>
<br>Когда у объекта множество состояний и поведение объекта кардинально меняется в зависимости от состояния, причём типов состояний много, и их код часто меняется.
<br>Когда код класса содержит множество больших, похожих друг на друга, условных операторов, которые выбирают поведения в зависимости от текущих значений полей класса.
<br>Когда вы используете табличную машину состояний, построенную на условных операторах, но вынуждены мириться с дублированием кода для похожих состояний и переходов.
<br><br>
<br>Определиться с классом, который будет играть роль контекста.
<br>Создать общий интерфейс для состояний.
<br>Для каждого состояния создать класс, реализующий интерфейс состояния.
<br><br><br>
<br>Избавляет от множества больших условных операторов машины состояний.
<br>Концентрирует в одном месте код, связанный с определённым состоянием.
<br>Упрощает код контекста.
<br><br>
<br>Может неоправданно усложнить код, если состояний мало и<br>
они редко меняются.<br>

<br><br>
<br>Паттерны Мост, Стратегия и Состояние (а также слегка Адаптер) имеют схожие структуры классов, так как все они построены на принципе "композиции", то есть делегирования работы другим объектам. Тем не менее, они отличаются тем, что решают разные проблемы. Помните, что паттерны - это не только рецепт построения кода определенным образом, но и описание проблем, которые привели к данному решению.
<br>Состояние можно рассматривать как надстройку над Стратегией. Оба паттерна используют композицию для изменения поведения основного объекта, делегируя работу вложенным объектам-помощникам. Однако в Стратегии эти объекты не знают друг о друге и никак не связаны. В Состоянии сами конкретные состояния могут переключать контекст.
<br><br><br>// Паттерн Состояние
//
// Назначение: Позволяет объектам менять поведение в зависимости от своего
// состояния. Извне создаётся впечатление, что изменился класс объекта.

using System;

namespace RefactoringGuru.DesignPatterns.State.Conceptual
{
    // Контекст определяет интерфейс, представляющий интерес для клиентов. Он
    // также хранит ссылку на экземпляр подкласса Состояния, который отображает
    // текущее состояние Контекста.
    class Context
    {
        // Ссылка на текущее состояние Контекста.
        private State _state = null;

        public Context(State state)
        {
            this.TransitionTo(state);
        }

        // Контекст позволяет изменять объект Состояния во время выполнения.
        public void TransitionTo(State state)
        {
            Console.WriteLine($"Context: Transition to {state.GetType().Name}.");
            this._state = state;
            this._state.SetContext(this);
        }

        // Контекст делегирует часть своего поведения текущему объекту
        // Состояния.
        public void Request1()
        {
            this._state.Handle1();
        }

        public void Request2()
        {
            this._state.Handle2();
        }
    }
    
    // Базовый класс Состояния объявляет методы, которые должны реализовать все
    // Конкретные Состояния, а также предоставляет обратную ссылку на объект
    // Контекст, связанный с Состоянием. Эта обратная ссылка может
    // использоваться Состояниями для передачи Контекста другому Состоянию.
    abstract class State
    {
        protected Context _context;

        public void SetContext(Context context)
        {
            this._context = context;
        }

        public abstract void Handle1();

        public abstract void Handle2();
    }

    // Конкретные Состояния реализуют различные модели поведения, связанные с
    // состоянием Контекста.
    class ConcreteStateA : State
    {
        public override void Handle1()
        {
            Console.WriteLine("ConcreteStateA handles request1.");
            Console.WriteLine("ConcreteStateA wants to change the state of the context.");
            this._context.TransitionTo(new ConcreteStateB());
        }

        public override void Handle2()
        {
            Console.WriteLine("ConcreteStateA handles request2.");
        }
    }

    class ConcreteStateB : State
    {
        public override void Handle1()
        {
            Console.Write("ConcreteStateB handles request1.");
        }

        public override void Handle2()
        {
            Console.WriteLine("ConcreteStateB handles request2.");
            Console.WriteLine("ConcreteStateB wants to change the state of the context.");
            this._context.TransitionTo(new ConcreteStateA());
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            // Клиентский код.
            var context = new Context(new ConcreteStateA());
            context.Request1();
            context.Request2();
        }
    }
}
Copy<br><br>Context: Transition to ConcreteStateA.
ConcreteStateA handles request1.
ConcreteStateA wants to change the state of the context.
Context: Transition to ConcreteStateB.
ConcreteStateB handles request2.
ConcreteStateB wants to change the state of the context.
Context: Transition to ConcreteStateA.
Copy]]></description><link>04.-literature-notes/погружение-в-паттерны-проектирования-by-alexander-shvets/состояние-(state).html</link><guid isPermaLink="false">04. Literature Notes/Погружение в ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ by Alexander Shvets/СОСТОЯНИЕ (State).md</guid><pubDate>Wed, 08 May 2024 15:51:59 GMT</pubDate></item><item><title><![CDATA[СТРАТЕГИЯ (Strategy)]]></title><description><![CDATA[ 
 <br><br>Нужно варьировать поведение объекта на лету.<br><br>Вынести различающееся поведение в отдельную иерархию классов-стратегий и делегировать работу объектам-помощникам.<br><br>Когда вы выбираете способ оплаты заказа в интернет-магазине, вы выбираете объект-стратегию, который изменит поведение объекта-корзины.<br><br>
<br>Интерфейс стратегий, описывающий алгоритм.
<br>Классы-стратегии, реализующие интерфейс.
<br>Класс контекста, который управляет выбором стратегии.
<br><br>
<br>Когда нужно использовать разные вариации какого-то алгоритма внутри одного объекта.
<br>Когда у вас есть множество похожих классов, отличающихся только некоторым поведением.
<br>Когда вы не хотите обнажать детали реализации алгоритмов для других классов.
<br>Когда различные вариации алгоритмов реализованы в виде развесистого условного оператора.
<br><br>
<br>Определите алгоритм, который подвержен изменениям.
<br>Создайте интерфейс стратегий, описывающий этот алгоритм.
<br>Создайте классы-стратегии, реализующие интерфейс.
<br>Создайте класс контекста, который управляет выбором стратегии.
<br>Клиенты контекста должны подавать соответствующий объект-стратегию.
<br><br><br>
<br>Горячая замена алгоритмов на лету.
<br>Изолирование кода и данных алгоритмов от других классов.
<br>Уход от наследования к делегированию.
<br>Реализация принципа открытости/закрытости.
<br><br>
<br>Усложнение программы за счет дополнительных классов.
<br>Клиент должен знать, в чем состоит разница между стратегиями, чтобы выбрать подходящую.
<br><br>
<br>Компоновщик, Декоратор и Стратегия решают похожие задачи, но используют разные подходы.
<br>Шаблонный метод использует наследование для расширения алгоритма, а Стратегия использует делегирование.
<br>Состояние можно рассматривать как надстройку над Стратегией.
<br><br><br>// Паттерн Стратегия
//
// Назначение: Определяет семейство схожих алгоритмов и помещает каждый из них в
// собственный класс, после чего алгоритмы можно взаимозаменять прямо во время
// исполнения программы.

using System;
using System.Collections.Generic;

namespace RefactoringGuru.DesignPatterns.Strategy.Conceptual
{
    // Контекст определяет интерфейс, представляющий интерес для клиентов.
    class Context
    {
        // Контекст хранит ссылку на один из объектов Стратегии. Контекст не
        // знает конкретного класса стратегии. Он должен работать со всеми
        // стратегиями через интерфейс Стратегии.
        private IStrategy _strategy;

        public Context()
        { }

        // Обычно Контекст принимает стратегию через конструктор, а также
        // предоставляет сеттер для её изменения во время выполнения.
        public Context(IStrategy strategy)
        {
            this._strategy = strategy;
        }

        // Обычно Контекст позволяет заменить объект Стратегии во время
        // выполнения.
        public void SetStrategy(IStrategy strategy)
        {
            this._strategy = strategy;
        }

        // Вместо того, чтобы самостоятельно реализовывать множественные версии
        // алгоритма, Контекст делегирует некоторую работу объекту Стратегии.
        public void DoSomeBusinessLogic()
        {
            Console.WriteLine("Context: Sorting data using the strategy (not sure how it'll do it)");
            var result = this._strategy.DoAlgorithm(new List&lt;string&gt; { "a", "b", "c", "d", "e" });

            string resultStr = string.Empty;
            foreach (var element in result as List&lt;string&gt;)
            {
                resultStr += element + ",";
            }

            Console.WriteLine(resultStr);
        }
    }

    // Интерфейс Стратегии объявляет операции, общие для всех поддерживаемых
    // версий некоторого алгоритма.
    //
    // Контекст использует этот интерфейс для вызова алгоритма, определённого
    // Конкретными Стратегиями.
    public interface IStrategy
    {
        object DoAlgorithm(object data);
    }

    // Конкретные Стратегии реализуют алгоритм, следуя базовому интерфейсу
    // Стратегии. Этот интерфейс делает их взаимозаменяемыми в Контексте.
    class ConcreteStrategyA : IStrategy
    {
        public object DoAlgorithm(object data)
        {
            var list = data as List&lt;string&gt;;
            list.Sort();

            return list;
        }
    }

    class ConcreteStrategyB : IStrategy
    {
        public object DoAlgorithm(object data)
        {
            var list = data as List&lt;string&gt;;
            list.Sort();
            list.Reverse();

            return list;
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            // Клиентский код выбирает конкретную стратегию и передаёт её в
            // контекст. Клиент должен знать о различиях между стратегиями,
            // чтобы сделать правильный выбор.
            var context = new Context();

            Console.WriteLine("Client: Strategy is set to normal sorting.");
            context.SetStrategy(new ConcreteStrategyA());
            context.DoSomeBusinessLogic();
            
            Console.WriteLine();
            
            Console.WriteLine("Client: Strategy is set to reverse sorting.");
            context.SetStrategy(new ConcreteStrategyB());
            context.DoSomeBusinessLogic();
        }
    }
}
Copy<br><br>Client: Strategy is set to normal sorting.
Context: Sorting data using the strategy (not sure how it'll do it)
a,b,c,d,e

Client: Strategy is set to reverse sorting.
Context: Sorting data using the strategy (not sure how it'll do it)
e,d,c,b,a
Copy]]></description><link>04.-literature-notes/погружение-в-паттерны-проектирования-by-alexander-shvets/стратегия-(strategy).html</link><guid isPermaLink="false">04. Literature Notes/Погружение в ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ by Alexander Shvets/СТРАТЕГИЯ (Strategy).md</guid><pubDate>Wed, 08 May 2024 15:52:21 GMT</pubDate></item><item><title><![CDATA[СТРОИТЕЛЬ (Builder)]]></title><description><![CDATA[ 
 <br><br>Конструкторы классов становятся слишком сложными, когда нужно создавать объекты с большим количеством параметров и их комбинаций.<br><br>Использовать паттерн Строитель, который позволяет создавать объекты пошагово. Каждый шаг построения объекта выполняется отдельным классом-строителем. Кроме того, класс-директор определяет последовательность шагов.<br><br>Класс-продукт - объект, который создается. Класс-строитель - класс, который выполняет конкретный шаг построения продукта. Класс-директор - определяет последовательность шагов построения.<br><br>
<br>Когда нужно создавать объекты с большим количеством параметров и их комбинаций.
<br>Когда нужно создавать разные представления одного объекта.
<br>Когда нужно собирать сложные составные объекты.
<br><br>
<br>Убедиться в том, что создание разных представлений объекта можно свести к общим шагам.
<br>Определить общий интерфейс строителей для этих шагов.
<br>Создать по одному классу-строителю для каждого представления объекта-продукта и реализовать их методы строительства.
<br><br><br>
<br>Позволяет создавать продукты пошагово.
<br>Позволяет использовать один и тот же код для создания разных продуктов.
<br>Изолирует сложный код сборки продукта от его основной бизнес-логики.
<br><br>
<br>Усложняет код программы из-за введения дополнительных классов.
<br>Клиент будет привязан к конкретным классам строителей, так как в интерфейсе директора может не быть метода получения результата.
<br><br>
<br>Абстрактная фабрика, Прототип и Строитель могут быть реализованы при помощи Одиночки.
<br>Строитель позволяет пошагово сооружать дерево Компоновщика.
<br>Строитель и Абстрактная фабрика позволяют создавать сложные объекты, но Абстрактная фабрика возвращает продукты сразу же, а Строитель - только после выполнения всех шагов.
<br><br>// Паттерн Строитель
//
// Назначение: Позволяет создавать сложные объекты пошагово. Строитель даёт
// возможность использовать один и тот же код строительства для получения разных
// представлений объектов.

using System;
using System.Collections.Generic;

namespace RefactoringGuru.DesignPatterns.Builder.Conceptual
{
    // Интерфейс Строителя объявляет создающие методы для различных частей
    // объектов Продуктов.
    public interface IBuilder
    {
        void BuildPartA();
		
        void BuildPartB();
		
        void BuildPartC();
    }
    
    // Классы Конкретного Строителя следуют интерфейсу Строителя и предоставляют
    // конкретные реализации шагов построения. Ваша программа может иметь
    // несколько вариантов Строителей, реализованных по-разному.
    public class ConcreteBuilder : IBuilder
    {
        private Product _product = new Product();
        
        // Новый экземпляр строителя должен содержать пустой объект продукта,
        // который используется в дальнейшей сборке.
        public ConcreteBuilder()
        {
            this.Reset();
        }
        
        public void Reset()
        {
            this._product = new Product();
        }
		
        // Все этапы производства работают с одним и тем же экземпляром
        // продукта.
        public void BuildPartA()
        {
            this._product.Add("PartA1");
        }
		
        public void BuildPartB()
        {
            this._product.Add("PartB1");
        }
		
        public void BuildPartC()
        {
            this._product.Add("PartC1");
        }
		
        // Конкретные Строители должны предоставить свои собственные методы
        // получения результатов. Это связано с тем, что различные типы
        // строителей могут создавать совершенно разные продукты с разными
        // интерфейсами. Поэтому такие методы не могут быть объявлены в базовом
        // интерфейсе Строителя (по крайней мере, в статически типизированном
        // языке программирования).
        //
        // Как правило, после возвращения конечного результата клиенту,
        // экземпляр строителя должен быть готов к началу производства
        // следующего продукта. Поэтому обычной практикой является вызов метода
        // сброса в конце тела метода GetProduct. Однако такое поведение не
        // является обязательным, вы можете заставить своих строителей ждать
        // явного запроса на сброс из кода клиента, прежде чем избавиться от
        // предыдущего результата.
        public Product GetProduct()
        {
            Product result = this._product;

            this.Reset();

            return result;
        }
    }
    
    // Имеет смысл использовать паттерн Строитель только тогда, когда ваши
    // продукты достаточно сложны и требуют обширной конфигурации.
    //
    // В отличие от других порождающих паттернов, различные конкретные строители
    // могут производить несвязанные продукты. Другими словами, результаты
    // различных строителей  могут не всегда следовать одному и тому же
    // интерфейсу.
    public class Product
    {
        private List&lt;object&gt; _parts = new List&lt;object&gt;();
		
        public void Add(string part)
        {
            this._parts.Add(part);
        }
		
        public string ListParts()
        {
            string str = string.Empty;

            for (int i = 0; i &lt; this._parts.Count; i++)
            {
                str += this._parts[i] + ", ";
            }

            str = str.Remove(str.Length - 2); // removing last ",c"

            return "Product parts: " + str + "\n";
        }
    }
    
    // Директор отвечает только за выполнение шагов построения в определённой
    // последовательности. Это полезно при производстве продуктов в определённом
    // порядке или особой конфигурации. Строго говоря, класс Директор
    // необязателен, так как клиент может напрямую управлять строителями.
    public class Director
    {
        private IBuilder _builder;
        
        public IBuilder Builder
        {
            set { _builder = value; } 
        }
        
        // Директор может строить несколько вариаций продукта, используя
        // одинаковые шаги построения.
        public void BuildMinimalViableProduct()
        {
            this._builder.BuildPartA();
        }
		
        public void BuildFullFeaturedProduct()
        {
            this._builder.BuildPartA();
            this._builder.BuildPartB();
            this._builder.BuildPartC();
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            // Клиентский код создаёт объект-строитель, передаёт его директору,
            // а затем инициирует  процесс построения. Конечный результат
            // извлекается из объекта-строителя.
            var director = new Director();
            var builder = new ConcreteBuilder();
            director.Builder = builder;
            
            Console.WriteLine("Standard basic product:");
            director.BuildMinimalViableProduct();
            Console.WriteLine(builder.GetProduct().ListParts());

            Console.WriteLine("Standard full featured product:");
            director.BuildFullFeaturedProduct();
            Console.WriteLine(builder.GetProduct().ListParts());

            // Помните, что паттерн Строитель можно использовать без класса
            // Директор.
            Console.WriteLine("Custom product:");
            builder.BuildPartA();
            builder.BuildPartC();
            Console.Write(builder.GetProduct().ListParts());
        }
    }
}
Copy]]></description><link>04.-literature-notes/погружение-в-паттерны-проектирования-by-alexander-shvets/строитель-(builder).html</link><guid isPermaLink="false">04. Literature Notes/Погружение в ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ by Alexander Shvets/СТРОИТЕЛЬ (Builder).md</guid><pubDate>Wed, 08 May 2024 15:53:10 GMT</pubDate></item><item><title><![CDATA[ФАБРИЧНЫЙ МЕТОД (Factory Method)]]></title><description><![CDATA[ 
 <br><br>Как создавать объекты, не связывая код с конкретными классами продуктов и не указывая явно их конструкторы? <br><br>Создание объектов делегируется фабричному методу, который находится в интерфейсе Creator.<br><br>
<br>Creator - интерфейс для создания объектов
<br>ConcreteCreator - классы, реализующие интерфейс Creator
<br>Product - интерфейс создаваемых продуктов
<br>ConcreteProduct - классы, реализующие интерфейс Product
<br><br>Используйте фабричный метод, когда:<br>
<br>класс не может заранее знать, какие типы объектов ему нужно создавать
<br>класс способен делегировать создание объектов другому классу
<br>класс предоставляет пользователю интерфейс для создания объектов, но не хочет раскрывать детали реализации
<br><br>
<br>Создать интерфейс Product и реализующие его классы
<br>Создать интерфейс Creator и реализующие его классы
<br>В классе Creator создать абстрактный фабричный метод, который будет возвращать интерфейс Product
<br>Реализовать фабричный метод в классах ConcreteCreator, возвращая нужный объект ConcreteProduct
<br><br><br>
<br>избавляет класс от привязки к конкретным классам продуктов
<br>выделяет код производства продуктов в одно место, упрощая поддержку кода
<br>упрощает добавление новых продуктов в программу
<br>реализует принцип открытости/закрытости
<br><br>
<br>может привести к созданию больших параллельных иерархий классов, так как для каждого класса продукта надо создать свой подкласс создателя
<br><br>
<br>Многие архитектуры начинаются с применения Фабричного метода и эволюционируют в сторону Абстрактной фабрики, Прототипа или Строителя
<br>Классы Абстрактной фабрики чаще всего реализуются с помощью Фабричного метода, хотя они могут быть построены и на основе Прототипа.
<br><br><br>// Паттерн Фабричный Метод
//
// Назначение: Определяет общий интерфейс для создания объектов в суперклассе,
// позволяя подклассам изменять тип создаваемых объектов.

using System;

namespace RefactoringGuru.DesignPatterns.FactoryMethod.Conceptual
{
    // Класс Создатель объявляет фабричный метод, который должен возвращать
    // объект класса Продукт. Подклассы Создателя обычно предоставляют
    // реализацию этого метода.
    abstract class Creator
    {
        // Обратите внимание, что Создатель может также обеспечить реализацию
        // фабричного метода по умолчанию.
        public abstract IProduct FactoryMethod();

        // Также заметьте, что, несмотря на название, основная обязанность
        // Создателя не заключается в создании продуктов. Обычно он содержит
        // некоторую базовую бизнес-логику, которая основана  на объектах
        // Продуктов, возвращаемых фабричным методом.  Подклассы могут косвенно
        // изменять эту бизнес-логику, переопределяя фабричный метод и возвращая
        // из него другой тип продукта.
        public string SomeOperation()
        {
            // Вызываем фабричный метод, чтобы получить объект-продукт.
            var product = FactoryMethod();
            // Далее, работаем с этим продуктом.
            var result = "Creator: The same creator's code has just worked with "
                + product.Operation();

            return result;
        }
    }

    // Конкретные Создатели переопределяют фабричный метод для того, чтобы
    // изменить тип результирующего продукта.
    class ConcreteCreator1 : Creator
    {
        // Обратите внимание, что сигнатура метода по-прежнему использует тип
        // абстрактного продукта, хотя  фактически из метода возвращается
        // конкретный продукт. Таким образом, Создатель может оставаться
        // независимым от конкретных классов продуктов.
        public override IProduct FactoryMethod()
        {
            return new ConcreteProduct1();
        }
    }

    class ConcreteCreator2 : Creator
    {
        public override IProduct FactoryMethod()
        {
            return new ConcreteProduct2();
        }
    }

    // Интерфейс Продукта объявляет операции, которые должны выполнять все
    // конкретные продукты.
    public interface IProduct
    {
        string Operation();
    }

    // Конкретные Продукты предоставляют различные реализации интерфейса
    // Продукта.
    class ConcreteProduct1 : IProduct
    {
        public string Operation()
        {
            return "{Result of ConcreteProduct1}";
        }
    }

    class ConcreteProduct2 : IProduct
    {
        public string Operation()
        {
            return "{Result of ConcreteProduct2}";
        }
    }

    class Client
    {
        public void Main()
        {
            Console.WriteLine("App: Launched with the ConcreteCreator1.");
            ClientCode(new ConcreteCreator1());
            
            Console.WriteLine("");

            Console.WriteLine("App: Launched with the ConcreteCreator2.");
            ClientCode(new ConcreteCreator2());
        }

        // Клиентский код работает с экземпляром конкретного создателя, хотя и
        // через его базовый интерфейс. Пока клиент продолжает работать с
        // создателем через базовый интерфейс, вы можете передать ему любой
        // подкласс создателя.
        public void ClientCode(Creator creator)
        {
            // ...
            Console.WriteLine("Client: I'm not aware of the creator's class," +
                "but it still works.\n" + creator.SomeOperation());
            // ...
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            new Client().Main();
        }
    }
}
Copy]]></description><link>04.-literature-notes/погружение-в-паттерны-проектирования-by-alexander-shvets/фабричный-метод-(factory-method).html</link><guid isPermaLink="false">04. Literature Notes/Погружение в ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ by Alexander Shvets/ФАБРИЧНЫЙ МЕТОД (Factory Method).md</guid><pubDate>Wed, 08 May 2024 15:53:03 GMT</pubDate></item><item><title><![CDATA[ФАСАД (Facade)]]></title><description><![CDATA[ 
 <br><br>Программы могут содержать сложные подсистемы, которые усложняются по мере развития. Это делает их непригодными для повторного использования и усложняет их использование.<br><br>Введение фасада, который предоставляет урезанный интерфейс к сложной подсистеме. Фасад скрывает сложность и детали подсистемы, упрощая её использование.<br><br>Клиент, который заказывает еду в ресторане через официанта. Официант является фасадом, который скрывает сложность процесса приготовления еды, и предоставляет урезанный интерфейс к кухонному персоналу.<br><br>Фасад представляет собой класс, который оборачивает целую подсистему. Клиент работает только с фасадом, не зная о существовании подсистемы.<br><br>Фасад применяется, когда нужен урезанный интерфейс к сложной подсистеме, который избавит клиента от необходимости знать о подробностях подсистемы.<br><br>
<br>Создать класс фасада, реализующий урезанный интерфейс к подсистеме.
<br>Переадресовать вызовы клиента нужным объектам подсистемы.
<br>Инициализировать объекты подсистемы.
<br>Работать только с фасадом.
<br><br><br>
<br>Изолирует клиентов от компонентов сложной подсистемы.
<br><br>
<br>Фасад рискует стать божественным объектом, привязанным ко всем классам программы.
<br><br>
<br>Фасад задаёт новый интерфейс, тогда как Адаптер повторно использует старый.
<br>Посредник и Фасад похожи тем, что пытаются организовать работу множества существующих классов.
<br><br><br>// Паттерн Фасад
//
// Назначение: Предоставляет простой интерфейс к сложной системе классов,
// библиотеке или фреймворку.

using System;

namespace RefactoringGuru.DesignPatterns.Facade.Conceptual
{
    // Класс Фасада предоставляет простой интерфейс для сложной логики одной или
    // нескольких подсистем. Фасад делегирует запросы клиентов соответствующим
    // объектам внутри подсистемы. Фасад также отвечает за управление их
    // жизненным циклом. Все это защищает клиента от нежелательной сложности
    // подсистемы.
    public class Facade
    {
        protected Subsystem1 _subsystem1;
		
        protected Subsystem2 _subsystem2;

        public Facade(Subsystem1 subsystem1, Subsystem2 subsystem2)
        {
            this._subsystem1 = subsystem1;
            this._subsystem2 = subsystem2;
        }
		
        // Методы Фасада удобны для быстрого доступа к сложной функциональности
        // подсистем. Однако клиенты получают только часть возможностей
        // подсистемы.
        public string Operation()
        {
            string result = "Facade initializes subsystems:\n";
            result += this._subsystem1.operation1();
            result += this._subsystem2.operation1();
            result += "Facade orders subsystems to perform the action:\n";
            result += this._subsystem1.operationN();
            result += this._subsystem2.operationZ();
            return result;
        }
    }
    
    // Подсистема может принимать запросы либо от фасада, либо от клиента
    // напрямую. В любом случае, для Подсистемы Фасад – это еще один клиент, и
    // он не является частью Подсистемы.
    public class Subsystem1
    {
        public string operation1()
        {
            return "Subsystem1: Ready!\n";
        }

        public string operationN()
        {
            return "Subsystem1: Go!\n";
        }
    }
	
    // Некоторые фасады могут работать с разными подсистемами одновременно.
    public class Subsystem2
    {
        public string operation1()
        {
            return "Subsystem2: Get ready!\n";
        }

        public string operationZ()
        {
            return "Subsystem2: Fire!\n";
        }
    }


    class Client
    {
        // Клиентский код работает со сложными подсистемами через простой
        // интерфейс, предоставляемый Фасадом. Когда фасад управляет жизненным
        // циклом подсистемы, клиент может даже не знать о существовании
        // подсистемы. Такой подход позволяет держать сложность под контролем.
        public static void ClientCode(Facade facade)
        {
            Console.Write(facade.Operation());
        }
    }
    
    class Program
    {
        static void Main(string[] args)
        {
            // В клиентском коде могут быть уже созданы некоторые объекты
            // подсистемы. В этом случае может оказаться целесообразным
            // инициализировать Фасад с этими объектами вместо того, чтобы
            // позволить Фасаду создавать новые экземпляры.
            Subsystem1 subsystem1 = new Subsystem1();
            Subsystem2 subsystem2 = new Subsystem2();
            Facade facade = new Facade(subsystem1, subsystem2);
            Client.ClientCode(facade);
        }
    }
}
Copy<br><br>Facade initializes subsystems:
Subsystem1: Ready!
Subsystem2: Get ready!
Facade orders subsystems to perform the action:
Subsystem1: Go!
Subsystem2: Fire!
Copy]]></description><link>04.-literature-notes/погружение-в-паттерны-проектирования-by-alexander-shvets/фасад-(facade).html</link><guid isPermaLink="false">04. Literature Notes/Погружение в ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ by Alexander Shvets/ФАСАД (Facade).md</guid><pubDate>Wed, 08 May 2024 15:53:41 GMT</pubDate></item><item><title><![CDATA[ЦЕПОЧКА ОБЯЗАННОСТЕЙ (CoR, Chain of Command, Chain of Responsibility)]]></title><description><![CDATA[ 
 <br><br>Как обработать запрос в зависимости от его типа, не зная точно, какой из объектов цепочки должен его обработать?<br><br>Создать цепочку обработчиков, которые последовательно пытаются обработать запрос. Если обработчик не может обработать запрос, он передает его следующему обработчику в цепочке.<br><br>Допустим, у тебя в жилом комплексе есть администратор, охранник и соседи. Если у тебя возникнут проблемы (например, ты заблудился), ты сначала обратишься к администратору. Если он не сможет решить проблему, ты обратишься к охраннику. Если охранник тоже не сможет помочь, ты обратишься к соседям. И так далее.<br><br>
<br>Обработчик: интерфейс для обработки запросов и установки следующего обработчика в цепочке.
<br>Конкретные обработчики: классы, которые реализуют интерфейс обработчика и могут обработать запрос или передать его следующему обработчику в цепочке.
<br><br>
<br>Когда нужно обрабатывать запросы в зависимости от их типа и контекста.
<br>Когда нужно отправить запрос на обработку одному из нескольких объектов, не зная точно, какому именно.
<br><br>
<br>Создать абстрактный базовый класс для обработчиков и реализовать в нем метод получения следующего обработчика в цепочке.
<br>Создать конкретные классы обработчиков и реализовать в них методы обработки запросов.
<br>Установить начальное значение поля-ссылки на следующий объект цепочки через конструктор базового класса.
<br>Реализовать базовый метод обработки так, чтобы он перенаправлял запрос следующему объекту, проверив его наличие.
<br><br><br>
<br>Уменьшает зависимость между клиентом и обработчиками.
<br>Реализует принцип единственной обязанности.
<br>Реализует принцип открытости/закрытости.
<br><br>
<br>Запрос может остаться никем не обработанным.
<br><br>
<br>Структура Цепочки обязанностей похожа на структуру Декоратора, но обработчики могут прерывать цепочку обработки запросов.
<br>Цепочку обязанностей можно использовать вместе с Компоновщиком, передавая запрос от дочерних компон
<br><br><br>// Паттерн Цепочка обязанностей
//
// Назначение: Позволяет передавать запросы последовательно по цепочке
// обработчиков. Каждый последующий обработчик решает, может ли он обработать
// запрос сам и стоит ли передавать запрос дальше по цепи.

using System;
using System.Collections.Generic;

namespace RefactoringGuru.DesignPatterns.ChainOfResponsibility.Conceptual
{
    // Интерфейс Обработчика объявляет метод построения цепочки обработчиков. Он
    // также объявляет метод для выполнения запроса.
    public interface IHandler
    {
        IHandler SetNext(IHandler handler);
		
        object Handle(object request);
    }

    // Поведение цепочки по умолчанию может быть реализовано внутри базового
    // класса обработчика.
    abstract class AbstractHandler : IHandler
    {
        private IHandler _nextHandler;

        public IHandler SetNext(IHandler handler)
        {
            this._nextHandler = handler;
            
            // Возврат обработчика отсюда позволит связать обработчики простым
            // способом, вот так:
            // monkey.SetNext(squirrel).SetNext(dog);
            return handler;
        }
		
        public virtual object Handle(object request)
        {
            if (this._nextHandler != null)
            {
                return this._nextHandler.Handle(request);
            }
            else
            {
                return null;
            }
        }
    }

    class MonkeyHandler : AbstractHandler
    {
        public override object Handle(object request)
        {
            if ((request as string) == "Banana")
            {
                return $"Monkey: I'll eat the {request.ToString()}.\n";
            }
            else
            {
                return base.Handle(request);
            }
        }
    }

    class SquirrelHandler : AbstractHandler
    {
        public override object Handle(object request)
        {
            if (request.ToString() == "Nut")
            {
                return $"Squirrel: I'll eat the {request.ToString()}.\n";
            }
            else
            {
                return base.Handle(request);
            }
        }
    }

    class DogHandler : AbstractHandler
    {
        public override object Handle(object request)
        {
            if (request.ToString() == "MeatBall")
            {
                return $"Dog: I'll eat the {request.ToString()}.\n";
            }
            else
            {
                return base.Handle(request);
            }
        }
    }

    class Client
    {
        // Обычно клиентский код приспособлен для работы с единственным
        // обработчиком. В большинстве случаев клиенту даже неизвестно, что этот
        // обработчик является частью цепочки.
        public static void ClientCode(AbstractHandler handler)
        {
            foreach (var food in new List&lt;string&gt; { "Nut", "Banana", "Cup of coffee" })
            {
                Console.WriteLine($"Client: Who wants a {food}?");

                var result = handler.Handle(food);

                if (result != null)
                {
                    Console.Write($"   {result}");
                }
                else
                {
                    Console.WriteLine($"   {food} was left untouched.");
                }
            }
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            // Другая часть клиентского кода создает саму цепочку.
            var monkey = new MonkeyHandler();
            var squirrel = new SquirrelHandler();
            var dog = new DogHandler();

            monkey.SetNext(squirrel).SetNext(dog);

            // Клиент должен иметь возможность отправлять запрос любому
            // обработчику, а не только первому в цепочке.
            Console.WriteLine("Chain: Monkey &gt; Squirrel &gt; Dog\n");
            Client.ClientCode(monkey);
            Console.WriteLine();

            Console.WriteLine("Subchain: Squirrel &gt; Dog\n");
            Client.ClientCode(squirrel);
        }
    }
}
Copy<br><br>Chain: Monkey &gt; Squirrel &gt; Dog

Client: Who wants a Nut?
   Squirrel: I'll eat the Nut.
Client: Who wants a Banana?
   Monkey: I'll eat the Banana.
Client: Who wants a Cup of coffee?
   Cup of coffee was left untouched.

Subchain: Squirrel &gt; Dog

Client: Who wants a Nut?
   Squirrel: I'll eat the Nut.
Client: Who wants a Banana?
   Banana was left untouched.
Client: Who wants a Cup of coffee?
   Cup of coffee was left untouched.
Copy]]></description><link>04.-literature-notes/погружение-в-паттерны-проектирования-by-alexander-shvets/цепочка-обязанностей-(cor,-chain-of-command,-chain-of-responsibility).html</link><guid isPermaLink="false">04. Literature Notes/Погружение в ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ by Alexander Shvets/ЦЕПОЧКА ОБЯЗАННОСТЕЙ (CoR, Chain of Command, Chain of Responsibility).md</guid><pubDate>Wed, 08 May 2024 15:46:40 GMT</pubDate></item><item><title><![CDATA[ШАБЛОННЫЙ МЕТОД (Template Method)]]></title><description><![CDATA[ 
 <br><br>Как создать основу алгоритма, но позволить подклассам переопределять его части?<br><br>Создать абстрактный класс, определяющий общую структуру алгоритма, но делегировать реализацию его частей подклассам.<br><br>Строители используют подход похожий на шаблонный метод при строительстве типовых домов. Они используют основной архитектурный проект, но могут вносить небольшие изменения на любом из этапов, чтобы сделать дом чуточку непохожим на другие.<br><br>
<br>Абстрактный класс, определяющий шаги алгоритма и содержащий шаблонный метод, состоящий из вызовов этих шагов.
<br>Конкретные классы переопределяют некоторые шаги алгоритма.
<br>Хуки, которые не обязательно переопределять, но дают дополнительные точки "вклинивания" в шаблонный метод.
<br><br>Когда подклассы должны расширять базовый алгоритм, не меняя его структуры.<br><br>
<br>Разбить алгоритм на шаги.
<br>Создать абстрактный базовый класс с шаблонным методом.
<br>Добавить методы для каждого шага алгоритма.
<br>Подумать о введении хуков между шагами алгоритма.
<br>Создать конкретные классы, унаследовав их от абстрактного класса.
<br><br>Плюсы<br>
<br>Облегчает повторное использование кода.
<br>Минусы<br>
<br>Жестко ограничены скелетом существующего алгоритма.
<br>С ростом количества шагов становится сложно поддерживать.
<br><br>
<br>Фабричный метод можно рассматривать как частный случай Шаблонного метода.
<br>Стратегия использует делегирование, чтобы изменять выполняемые алгоритмы на лету.
<br>Шаблонный метод работает на уровне классов. Стратегия позволяет менять логику отдельных объектов.
<br><br><br>// Паттерн Шаблонный метод
//
// Назначение: Определяет скелет алгоритма, перекладывая ответственность за
// некоторые его шаги на подклассы. Паттерн позволяет подклассам переопределять
// шаги алгоритма, не меняя его общей структуры.

using System;

namespace RefactoringGuru.DesignPatterns.TemplateMethod.Conceptual
{
    // Абстрактный Класс определяет шаблонный метод, содержащий скелет
    // некоторого алгоритма, состоящего из вызовов (обычно) абстрактных
    // примитивных операций.
    //
    // Конкретные подклассы должны реализовать эти операции, но оставить сам
    // шаблонный метод без изменений.
    abstract class AbstractClass
    {
        // Шаблонный метод определяет скелет алгоритма.
        public void TemplateMethod()
        {
            this.BaseOperation1();
            this.RequiredOperations1();
            this.BaseOperation2();
            this.Hook1();
            this.RequiredOperation2();
            this.BaseOperation3();
            this.Hook2();
        }

        // Эти операции уже имеют реализации.
        protected void BaseOperation1()
        {
            Console.WriteLine("AbstractClass says: I am doing the bulk of the work");
        }

        protected void BaseOperation2()
        {
            Console.WriteLine("AbstractClass says: But I let subclasses override some operations");
        }

        protected void BaseOperation3()
        {
            Console.WriteLine("AbstractClass says: But I am doing the bulk of the work anyway");
        }
        
        // А эти операции должны быть реализованы в подклассах.
        protected abstract void RequiredOperations1();

        protected abstract void RequiredOperation2();
        
        // Это «хуки». Подклассы могут переопределять их, но это не обязательно,
        // поскольку у хуков уже есть стандартная (но пустая) реализация. Хуки
        // предоставляют дополнительные точки расширения в некоторых критических
        // местах алгоритма.
        protected virtual void Hook1() { }

        protected virtual void Hook2() { }
    }

    // Конкретные классы должны реализовать все абстрактные операции базового
    // класса. Они также могут переопределить некоторые операции с реализацией
    // по умолчанию.
    class ConcreteClass1 : AbstractClass
    {
        protected override void RequiredOperations1()
        {
            Console.WriteLine("ConcreteClass1 says: Implemented Operation1");
        }

        protected override void RequiredOperation2()
        {
            Console.WriteLine("ConcreteClass1 says: Implemented Operation2");
        }
    }

    // Обычно конкретные классы переопределяют только часть операций базового
    // класса.
    class ConcreteClass2 : AbstractClass
    {
        protected override void RequiredOperations1()
        {
            Console.WriteLine("ConcreteClass2 says: Implemented Operation1");
        }

        protected override void RequiredOperation2()
        {
            Console.WriteLine("ConcreteClass2 says: Implemented Operation2");
        }

        protected override void Hook1()
        {
            Console.WriteLine("ConcreteClass2 says: Overridden Hook1");
        }
    }

    class Client
    {
        // Клиентский код вызывает шаблонный метод для выполнения алгоритма.
        // Клиентский код не должен знать конкретный класс объекта, с которым
        // работает, при условии, что он работает с объектами через интерфейс их
        // базового класса.
        public static void ClientCode(AbstractClass abstractClass)
        {
            // ...
            abstractClass.TemplateMethod();
            // ...
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Same client code can work with different subclasses:");

            Client.ClientCode(new ConcreteClass1());

            Console.Write("\n");
            
            Console.WriteLine("Same client code can work with different subclasses:");
            Client.ClientCode(new ConcreteClass2());
        }
    }
}
Copy<br><br>Same client code can work with different subclasses:
AbstractClass says: I am doing the bulk of the work
ConcreteClass1 says: Implemented Operation1
AbstractClass says: But I let subclasses override some operations
ConcreteClass1 says: Implemented Operation2
AbstractClass says: But I am doing the bulk of the work anyway

Same client code can work with different subclasses:
AbstractClass says: I am doing the bulk of the work
ConcreteClass2 says: Implemented Operation1
AbstractClass says: But I let subclasses override some operations
ConcreteClass2 says: Overridden Hook1
ConcreteClass2 says: Implemented Operation2
AbstractClass says: But I am doing the bulk of the work anyway
Copy]]></description><link>04.-literature-notes/погружение-в-паттерны-проектирования-by-alexander-shvets/шаблонный-метод-(template-method).html</link><guid isPermaLink="false">04. Literature Notes/Погружение в ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ by Alexander Shvets/ШАБЛОННЫЙ МЕТОД (Template Method).md</guid><pubDate>Wed, 08 May 2024 15:52:37 GMT</pubDate></item><item><title><![CDATA[6. The JOIN operation]]></title><description><![CDATA[ 
 <br><br>This tutorial introduces&nbsp;JOIN&nbsp;which allows you to use data from two or more tables. The tables contain all matches and goals from UEFA EURO 2012 Football Championship in Poland and Ukraine.<br><br><a data-tooltip-position="top" aria-label="https://sqlzoo.net/w/images/c/ce/FootballERD.png" rel="noopener" class="external-link" href="https://sqlzoo.net/w/images/c/ce/FootballERD.png" target="_blank"><span alt="Learn SQL step by step - sqlzoo.net-240507-1.jpg" src="Learn SQL step by step - sqlzoo.net-240507-1.jpg" class="internal-embed media-embed image-embed is-loaded"></span></a><img alt="Learn SQL step by step - sqlzoo.net-240507-1.jpg" src="lib/media/learn-sql-step-by-step-sqlzoo.net-240507-1.jpg"><br>game<br><br>goal<br><br>eteam<br><br><br><br>Instead show the&nbsp;name&nbsp;of all players who scored a goal against Germany.<br>SELECT DISTINCT player FROM game join goal on matchid = id
	WHERE (team1 = 'GER' OR team2 = 'GER')
	AND teamid not in ('GER')

Copy<br><br>player<br><br>Robin van Persie<br><br>Michael Krohn-Dehli<br><br>Georgios Samaras<br><br>Dimitris Salpingidis<br><br>Mario Balotelli<br><br><br>COUNT and GROUP BY<br>SELECT teamname, COUNT(matchid) as Goals
	from eteam JOIN goal on id = teamid
    GROUP by teamname
Copy<br><br><br><br>SELECT stadium, COUNT(matchid)
	FROM game JOIN goal on id = matchid
    GROUP BY stadium
Copy<br><br><br><br>SELECT matchid, mdate, COUNT(matchid)
	FROM game JOIN goal on id = matchid
    WHERE team1 = 'POL' or team2 = 'POL'
    GROUP by id
Copy<br><br><br><br>
SELECT matchid, mdate, COUNT(teamid)
	FROM game JOIN goal ON id = matchid
    WHERE teamid = 'GER'
    GROUP BY matchid
Copy<br><br><br><br><br>SELECT 	mdate,
		team1,
        SUM(
        	CASE WHEN team1 = teamid THEN 1
          	ELSE 0
          END
        ) AS score1,
        team2,
        SUM(
        	CASE WHEN team2 = teamid THEN 1
          	ELSE 0
          END
        ) AS score2

	FROM game as GA JOIN goal as GL on (id = matchid)
    GROUP by mdate, matchid, team1, team2

Copy<br><br>]]></description><link>04.-literature-notes/learn-sql-step-by-step-by-sqlzoo.net/6.-the-join-operation.html</link><guid isPermaLink="false">04. Literature Notes/Learn SQL step by step by sqlzoo.net/6. The JOIN operation.md</guid><pubDate>Thu, 09 May 2024 11:30:08 GMT</pubDate><enclosure url="lib/media/learn-sql-step-by-step-sqlzoo.net-240507-1.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/learn-sql-step-by-step-sqlzoo.net-240507-1.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[7. More JOIN operations]]></title><description><![CDATA[ 
 <br>This tutorial introduces the notion of a join. The database consists of three tables&nbsp;movie&nbsp;,&nbsp;actor&nbsp;and&nbsp;casting&nbsp;.<br><br>This database features two entities (movies and actors) in a many-to-many relation. Each entity has its own table. A third table,&nbsp;casting&nbsp;, is used to link them. The relationship is many-to-many because each film features many actors and each actor has appeared in many films.<br><a data-tooltip-position="top" aria-label="https://sqlzoo.net/w/images/1/10/Movie-er.png" rel="noopener" class="external-link" href="https://sqlzoo.net/w/images/1/10/Movie-er.png" target="_blank"><span alt="Learn SQL step by step - sqlzoo.net-240507-2.jpg" src="Learn SQL step by step - sqlzoo.net-240507-2.jpg" class="internal-embed media-embed image-embed is-loaded"></span></a><img alt="Learn SQL step by step - sqlzoo.net-240507-2.jpg" src="lib/media/learn-sql-step-by-step-sqlzoo.net-240507-2.jpg"><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
<br>Which were the busiest years for 'Rock Hudson', show the year and the number of movies he made each year for any year in which he made more than 2 movies.
<br>
SELECT yr, COUNT(title) as titles
	from movie JOIN casting on movie.id = movieid
    JOIN actor on actorid = actor.id
    WHERE name = 'Rock Hudson'
    GROUP BY yr
    HAVING COUNT(title) &gt; 2

Copy<br><br>
<br>List the film title and the leading actor for all of the films 'Julie Andrews' played in.
<br>Did you get "Little Miss Marker twice"?<br><a rel="noopener" class="external-link" href="https://youtu.be/BcNIDK5qYx8?si=JPnwjebIDYDah67f" target="_blank">https://youtu.be/BcNIDK5qYx8?si=JPnwjebIDYDah67f</a><br><a data-tooltip-position="top" aria-label="https://i.ytimg.com/vi/BcNIDK5qYx8/hqdefault.jpg" rel="noopener" class="external-link" href="https://i.ytimg.com/vi/BcNIDK5qYx8/hqdefault.jpg" target="_blank"><span alt="Learn SQL step by step - sqlzoo.net-240507-3.jpg" src="Learn SQL step by step - sqlzoo.net-240507-3.jpg" class="internal-embed media-embed image-embed is-loaded"></span></a><img alt="Learn SQL step by step - sqlzoo.net-240507-3.jpg" src="lib/media/learn-sql-step-by-step-sqlzoo.net-240507-3.jpg"><br>
SELECT m.title, a.name
	FROM movie as m JOIN casting as c on (c.movieid = m.id
                                          and ord = 1)
    JOIN actor as a on a.id = c.actorid
    WHERE m.id in (
      	SELECT movieid FROM casting
        WHERE actorid IN (
        SELECT id FROM actor
        WHERE name='Julie Andrews')
    )


Copy<br><br>
<br>Obtain a list, in alphabetical order, of actors who've had at least 15&nbsp;starring&nbsp;roles.
<br>
SELECT actor.name
	FROM actor JOIN casting on actor.id = casting.actorid
	where casting.ord = 1
    GROUP by actor.name
    HAVING COUNT(ord) &gt;= 15

Copy<br><br>
<br>List the films released in the year 1978 ordered by the number of actors in the cast, then by title.
<br>

SELECT movie.title, COUNT(casting.movieid)
	FROM movie JOIN casting on movie.id = casting.movieid
    WHERE movie.yr = 1978
    GROUP BY movie.title
    ORDER BY COUNT(casting.movieid) DESC, movie.title

Copy<br><br>
<br>List all the people who have worked with 'Art Garfunkel'.
<br>
SELECT DISTINCT actor.name
	FROM actor JOIN casting on casting.actorid = actor.id
    JOIN movie on movie.id = casting.movieid
    WHERE movie.id in (
    	SELECT movie.id FROM movie JOIN casting on movie.id = casting.movieid
      		WHERE casting.actorid in (
            	SELECT id FROM actor WHERE name = 'Art Garfunkel'
            )
    )
    AND actor.name != 'Art Garfunkel'

Copy]]></description><link>04.-literature-notes/learn-sql-step-by-step-by-sqlzoo.net/7.-more-join-operations.html</link><guid isPermaLink="false">04. Literature Notes/Learn SQL step by step by sqlzoo.net/7. More JOIN operations.md</guid><pubDate>Thu, 09 May 2024 11:30:13 GMT</pubDate><enclosure url="lib/media/learn-sql-step-by-step-sqlzoo.net-240507-2.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/learn-sql-step-by-step-sqlzoo.net-240507-2.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[8. Using Null]]></title><description><![CDATA[ 
 <br><br>The school includes many departments. Most teachers work exclusively for a single department. Some teachers have no department.<br><br>teacher<br><br>dept<br><br><br>
<br>List the teachers who have NULL for their department.
<br>
SELECT name FROM teacher where dept is null

Copy<br>Correct answer<br>name<br><br>Spiregrain<br><br>Deadyawn<br><br>
<br>Note the INNER JOIN misses the teachers with no department and the departments with no teacher.
<br>
SELECT teacher.name, dept.name
 FROM teacher INNER JOIN dept
           ON (teacher.dept=dept.id)

Copy<br>Correct answer<br><br>
<br>Use a different JOIN so that all teachers are listed.
<br>SELECT teacher.name, dept.name
 FROM teacher LEFT JOIN dept on (teacher.dept = dept.id)

Copy<br>Correct answer<br><br>
<br>Use a different JOIN so that all departments are listed.
<br>SELECT teacher.name, dept.name
 FROM teacher right JOIN dept on (teacher.dept = dept.id)
Copy<br>Correct answer<br><br><br>
<br>Use COALESCE to print the mobile number. Use the number '07986 444 2266' if there is no number given.&nbsp;Show teacher name and mobile number or '07986 444 2266'
<br>SELECT teacher.name, COALESCE(teacher.mobile, '07986 444 2266')
	FROM teacher
Copy<br>Correct answer<br><br>
<br>Use the COALESCE function and a LEFT JOIN to print the teacher&nbsp;name&nbsp;and department name. Use the string 'None' where there is no department.
<br>SELECT teacher.name, COALESCE(dept.name, 'None')
	FROM teacher LEFT JOIN dept on teacher.dept = dept.id

Copy<br>Correct answer<br><br>
<br>Use COUNT to show the number of teachers and the number of mobile phones.
<br>SELECT COUNT(name) as 'Number of teachers', COUNT(mobile) as 'Number of mobiles'
	FROM teacher
Copy<br>Correct answer<br><br>
<br>Use COUNT and GROUP BY&nbsp;<a data-tooltip-position="top" aria-label="http://dept.name/" rel="noopener" class="external-link" href="http://dept.name/" target="_blank"><strong></strong></a>dept.name&nbsp;to show each department and the number of staff. Use a RIGHT JOIN to ensure that the Engineering department is listed.
<br>SELECT dept.name, COUNT(teacher.name)
	FROM teacher right JOIN dept on dept.id = teacher.dept
    GROUP BY dept.name
Copy<br>Correct answer<br><br><br>
<br>Use CASE to show the&nbsp;name&nbsp;of each teacher followed by 'Sci' if the teacher is in&nbsp;dept&nbsp;1 or 2 and 'Art' otherwise.
<br>SELECT name,
	case when dept &lt; 3
    	then 'Sci'
        else 'Art'
    end
	FROM teacher
Copy<br>Correct answer<br><br>
<br>Use CASE to show the name of each teacher followed by 'Sci' if the teacher is in dept 1 or 2, show 'Art' if the teacher's dept is 3 and 'None' otherwise.
<br>SELECT name,
	case when dept &lt; 3
    	then 'Sci'
        when dept = 3
        then 'Art'
        else 'None'
    end
	FROM teacher
Copy<br>Correct answer<br>]]></description><link>04.-literature-notes/learn-sql-step-by-step-by-sqlzoo.net/8.-using-null.html</link><guid isPermaLink="false">04. Literature Notes/Learn SQL step by step by sqlzoo.net/8. Using Null.md</guid><pubDate>Thu, 09 May 2024 11:29:55 GMT</pubDate></item><item><title><![CDATA[8.1. NSS Tutorial]]></title><description><![CDATA[ 
 <br><br>National Student Survey 2012<br>The National Student Survey&nbsp;<a rel="noopener" class="external-link" href="http://www.thestudentsurvey.com/" target="_blank">http://www.thestudentsurvey.com/</a>&nbsp;is presented to thousands of graduating students in UK Higher Education. The survey asks 22 questions, students can respond with STRONGLY DISAGREE, DISAGREE, NEUTRAL, AGREE or STRONGLY AGREE. The values in these columns represent PERCENTAGES of the total students who responded with that answer.<br>The table&nbsp;nss&nbsp;has one row per institution, subject and question.<br><br>Show the percentage of students who A_STRONGLY_AGREE to question 22 for the subject '(8) Computer Science' show the same figure for the subject '(H) Creative Arts and Design'.<br>Use the&nbsp;ROUND&nbsp;function to show the percentage without decimal places.<br>SELECT subject, ROUND(SUM(A_STRONGLY_AGREE*response/100)/SUM(response)*100)
	FROM nss
    WHERE question = 'Q22'
    	AND subject in ('(H) Creative Arts and Design', '(8) Computer Science')
        GROUP by subject
Copy<br>correct answer<br><br><br>Show the average scores for question 'Q22' for each institution that include 'Manchester' in the name.<br>The column&nbsp;score&nbsp;is a percentage - you must use the method outlined above to multiply the percentage by the&nbsp;response&nbsp;and divide by the total response. Give your answer rounded to the nearest whole number.<br>SELECT institution, ROUND(SUM(score*response/100)/SUM(response)*100)
	FROM nss
    WHERE question = 'Q22'
    	AND institution LIKE '%Manchester%'
    GROUP by institution

Copy<br>correct answer<br><br><br>Show the institution, the total sample size and the number of computing students for institutions in Manchester for 'Q01'.<br>SELECT institution,SUM(sample), (
  SELECT SUM(sample) FROM nss as intern
  WHERE subject = '(8) Computer Science'
  AND extern.institution = intern.institution
  and extern.question = intern.question
	)
  FROM nss as extern
 WHERE question='Q01'
   AND (institution LIKE '%Manchester%')
   GROUP by institution


Copy<br>correct answer<br>]]></description><link>04.-literature-notes/learn-sql-step-by-step-by-sqlzoo.net/8.1.-nss-tutorial.html</link><guid isPermaLink="false">04. Literature Notes/Learn SQL step by step by sqlzoo.net/8.1. NSS Tutorial.md</guid><pubDate>Thu, 09 May 2024 11:30:21 GMT</pubDate></item><item><title><![CDATA[9. Self join]]></title><description><![CDATA[ 
 <br><br><br>This database consists of two tables: stops and routes<br><br>This is a list of areas served by buses. The detail does not really include each actual bus stop - just areas within Edinburgh and whole towns near Edinburgh.<br><br><br>A route is the path through town taken by a bus.<br><br>As different companies use numbers arbitrarily the num and the company are both required to identify a route.<br><br><br>The query shown gives the number of routes that visit either London Road (149) or Craiglockhart (53). Run the query and notice the two services that link these&nbsp;stops&nbsp;have a count of 2. Add a HAVING clause to restrict the output to these two routes.<br>SELECT company, num, COUNT(*)
FROM route WHERE stop=149 OR stop=53
GROUP BY company, num
HAVING COUNT(*) &gt;=2

Copy<br><br><br>Execute the self join shown and observe that b.stop gives all the places you can get to from Craiglockhart, without changing routes. Change the query so that it shows the services from Craiglockhart to London Road.<br>SELECT a.company, a.num, a.stop, b.stop
FROM route a JOIN route b ON
  (a.company=b.company AND a.num=b.num)
WHERE a.stop=53 and b.stop = 149
Copy<br><br><br>The query shown is similar to the previous one, however by joining two copies of the&nbsp;stops&nbsp;table we can refer to&nbsp;stops&nbsp;by&nbsp;name&nbsp;rather than by number. Change the query so that the services between 'Craiglockhart' and 'London Road' are shown. If you are tired of these places try 'Fairmilehead' against 'Tollcross'<br>SELECT a.company, a.num, stopa.name, stopb.name
FROM route a JOIN route b ON
  (a.company=b.company AND a.num=b.num)
  JOIN stops stopa ON (a.stop=stopa.id)
  JOIN stops stopb ON (b.stop=stopb.id)
WHERE stopa.name='Craiglockhart' and stopb.name = 'London Road'
Copy<br><br><br><br>Give a list of all the services which connect stops 115 and 137 ('Haymarket' and 'Leith')<br>SELECT DISTINCT a.company, a.num
	FROM route a JOIN route b ON
    	(a.company = b.company AND a.num = b.num)
        JOIN stops sa on (a.stop = sa.id)
        JOIN stops sb on (b.stop = sb.id)
        WHERE sa.name = 'Haymarket' and sb.name = 'Leith'
Copy<br><br><br>Give a list of the services which connect the&nbsp;stops&nbsp;'Craiglockhart' and 'Tollcross'<br>SELECT a.company, a.num
	FROM route a JOIN route b on
    	(a.num = b.num and a.company = b.company)
    JOIN stops aa on (a.stop = aa.id)
    JOIN stops bb on (b.stop = bb.id)
    WHERE aa.name = 'Craiglockhart' and bb.name = 'Tollcross'
Copy<br><br><br>Give a distinct list of the&nbsp;stops&nbsp;which may be reached from 'Craiglockhart' by taking one bus, including 'Craiglockhart' itself, offered by the LRT company. Include the company and bus no. of the relevant services.<br>
SELECT DISTINCT bb.name, a.company, a.num
	FROM route a JOIN route b on
    	(a.num = b.num and a.company = b.company)
    JOIN stops aa on (a.stop = aa.id)
    JOIN stops bb on (b.stop = bb.id)
    WHERE aa.name = 'Craiglockhart'

Copy<br><br><br><br>Find the routes involving two buses that can go from&nbsp;Craiglockhart&nbsp;to&nbsp;Lochend.<br>Show the bus no. and company for the first bus, the name of the stop for the transfer,<br>and the bus no. and company for the second bus.<br>SELECT a.num, a.company,bb.name, c.num, c.company
	FROM route a
    	JOIN route b on a.num = b.num and a.company = b.company
        JOIN (route c JOIN route d on c.company = d.company and c.num = d.num)
        JOIN stops aa on a.stop = aa.id
        JOIN stops bb on b.stop = bb.id
        JOIN stops cc on c.stop = cc.id
		JOIN stops dd on d.stop = dd.id
    where aa.name =  'Craiglockhart'
    	AND dd.name = 'Lochend'
        AND bb.name = cc.name
    ORDER by 1,2,3,4,5

Copy]]></description><link>04.-literature-notes/learn-sql-step-by-step-by-sqlzoo.net/9.-self-join.html</link><guid isPermaLink="false">04. Literature Notes/Learn SQL step by step by sqlzoo.net/9. Self join.md</guid><pubDate>Thu, 09 May 2024 11:30:25 GMT</pubDate></item><item><title><![CDATA[6. The JOIN operation]]></title><description><![CDATA[ 
 <br><br>6. The JOIN operation<br><br><br><br>This tutorial introduces&nbsp;JOIN&nbsp;which allows you to use data from two or more tables. The tables contain all matches and goals from UEFA EURO 2012 Football Championship in Poland and Ukraine.<br><br><a data-tooltip-position="top" aria-label="https://sqlzoo.net/w/images/c/ce/FootballERD.png" rel="noopener" class="external-link" href="https://sqlzoo.net/w/images/c/ce/FootballERD.png" target="_blank"><span alt="Learn SQL step by step - sqlzoo.net-240507-1.jpg" src="Learn SQL step by step - sqlzoo.net-240507-1.jpg" class="internal-embed media-embed image-embed is-loaded"></span></a><img alt="Learn SQL step by step - sqlzoo.net-240507-1.jpg" src="lib/media/learn-sql-step-by-step-sqlzoo.net-240507-1.jpg"><br>game<br><br>goal<br><br>eteam<br><br><br><br>Instead show the&nbsp;name&nbsp;of all players who scored a goal against Germany.<br>SELECT DISTINCT player FROM game join goal on matchid = id
	WHERE (team1 = 'GER' OR team2 = 'GER')
	AND teamid not in ('GER')

Copy<br><br>player<br><br>Robin van Persie<br><br>Michael Krohn-Dehli<br><br>Georgios Samaras<br><br>Dimitris Salpingidis<br><br>Mario Balotelli<br><br><br>COUNT and GROUP BY<br>SELECT teamname, COUNT(matchid) as Goals
	from eteam JOIN goal on id = teamid
    GROUP by teamname
Copy<br><br><br><br>SELECT stadium, COUNT(matchid)
	FROM game JOIN goal on id = matchid
    GROUP BY stadium
Copy<br><br><br><br>SELECT matchid, mdate, COUNT(matchid)
	FROM game JOIN goal on id = matchid
    WHERE team1 = 'POL' or team2 = 'POL'
    GROUP by id
Copy<br><br><br><br>
SELECT matchid, mdate, COUNT(teamid)
	FROM game JOIN goal ON id = matchid
    WHERE teamid = 'GER'
    GROUP BY matchid
Copy<br><br><br><br><br>SELECT 	mdate,
		team1,
        SUM(
        	CASE WHEN team1 = teamid THEN 1
          	ELSE 0
          END
        ) AS score1,
        team2,
        SUM(
        	CASE WHEN team2 = teamid THEN 1
          	ELSE 0
          END
        ) AS score2

	FROM game as GA JOIN goal as GL on (id = matchid)
    GROUP by mdate, matchid, team1, team2

Copy<br><br>| 9 June 2012  | NED   | 0      | DEN   | 1      |<br>
| 9 June 2012  | GER   | 1      | POR   | 0      |<br><br>7. More JOIN operations<br><br><br>This tutorial introduces the notion of a join. The database consists of three tables&nbsp;movie&nbsp;,&nbsp;actor&nbsp;and&nbsp;casting&nbsp;.<br><br>This database features two entities (movies and actors) in a many-to-many relation. Each entity has its own table. A third table,&nbsp;casting&nbsp;, is used to link them. The relationship is many-to-many because each film features many actors and each actor has appeared in many films.<br><a data-tooltip-position="top" aria-label="https://sqlzoo.net/w/images/1/10/Movie-er.png" rel="noopener" class="external-link" href="https://sqlzoo.net/w/images/1/10/Movie-er.png" target="_blank"><span alt="Learn SQL step by step - sqlzoo.net-240507-2.jpg" src="Learn SQL step by step - sqlzoo.net-240507-2.jpg" class="internal-embed media-embed image-embed is-loaded"></span></a><img alt="Learn SQL step by step - sqlzoo.net-240507-2.jpg" src="lib/media/learn-sql-step-by-step-sqlzoo.net-240507-2.jpg"><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
<br>Which were the busiest years for 'Rock Hudson', show the year and the number of movies he made each year for any year in which he made more than 2 movies.
<br>
SELECT yr, COUNT(title) as titles
	from movie JOIN casting on movie.id = movieid
    JOIN actor on actorid = actor.id
    WHERE name = 'Rock Hudson'
    GROUP BY yr
    HAVING COUNT(title) &gt; 2

Copy<br><br>
<br>List the film title and the leading actor for all of the films 'Julie Andrews' played in.
<br>Did you get "Little Miss Marker twice"?<br><a rel="noopener" class="external-link" href="https://youtu.be/BcNIDK5qYx8?si=JPnwjebIDYDah67f" target="_blank">https://youtu.be/BcNIDK5qYx8?si=JPnwjebIDYDah67f</a><br><a data-tooltip-position="top" aria-label="https://i.ytimg.com/vi/BcNIDK5qYx8/hqdefault.jpg" rel="noopener" class="external-link" href="https://i.ytimg.com/vi/BcNIDK5qYx8/hqdefault.jpg" target="_blank"><span alt="Learn SQL step by step - sqlzoo.net-240507-3.jpg" src="Learn SQL step by step - sqlzoo.net-240507-3.jpg" class="internal-embed media-embed image-embed is-loaded"></span></a><img alt="Learn SQL step by step - sqlzoo.net-240507-3.jpg" src="lib/media/learn-sql-step-by-step-sqlzoo.net-240507-3.jpg"><br>
SELECT m.title, a.name
	FROM movie as m JOIN casting as c on (c.movieid = m.id
                                          and ord = 1)
    JOIN actor as a on a.id = c.actorid
    WHERE m.id in (
      	SELECT movieid FROM casting
        WHERE actorid IN (
        SELECT id FROM actor
        WHERE name='Julie Andrews')
    )


Copy<br><br>
<br>Obtain a list, in alphabetical order, of actors who've had at least 15&nbsp;starring&nbsp;roles.
<br>
SELECT actor.name
	FROM actor JOIN casting on actor.id = casting.actorid
	where casting.ord = 1
    GROUP by actor.name
    HAVING COUNT(ord) &gt;= 15

Copy<br><br>
<br>List the films released in the year 1978 ordered by the number of actors in the cast, then by title.
<br>

SELECT movie.title, COUNT(casting.movieid)
	FROM movie JOIN casting on movie.id = casting.movieid
    WHERE movie.yr = 1978
    GROUP BY movie.title
    ORDER BY COUNT(casting.movieid) DESC, movie.title

Copy<br><br>
<br>List all the people who have worked with 'Art Garfunkel'.
<br>
SELECT DISTINCT actor.name
	FROM actor JOIN casting on casting.actorid = actor.id
    JOIN movie on movie.id = casting.movieid
    WHERE movie.id in (
    	SELECT movie.id FROM movie JOIN casting on movie.id = casting.movieid
      		WHERE casting.actorid in (
            	SELECT id FROM actor WHERE name = 'Art Garfunkel'
            )
    )
    AND actor.name != 'Art Garfunkel'

Copy<br><br>8. Using Null<br><br><br><br>The school includes many departments. Most teachers work exclusively for a single department. Some teachers have no department.<br><br>teacher<br><br>dept<br><br><br>
<br>List the teachers who have NULL for their department.
<br>
SELECT name FROM teacher where dept is null

Copy<br>Correct answer<br>name<br><br>Spiregrain<br><br>Deadyawn<br><br>
<br>Note the INNER JOIN misses the teachers with no department and the departments with no teacher.
<br>
SELECT teacher.name, dept.name
 FROM teacher INNER JOIN dept
           ON (teacher.dept=dept.id)

Copy<br>Correct answer<br><br>
<br>Use a different JOIN so that all teachers are listed.
<br>SELECT teacher.name, dept.name
 FROM teacher LEFT JOIN dept on (teacher.dept = dept.id)

Copy<br>Correct answer<br><br>
<br>Use a different JOIN so that all departments are listed.
<br>SELECT teacher.name, dept.name
 FROM teacher right JOIN dept on (teacher.dept = dept.id)
Copy<br>Correct answer<br><br><br>
<br>Use COALESCE to print the mobile number. Use the number '07986 444 2266' if there is no number given.&nbsp;Show teacher name and mobile number or '07986 444 2266'
<br>SELECT teacher.name, COALESCE(teacher.mobile, '07986 444 2266')
	FROM teacher
Copy<br>Correct answer<br><br>
<br>Use the COALESCE function and a LEFT JOIN to print the teacher&nbsp;name&nbsp;and department name. Use the string 'None' where there is no department.
<br>SELECT teacher.name, COALESCE(dept.name, 'None')
	FROM teacher LEFT JOIN dept on teacher.dept = dept.id

Copy<br>Correct answer<br><br>
<br>Use COUNT to show the number of teachers and the number of mobile phones.
<br>SELECT COUNT(name) as 'Number of teachers', COUNT(mobile) as 'Number of mobiles'
	FROM teacher
Copy<br>Correct answer<br><br>
<br>Use COUNT and GROUP BY&nbsp;<a data-tooltip-position="top" aria-label="http://dept.name/" rel="noopener" class="external-link" href="http://dept.name/" target="_blank"><strong></strong></a>dept.name&nbsp;to show each department and the number of staff. Use a RIGHT JOIN to ensure that the Engineering department is listed.
<br>SELECT dept.name, COUNT(teacher.name)
	FROM teacher right JOIN dept on dept.id = teacher.dept
    GROUP BY dept.name
Copy<br>Correct answer<br><br><br>
<br>Use CASE to show the&nbsp;name&nbsp;of each teacher followed by 'Sci' if the teacher is in&nbsp;dept&nbsp;1 or 2 and 'Art' otherwise.
<br>SELECT name,
	case when dept &lt; 3
    	then 'Sci'
        else 'Art'
    end
	FROM teacher
Copy<br>Correct answer<br><br>
<br>Use CASE to show the name of each teacher followed by 'Sci' if the teacher is in dept 1 or 2, show 'Art' if the teacher's dept is 3 and 'None' otherwise.
<br>SELECT name,
	case when dept &lt; 3
    	then 'Sci'
        when dept = 3
        then 'Art'
        else 'None'
    end
	FROM teacher
Copy<br>Correct answer<br><br><br>8.1. NSS Tutorial<br><br><br><br>National Student Survey 2012<br>The National Student Survey&nbsp;<a rel="noopener" class="external-link" href="http://www.thestudentsurvey.com/" target="_blank">http://www.thestudentsurvey.com/</a>&nbsp;is presented to thousands of graduating students in UK Higher Education. The survey asks 22 questions, students can respond with STRONGLY DISAGREE, DISAGREE, NEUTRAL, AGREE or STRONGLY AGREE. The values in these columns represent PERCENTAGES of the total students who responded with that answer.<br>The table&nbsp;nss&nbsp;has one row per institution, subject and question.<br><br>Show the percentage of students who A_STRONGLY_AGREE to question 22 for the subject '(8) Computer Science' show the same figure for the subject '(H) Creative Arts and Design'.<br>Use the&nbsp;ROUND&nbsp;function to show the percentage without decimal places.<br>SELECT subject, ROUND(SUM(A_STRONGLY_AGREE*response/100)/SUM(response)*100)
	FROM nss
    WHERE question = 'Q22'
    	AND subject in ('(H) Creative Arts and Design', '(8) Computer Science')
        GROUP by subject
Copy<br>correct answer<br><br><br>Show the average scores for question 'Q22' for each institution that include 'Manchester' in the name.<br>The column&nbsp;score&nbsp;is a percentage - you must use the method outlined above to multiply the percentage by the&nbsp;response&nbsp;and divide by the total response. Give your answer rounded to the nearest whole number.<br>SELECT institution, ROUND(SUM(score*response/100)/SUM(response)*100)
	FROM nss
    WHERE question = 'Q22'
    	AND institution LIKE '%Manchester%'
    GROUP by institution

Copy<br>correct answer<br><br><br>Show the institution, the total sample size and the number of computing students for institutions in Manchester for 'Q01'.<br>SELECT institution,SUM(sample), (
  SELECT SUM(sample) FROM nss as intern
  WHERE subject = '(8) Computer Science'
  AND extern.institution = intern.institution
  and extern.question = intern.question
	)
  FROM nss as extern
 WHERE question='Q01'
   AND (institution LIKE '%Manchester%')
   GROUP by institution


Copy<br>correct answer<br>|University of Manchester|8065|180|<br><br>9. Self join<br><br><br><br><br>This database consists of two tables: stops and routes<br><br>This is a list of areas served by buses. The detail does not really include each actual bus stop - just areas within Edinburgh and whole towns near Edinburgh.<br><br><br>A route is the path through town taken by a bus.<br><br>As different companies use numbers arbitrarily the num and the company are both required to identify a route.<br><br><br>The query shown gives the number of routes that visit either London Road (149) or Craiglockhart (53). Run the query and notice the two services that link these&nbsp;stops&nbsp;have a count of 2. Add a HAVING clause to restrict the output to these two routes.<br>SELECT company, num, COUNT(*)
FROM route WHERE stop=149 OR stop=53
GROUP BY company, num
HAVING COUNT(*) &gt;=2

Copy<br><br><br>Execute the self join shown and observe that b.stop gives all the places you can get to from Craiglockhart, without changing routes. Change the query so that it shows the services from Craiglockhart to London Road.<br>SELECT a.company, a.num, a.stop, b.stop
FROM route a JOIN route b ON
  (a.company=b.company AND a.num=b.num)
WHERE a.stop=53 and b.stop = 149
Copy<br><br><br>The query shown is similar to the previous one, however by joining two copies of the&nbsp;stops&nbsp;table we can refer to&nbsp;stops&nbsp;by&nbsp;name&nbsp;rather than by number. Change the query so that the services between 'Craiglockhart' and 'London Road' are shown. If you are tired of these places try 'Fairmilehead' against 'Tollcross'<br>SELECT a.company, a.num, stopa.name, stopb.name
FROM route a JOIN route b ON
  (a.company=b.company AND a.num=b.num)
  JOIN stops stopa ON (a.stop=stopa.id)
  JOIN stops stopb ON (b.stop=stopb.id)
WHERE stopa.name='Craiglockhart' and stopb.name = 'London Road'
Copy<br><br><br><br>Give a list of all the services which connect stops 115 and 137 ('Haymarket' and 'Leith')<br>SELECT DISTINCT a.company, a.num
	FROM route a JOIN route b ON
    	(a.company = b.company AND a.num = b.num)
        JOIN stops sa on (a.stop = sa.id)
        JOIN stops sb on (b.stop = sb.id)
        WHERE sa.name = 'Haymarket' and sb.name = 'Leith'
Copy<br><br><br>]]></description><link>04.-literature-notes/learn-sql-step-by-step-by-sqlzoo.net/learn-sql-step-by-step-by-sqlzoo.net.html</link><guid isPermaLink="false">04. Literature Notes/Learn SQL step by step by sqlzoo.net/Learn SQL step by step by sqlzoo.net.md</guid><pubDate>Thu, 09 May 2024 11:30:36 GMT</pubDate><enclosure url="lib/media/learn-sql-step-by-step-sqlzoo.net-240507-1.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/learn-sql-step-by-step-sqlzoo.net-240507-1.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Агрегатные операции]]></title><description><![CDATA[ 
 <br>К агрегатным операциям относят различные операции над выборкой, например, получение числа элементов, получение минимального, максимального и среднего значения в выборке, а также суммирование значений.<br><br>Метод Aggregate выполняет общую агрегацию элементов коллекции в зависимости от указанного выражения. Например:<br>int[] numbers = { 1, 2, 3, 4, 5};int query = numbers.Aggregate((x,y)=&gt; x - y);Console.WriteLine(query);   // -13
Copy<br>Переменная query будет представлять результат агрегации массива. В качестве условия агрегации используется выражение&nbsp;(x,y)=&gt; x - y, то есть вначале из первого элемента вычитается второй, потом из получившегося значения вычитается третий и так далее. То есть будет эквивалентно выражению:<br>int query = 1 - 2 - 3 - 4 - 5
Copy<br>В итоге мы получим число -13. Соответственно мы бы могли использовать любые другие операции, например, сложение:<br>int query = numbers.Aggregate((x,y)=&gt; x + y); // аналогично 1 + 2 + 3 + 4 + 5
Copy<br>Еще одна версия метода позволяет задать начальное значение, с которого начинается цепь агрегатных операций:<br>string[] words = { "Gaudeamus", "igitur", "Juvenes", "dum", "sumus" };var sentence = words.Aggregate("Text:", (first, next) =&gt; $"{first} {next}");Console.WriteLine(sentence);  // Text: Gaudeamus igitur Juvenes dum sumus
Copy<br>В данном случае объединяются все элементы массива words, но первым элемент агрегатной операции будет строка “Text:”.<br><br>Для получения числа элементов в выборке используется метод&nbsp;Count():<br>int[] numbers = { 1, 2, 3, 4, 10, 34, 55, 66, 77, 88 };int size = numbers.Count();  // 10Console.WriteLine(size);
Copy<br>Метод&nbsp;Count()&nbsp;в одной из версий также может принимать лямбда-выражение, которое устанавливает условие выборки. Поэтому мы можем в данном случае не использовать выражение&nbsp;Where:<br>int[] numbers = { 1, 2, 3, 4, 10, 34, 55, 66, 77, 88 };//  количество четных чисел, которые больше 10int size = numbers.Count(i =&gt; i % 2 == 0 &amp;&amp; i &gt; 10);Console.WriteLine(size);    // 3
Copy<br><br>Для получения суммы значений применяется метод&nbsp;Sum:<br>int[] numbers = { 1, 2, 3, 4, 10, 34, 55, 66, 77, 88 };int sum = numbers.Sum();Console.WriteLine(sum);     // 340
Copy<br>Метод&nbsp;Sum()&nbsp;имеет ряд перегрузок. В частности, если у нас набор сложных объектов, как в примере выше, то мы можем указать свойство, значения которого будут суммироваться:<br>Person[] people = { new Person("Tom", 37), new Person("Sam", 28), new Person("Bob", 41) };int ageSum = people.Sum(p =&gt; p.Age);Console.WriteLine(ageSum);     // 106record class Person(string Name, int Age);
Copy<br>В данном случае вычисляется сумма значений свойств Age объектов Person из массива people.<br><br>Для нахождения минимального значения применяется метод&nbsp;Min(), для получения максимального - метод&nbsp;Max(), а для нахождения среднего значения - метод&nbsp;Average(). Их действие похоже на методы Sum и Count:<br>int[] numbers = { 1, 2, 3, 4, 10, 34, 55, 66, 77, 88 };int min = numbers.Min();int max = numbers.Max();double average = numbers.Average();Console.WriteLine($"Min: {min}");           // Min: 1Console.WriteLine($"Max: {max}");           // Max: 88Console.WriteLine($"Average: {average}");   // Average: 34
Copy<br>Если мы работаем со сложными объектами, то в эти методы передается делегат, который принимает свойство, применяемое в вычислениях:<br>Person[] people = { new Person("Tom", 37), new Person("Sam", 28), new Person("Bob", 41) };int minAge = people.Min(p =&gt; p.Age); // минимальный возрастint maxAge = people.Max(p =&gt; p.Age); // максимальный возрастdouble averageAge = people.Average(p =&gt; p.Age); //средний возрастConsole.WriteLine($"Min Age: {minAge}");           // Min Age: 28Console.WriteLine($"Max Age: {maxAge}");           // Max Age: 41Console.WriteLine($"Average Age: {averageAge}");   // Average Age: 35,33record class Person(string Name, int Age);
Copy<br>В данном случае для вычислений применяется свойство Age, то есть вычисляется минимальный, максимальный и средний возраст.]]></description><link>04.-literature-notes/linq-by-metanit/агрегатные-операции.html</link><guid isPermaLink="false">04. Literature Notes/LINQ by Metanit/Агрегатные операции.md</guid><pubDate>Wed, 08 May 2024 21:42:25 GMT</pubDate></item><item><title><![CDATA[Группировка]]></title><description><![CDATA[ 
 <br>Для группировки данных по определенным параметрам применяется оператор&nbsp;group by&nbsp;и метод&nbsp;GroupBy().<br><br>Допустим, у нас есть набор из объектов следующего типа:<br>record class Person(string Name, string Company);
Copy<br>Данный класс представляет пользователя и имеет два свойства: Name (имя пользователя) и Company (компания, где работает пользователь). Сгруппируем набор пользователей по компании:<br>Person[] people ={    new Person("Tom", "Microsoft"), new Person("Sam", "Google"),    new Person("Bob", "JetBrains"), new Person("Mike", "Microsoft"),    new Person("Kate", "JetBrains"), new Person("Alice", "Microsoft"),};var companies = from person in people                group person by person.Company;foreach(var company in companies){    Console.WriteLine(company.Key);    foreach(var person in company)    {        Console.WriteLine(person.Name);    }    Console.WriteLine(); // для разделения между группами}record class Person(string Name, string Company);
Copy<br>Если в выражении LINQ последним оператором, выполняющим операции над выборкой, является&nbsp;group, то оператор&nbsp;select&nbsp;не применяется.<br>Оператор&nbsp;group&nbsp;принимает критерий по которому проводится группировка:<br>group person by person.Company
Copy<br>в данном случае группировка идет по свойству Company. Результатом оператора&nbsp;group&nbsp;является выборка, которая состоит из групп. Каждая группа представляет объект&nbsp;IGrouping&lt;K, V&gt;: параметр&nbsp;K&nbsp;указывает на тип ключа - тип свойства, по которому идет группировка (здесь это тип string). А параметр&nbsp;V&nbsp;представляет тип сгруппированных объектов - в данном случае группируем объекты Person.<br>Каждая группа имеет ключ, который мы можем получить через свойство Key:&nbsp;g.Key. Здесь это будет название компании.<br>Все элементы внутри группы можно получить с помощью дополнительной итерации. Элементы группы имеют тот же тип, что и тип объектов, которые передавались оператору&nbsp;group, то есть в данном случае объекты типа&nbsp;Person.<br>В итоге мы получим следующий вывод:<br>Microsoft
Tom
Mike
Alice

Google
Sam

JetBrains
Bob
Kate
Copy<br><br>В качестве альтернативы можно использовать метод расширения&nbsp;GroupBy. Он имеет ряд перегрузок, возьмем самую простую из них:<br>GroupBy&lt;TSource,TKey&gt; (Func&lt;TSource,TKey&gt; keySelector);
Copy<br>Данная версия получает делегат, которые в качестве параметра принимает каждый элемент коллекции и возвращает критерий группировки.<br>Перепишем предыдущий пример с помощью метода GroupBy:<br>Person[] people ={    new Person("Tom", "Microsoft"), new Person("Sam", "Google"),    new Person("Bob", "JetBrains"), new Person("Mike", "Microsoft"),    new Person("Kate", "JetBrains"), new Person("Alice", "Microsoft"),};var companies = people.GroupBy(p =&gt; p.Company);foreach(var company in companies){    Console.WriteLine(company.Key);    foreach(var person in company)    {        Console.WriteLine(person.Name);    }    Console.WriteLine(); // для разделения между группами}record class Person(string Name, string Company);
Copy<br><br>Теперь изменим запрос и создадим из группы новый объект:<br>Person[] people ={    new Person("Tom", "Microsoft"), new Person("Sam", "Google"),    new Person("Bob", "JetBrains"), new Person("Mike", "Microsoft"),    new Person("Kate", "JetBrains"), new Person("Alice", "Microsoft"),};var companies = from person in people                group person by person.Company into g                select new { Name = g.Key, Count = g.Count() }; ;foreach(var company in companies){    Console.WriteLine($"{company.Name} : {company.Count}");}record class Person(string Name, string Company);
Copy<br>Выражение<br>group person by person.Company into g
Copy<br>определяет переменную&nbsp;g, которая будет содержать группу. С помощью этой переменной мы можем затем создать новый объект анонимного типа (хотя также можно под данную задачу определить новый класс):<br>select new { Name = g.Key, Count = g.Count() }
Copy<br>Теперь результат запроса LINQ будет представлять набор объектов таких анонимных типов, у которых два свойства Name и Count.<br>Результат программы:<br>Microsoft : 3
Google : 1
JetBrains : 2
Copy<br>Аналогичная операция с помощью метода&nbsp;GroupBy():<br>var companies = people                    .GroupBy(p=&gt;p.Company)                    .Select(g =&gt; new { Name = g.Key, Count = g.Count() });
Copy<br><br>Также мы можем осуществлять вложенные запросы:<br>Person[] people ={    new Person("Tom", "Microsoft"), new Person("Sam", "Google"),    new Person("Bob", "JetBrains"), new Person("Mike", "Microsoft"),    new Person("Kate", "JetBrains"), new Person("Alice", "Microsoft"),};var companies = from person in people                group person by person.Company into g                select new                {                    Name = g.Key,                    Count = g.Count(),                    Employees = from p in g select p                };foreach (var company in companies){    Console.WriteLine($"{company.Name} : {company.Count}");    foreach(var employee in company.Employees)    {        Console.WriteLine(employee.Name);    }    Console.WriteLine(); // для разделения компаний}record class Person(string Name, string Company);
Copy<br>Здесь свойство Employees каждой группы формируется с помощью дополнительного запроса, который выбирает всех пользователей в этой группе. Консольный вывод программы:<br>Microsoft : 3
Tom
Mike
Alice

Google : 1
Sam

JetBrains : 2
Bob
Kate
Copy<br>Аналогичный запрос с помощью метода GroupBy:<br>var companies = people                    .GroupBy(p=&gt;p.Company)                    .Select(g =&gt; new                    {                        Name = g.Key,                        Count = g.Count(),                        Employees = g.Select(p=&gt; p)                    });
Copy]]></description><link>04.-literature-notes/linq-by-metanit/группировка.html</link><guid isPermaLink="false">04. Literature Notes/LINQ by Metanit/Группировка.md</guid><pubDate>Wed, 08 May 2024 21:42:20 GMT</pubDate></item><item><title><![CDATA[Делегаты в запросах LINQ]]></title><description><![CDATA[ 
 <br>Если мы обратимся к определению многих методов расширений LINQ, то увидим, что в качестве параметра многие из них принимают делегаты например,&nbsp;Func&lt;TSource, bool&gt;, например, определение метода Where:<br>public static IEnumerable&lt;TSource&gt; Where&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, bool&gt; predicate)
Copy<br>Хотя, как правило, в качестве делегата в подобные методы удобно передавать лямбда-выражения. Но тем не менее мы также можем передать полноценные методы. Например:<br>string[] people = { "Tom", "Bob", "Kate", "Tim", "Mike", "Sam" };
var result = people.Where(LenghtIs3);
foreach (var person in result)
	Console.WriteLine(person);
bool LenghtIs3(string name) =&gt; name.Length == 3;
Copy<br>Здесь метод LenghtIs3 проверяет, равна ли длина строки 3 символам. Так как в данном случае набор элементов, к которому применяется метод Where, содержит объекты string, то в метод в качестве параметра передается объект этого типа. Возвращаемый тип должен представлять тип&nbsp;bool: если true, то объект string соответствует условию и попадает в выходную коллекцию.<br>Рассмотрим другой пример. Пусть метод&nbsp;Select()&nbsp;применяется к коллекции целых чисел и преобразует каждое число в его квадрат:<br>int[] numbers = { -2, -1, 0, 1, 2, 3, 4, 5, 6, 7 };
var result = numbers.Where(i =&gt; i &gt; 0).Select(Square);
foreach (int i in result)    
	Console.WriteLine(i);
int Square(int n) =&gt; n * n;
Copy<br>Метод Select в качестве параметра принимает тип&nbsp;Func&lt;TSource, TResult&gt; selector. Так как у нас набор объектов&nbsp;int, то входным параметром делегата также будет объект типа int. В качестве типа выходного параметра выберем int, так как здесь квадрат числа - это целочисленное значение.]]></description><link>04.-literature-notes/linq-by-metanit/делегаты-в-запросах-linq.html</link><guid isPermaLink="false">04. Literature Notes/LINQ by Metanit/Делегаты в запросах LINQ.md</guid><pubDate>Wed, 08 May 2024 21:42:13 GMT</pubDate></item><item><title><![CDATA[Методы Skip и Take]]></title><description><![CDATA[ 
 <br>Ряд методов в LINQ позволяют получить часть коллекции, в частности, такие методы как Skip, Take, SkipWhile, TakeWhile.<br><br>Метод&nbsp;Skip()&nbsp;пропускает определенное количество элементов. Количество пропускаемых элементов передается в качестве параметра в метод:<br>string[] people = { "Tom", "Sam", "Bob", "Mike", "Kate" };// пропускаем первые два элементаvar result = people.Skip(2);    // "Bob", "Mike", "Kate"foreach (var person in result)    Console.WriteLine(person);
Copy<br>В данном случае пропускаем первые два элемента. Консольный вывод:<br>Bob
Mike
Kate
Copy<br>Если необходимо пропустить определенное количество элементов с конца коллекции, то применяется метод&nbsp;SkipLast():<br>string[] people = { "Tom", "Sam", "Bob", "Mike", "Kate" };// пропускаем последние два элементаvar result = people.SkipLast(2);    // "Tom", "Sam", "Bob"foreach (var person in result)    Console.WriteLine(person);
Copy<br>В данном случае пропускаем последние два элемента. Консольный вывод:<br>Tom
Sam
Bob
Copy<br><br>Метод&nbsp;SkipWhile()&nbsp;пропускает цепочку элементов, начиная с первого элемента, пока они удовлетворяют определенному условию:<br>SkipWhile(Func&lt;TSource, bool&gt; predicate);
Copy<br>В метод передается делегат, который представляет условие, он получает каждый элемент коллекции и возвращает значение true, если элемент соответствует условию. Например:<br>string[] people = { "Tom", "Sam", "Mike", "Kate", "Bob" };// пропускаем первые элементы, длина которых равна 3var result = people.SkipWhile(p=&gt; p.Length == 3);    // "Mike", "Kate", "Bob"foreach (var person in result)    Console.WriteLine(person);
Copy<br>Здесь метод SkipWhile пропускает элементы, длина которых равна 3 символам. Первые два элемента массива people (“Tom”, “Sam”) соответствуют этому условию и поэтому будут пропущены. На третьем элементе (“Mike”) цепочка обрывается, поэтому последний элемент (“Bob”), длина которго тоже равна 3-м символам, не будет пропущен и будет включен в выходную коллекцию:<br>Mike
Kate
Bob
Copy<br>Если в массиве первый элемент имел бы длину больше или меньше 3 символов, то цепочка пропускаемых элементов прервалась бы уже на первом элементе, и поэтому метод SkipWhile возвратил бы все элементы массива.<br><br>Метод&nbsp;Take()&nbsp;извлекает определенное число элементов. Количество извлекаемых элементов передается в метод в качестве параметра. Например, извлечем три первых элемента:<br>string[] people = { "Tom", "Sam", "Mike", "Kate", "Bob" };// извлекаем первые 3 элементаvar result = people.Take(3);    // "Tom", "Sam", "Mike"foreach (var person in result)    Console.WriteLine(person);
Copy<br>Метод&nbsp;TakeLast()&nbsp;извлекает определенное количество элементов с конце коллекции:<br>string[] people = { "Tom", "Sam", "Mike", "Kate", "Bob" };// извлекаем последние 3 элементаvar result = people.TakeLast(3);    // "Mike", "Kate", "Bob"foreach (var person in result)    Console.WriteLine(person);
Copy<br><br>Метод&nbsp;TakeWhile()&nbsp;выбирает цепочку элементов, начиная с первого элемента, пока они удовлетворяют определенному условию:<br>TakeWhile(Func&lt;TSource, bool&gt; predicate);
Copy<br>В метод передается делегат, который представляет условие, он получает каждый элемент коллекции и возвращает значение true, если элемент соответствует условию. Например:<br>string[] people = { "Tom", "Sam", "Mike", "Kate", "Bob" };// извлекаем первые элементы, длина которых равна 3var result = people.TakeWhile(p=&gt; p.Length == 3);    // "Tom", "Sam"foreach (var person in result)    Console.WriteLine(person);
Copy<br>Здесь метод TakeWhile выбирает элементы, длина которых равна 3 символам. Первые два элемента массива people (“Tom”, “Sam”) соответствуют этому условию и поэтому будут выбраны в выходную коллекцию. На третьем элементе (“Mike”) цепочка обрывается, поэтому последний элемент (“Bob”), длина которго тоже равна 3-м символам, не будет включен в выходную коллекцию:<br>Tom
Sam
Copy<br>Если бы первый элемент в массиве имел бы длину больше или меньше 3 символов, то в этом случае метод TakeWhile возвратил бы нам 0 элементов.<br><br>Совмещая оба метода - Take и Skip, мы можем выбрать определенное количество элементов начиная с определенного элемента. Например, выберем два элемента, начиная со четвертого (то есть пропустим 3 первых элемента):<br>string[] people = { "Tom", "Sam", "Mike", "Kate", "Bob", "Alice" };// пропускаем 3 элемента и выбираем 2 элементаvar result = people.Skip(3).Take(2);    // "Kate", "Bob"foreach (var person in result)    Console.WriteLine(person);
Copy]]></description><link>04.-literature-notes/linq-by-metanit/методы-skip-и-take.html</link><guid isPermaLink="false">04. Literature Notes/LINQ by Metanit/Методы Skip и Take.md</guid><pubDate>Wed, 08 May 2024 21:42:31 GMT</pubDate></item><item><title><![CDATA[Объединение, пересечение и разность коллекций]]></title><description><![CDATA[ 
 <br>LINQ предоставляет несколько методов для работы с коллекциями как с множествами, а именно находить их разность, объединение и пересечение.<br><br>С помощью метода&nbsp;Except()&nbsp;можно получить разность двух последовательностей:<br>string[] soft = { "Microsoft", "Google", "Apple"};string[] hard = { "Apple", "IBM", "Samsung"};// разность последовательностейvar result = soft.Except(hard);foreach (string s in result)    Console.WriteLine(s);
Copy<br>В данном случае из массива&nbsp;soft&nbsp;убираются все элементы, которые есть в массиве&nbsp;hard. Результатом операции будут два элемента:<br>Microsoft
Google
Copy<br><br>Для получения пересечения последовательностей, то есть общих для обоих наборов элементов, применяется метод&nbsp;Intersect:<br>string[] soft = { "Microsoft", "Google", "Apple"};string[] hard = { "Apple", "IBM", "Samsung"};// пересечение последовательностейvar result = soft.Intersect(hard);foreach (string s in result)    Console.WriteLine(s);
Copy<br>Так как оба набора имеют только один общий элемент, то соответственно только он и попадет в результирующую выборку:<br>Apple
Copy<br><br>Для удаления дублей в наборе используется метод&nbsp;Distinct:<br>string[] soft = { "Microsoft", "Google", "Apple", "Microsoft", "Google" };// удаление дублейvar result = soft.Distinct();foreach (string s in result)    Console.WriteLine(s);
Copy<br>Microsoft
Google
Apple
Copy<br><br>Для объединения двух последовательностей используется метод&nbsp;Union. Его результатом является новый набор, в котором имеются элементы, как из первой, так и из второй последовательности. Повторяющиеся элементы добавляются в результат только один раз:<br>string[] soft = { "Microsoft", "Google", "Apple"};string[] hard = { "Apple", "IBM", "Samsung"};// объединение последовательностейvar result = soft.Union(hard);foreach (string s in result)    Console.WriteLine(s);
Copy<br>Результатом операции будет следующий набор:<br>Microsoft
Google
Apple
IBM
Samsung
Copy<br>Если же нам нужно простое объединение двух наборов, то мы можем использовать метод&nbsp;Concat:<br>var result = soft.Concat(hard);
Copy<br>В этом случае те элементы, которые встречаются в обоих наборах, дублируются в резутирующей последовательности.<br>Последовательное применение методов Concat и Distinct будет подобно действию метода Union.<br><br>Для сравнения объектов в последовательностях применяются реализации методов GetHashCode() и Equals(). Поэтому если мы хотим работать с последовательностями, которые содержат объекты своих классов и структур, то нам необходимо определить для них подобные методы:<br>Person[] students = { new Person("Tom"), new Person("Bob"), new Person("Sam") };Person[] employees = { new Person("Tom"), new Person("Bob"), new Person("Mike") };// объединение последовательностейvar people = students.Union(employees);foreach (Person person in people)    Console.WriteLine(person.Name);class Person{    public string Name { get;}    public Person(string name) =&gt; Name = name;    public override bool Equals(object? obj)    {        if (obj is Person person) return Name == person.Name;        return false;    }    public override int GetHashCode() =&gt; Name.GetHashCode();}
Copy<br>Здесь объекты Person сравниваются исходя из значения их свойства Name - если имена равны, то и объекты Person равны. Консольный вывод:<br>Tom
Bob
Sam
Mike
Copy<br><br><br><br>Пара слов о перечисленных в статье методах. Для определения эквивалентности они используют методы GetHeshCode() &amp; Equals(). Если вам нужно работать с коллекцией объектов вашего класса, то эти методы, возможно, придется в нём переопределить.<br>class Program    {        static void Main()        {            List&lt; User&gt; users = new List&lt; User&gt;()                {                    new User { Name = "Tom", Age = 33 },                    new User { Name = "Tom", Age = 33 },                    new User { Name = "Bob", Age = 30 },                    new User { Name = "Tom", Age = 21 },                    new User { Name = "Sam", Age = 43 },                    new User { Name = "Jack", Age = 0 },                    new User { Name = "Maks", Age = 21 },                    new User { Name = "Nikita", Age = 103 },                    new User { Name = "Mike", Age = 3 }                };            foreach (User user in users)                Console.WriteLine($"{user.Name} - {user.Age}");            var distinctedUsers = users.Distinct();            Console.WriteLine("===================");            foreach (User user in distinctedUsers)                Console.WriteLine($"{user.Name} - {user.Age}");        }    }    class User    {        public string Name { get; set; }        public int Age { get; set; }        public override bool Equals(object obj)        {            return obj is User user &amp;&amp;                   Name == user.Name &amp;&amp;                   Age == user.Age;        }        public override int GetHashCode()        {            return HashCode.Combine(Name, Age);        }    }
Copy<br><br>Касательно последнего примера про выборку сложных объектов.<br>Метод Equals по умолчанию работает с object типом, из-за чего каждый раз будет происходить боксинг-анбоксинг при проверка каждого из элементов списка, что не самым лучшим образом влияет на производительность.<br>Нужно реализовать интерфейс IEquatable&lt;t&gt;, чтобы решить эту проблему (это вариант Eqauls с универсальным типом)<br>Person[] students = { new Person("Tom"), new Person("Bob"), new Person("Sam") };Person[] employees = { new Person("Tom"), new Person("Bob"), new Person("Mike") };// объединение последовательностейvar people = students.Union(employees);foreach (Person person in people)    Console.WriteLine(person.Name);class Person : IEquatable&lt;person&gt;{    public string Name { get; }    public Person(string name) =&gt; Name = name;    public bool Equals(Person? obj)    {        if (obj is null) return false;        return obj.Name == Name;    }    public override int GetHashCode() =&gt; Name.GetHashCode();}
Copy<br>В этом случае боксинг и анбоксинг происходить не будет. Вот более подробно про это -&nbsp;<a data-tooltip-position="top" aria-label="https://learn.microsoft.com/ru-ru/dotnet/api/system.linq.enumerable.union?view=net-7.0" rel="noopener" class="external-link" href="https://learn.microsoft.com/ru-ru/dotnet/api/system.linq.enumerable.union?view=net-7.0" target="_blank">https://learn.microsoft.com…</a>]]></description><link>04.-literature-notes/linq-by-metanit/объединение,-пересечение-и-разность-коллекций.html</link><guid isPermaLink="false">04. Literature Notes/LINQ by Metanit/Объединение, пересечение и разность коллекций.md</guid><pubDate>Wed, 08 May 2024 21:42:08 GMT</pubDate></item><item><title><![CDATA[Основы LINQ]]></title><description><![CDATA[ 
 <br>LINQ&nbsp;(Language-Integrated Query) представляет простой и удобный язык запросов к источнику данных. В качестве источника данных может выступать объект, реализующий интерфейс IEnumerable (например, стандартные коллекции, массивы), набор данных DataSet, документ XML. Но вне зависимости от типа источника LINQ позволяет применить ко всем один и тот же подход для выборки данных.<br>Существует несколько разновидностей LINQ:<br>
<br>LINQ to Objects: применяется для работы с массивами и коллекциями
<br>LINQ to Entities: используется при обращении к базам данных через технологию Entity Framework
<br>LINQ to XML: применяется при работе с файлами XML
<br>LINQ to DataSet: применяется при работе с объектом DataSet
<br>Parallel LINQ (PLINQ): используется для выполнения параллельных запросов
<br>В этой главе речь пойдет прежде всего о&nbsp;LINQ to Objects, но в последующих материалах также будут затронуты и другие разновидности LINQ. Основная часть функциональности LINQ сосредоточена в пространстве имен&nbsp;System.LINQ. В проектах под .NET 6 данное пространство имен подключается по умолчанию.<br>В чем же удобство LINQ? Посмотрим на простейшем примере. Выберем из массива строки, которые начинаются на определенную букву, например, букву “T”, и отсортируем полученный список:<br>string[] people = { "Tom", "Bob", "Sam", "Tim", "Tomas", "Bill" };

// Creăm un nou List pentru rezultate
var selectedPeople = new List&lt;string&gt;();

// Parcurgem array-ul
foreach (string person in people)
{
    // Dacă string-ul începe cu litera 'T', îl adăugăm în List
    if (person.ToUpper().StartsWith("T"))
        selectedPeople.Add(person);
}

// Sortăm List-ul
selectedPeople.Sort();

foreach (string person in selectedPeople)
    Console.WriteLine(person);
Copy<br>Для отфильтрованных строк создается специальный список. Затем в цикле проходим по всем элементам массива и, если они соответствуют условию (начинаются на букву T), то добавляем их в этот список. Затем сортируем список по возрастанию. И в конце элементы полученного списка выводим на консоль:<br>Tim
Tom
Tomas
Copy<br>Хотя подобный подход вполне работает, однако LINQ позволяет значительно сократить код с помощью интуитивно понятного и краткого синтаксиса.<br>Для работы с колекциями можно использовать два способа:<br>
<br>Операторы запросов LINQ
<br>Методы расширений LINQ
<br>Рассмотрим оба способа<br><br>Операторы запросов LINQ в каком-то роде частично напоминают синтаксис запросов SQL, поэтому если вы работали когда-нибудь с sql-запросами, то будет проще понять общую концепцию. Итак, изменим предыдущий пример, применив операторы запросов LINQ:<br>string[] people = { "Tom", "Bob", "Sam", "Tim", "Tomas", "Bill" };

// Создаем новый список для результатов
var selectedPeople = from p in people  // Передаем каждый элемент из people в переменную p
                    where p.ToUpper().StartsWith("T") // Фильтрация по критерию
                    orderby p  // Упорядочиваем по возрастанию
                    select p; // Выбираем объекты в создаваемую коллекцию

foreach (string person in selectedPeople)
    Console.WriteLine(person);
Copy<br>Прежде всего, как мы видим, код стал меньше и проще, а результат будет тем же. В принципе все выражение можно было бы записать в одну строку:<br>var selectedPeople = from p in people where p.ToUpper().StartsWith("T") orderby p  select p;
Copy<br>Но для более понятной логической разбивки я поместил каждое отдельное подвыражение на отдельной строке.<br>Простейшее определение запроса LINQ выглядит следующим образом:<br>from переменная in набор_объектов select переменная;
Copy<br>Итак, что делает этот запрос LINQ? Выражение&nbsp;from p in people&nbsp;проходит по всем элементам массива people и определяет каждый элемент как&nbsp;p. Используя переменную&nbsp;p&nbsp;мы можем проводить над ней разные операции.<br>Несмотря на то, что мы не указываем тип переменной&nbsp;p, выражения LINQ являются строго типизированными. То есть среда автоматически распознает, что набор people состоит из объектов string, поэтому переменная&nbsp;p&nbsp;будет рассматриваться в качестве строки.<br>Далее с помощью оператора&nbsp;where&nbsp;проводится фильтрация объектов, и если объект соответствует критерию (в данном случае начальная буква должна быть “T”), то этот объект передается дальше.<br>Оператор&nbsp;orderby&nbsp;упорядочивает по возрастанию, то есть сортирует выбранные объекты.<br>Оператор&nbsp;select&nbsp;передает выбранные значения в результирующую выборку, которая возвращается LINQ-выражением.<br>В данном случае результатом выражения LINQ является объект&nbsp;IEnumerable&lt;T&gt;. Нередко результирующая выборка определяется с помощью ключевого слова&nbsp;var, тогда компилятор на этапе компиляции сам выводит тип.<br><br>Кроме стандартного синтаксиса&nbsp;from .. in .. select&nbsp;для создания запроса LINQ мы можем применять специальные методы расширения, которые определены для интерфейса&nbsp;IEnumerable. Как правило, эти методы реализуют ту же функциональность, что и операторы LINQ типа&nbsp;where&nbsp;или&nbsp;orderby.<br>Например:<br>string[] people = { "Tom", "Bob", "Sam", "Tim", "Tomas", "Bill" };
var selectedPeople = people.Where(p =&gt; p.ToUpper().StartsWith("T")).OrderBy(p =&gt; p);

foreach (string person in selectedPeople)
    Console.WriteLine(person);
Copy<br>Запрос&nbsp;people.Where(p=&gt;p.ToUpper().StartsWith("T")).OrderBy(p =&gt; p)&nbsp;будет аналогичен предыдущему. Он состоит из цепочки методов Where и OrderBy. В качестве аргумента эти методы принимают делегат или лямбда-выражение.<br>И хотя ряд действий мы можем реализовать как с помощью операторов запросов LINQ, так и с помощью методов расширений LINQ, но не каждый метод расширения имеет аналог среди операторов LINQ. И в этом случае можно сочетать оба подхода. Например, используем стандартный синтаксис linq и метод расширения Count(), который возвращает количество элементов в выборке:<br>int number = (from p in people where p.ToUpper().StartsWith("T") select p).Count();
Console.WriteLine(number); // 3
Copy<br><br>
<br>Select: определяет проекцию выбранных значений
<br>Where: определяет фильтр выборки
<br>OrderBy: упорядочивает элементы по возрастанию
<br>OrderByDescending: упорядочивает элементы по убыванию
<br>ThenBy: задает дополнительные критерии для упорядочивания элементов возрастанию
<br>ThenByDescending: задает дополнительные критерии для упорядочивания элементов по убыванию
<br>Join: соединяет две коллекции по определенному признаку
<br>Aggregate: применяет к элементам последовательности агрегатную функцию, которая сводит их к одному объекту
<br>GroupBy: группирует элементы по ключу
<br>ToLookup: группирует элементы по ключу, при этом все элементы добавляются в словарь
<br>GroupJoin: выполняет одновременно <a data-href="Соединение коллекций" href="04.-literature-notes/linq-by-metanit/соединение-коллекций.html" class="internal-link" target="_self" rel="noopener">Соединение коллекций</a> и группировку элементов по ключу
<br>Reverse: располагает элементы в обратном порядке
<br>All: определяет, все ли элементы коллекции удовлятворяют определенному условию
<br>Any: определяет, удовлетворяет хотя бы один элемент коллекции определенному условию
<br>Contains: определяет, содержит ли коллекция определенный элемент
<br>Distinct: удаляет дублирующиеся элементы из коллекции
<br>Except: возвращает разность двух коллекцию, то есть те элементы, которые создаются только в одной коллекции
<br>Union: объединяет две однородные коллекции
<br>Intersect: возвращает пересечение двух коллекций, то есть те элементы, которые встречаются в обоих коллекциях
<br>Count: подсчитывает количество элементов коллекции, которые удовлетворяют определенному условию
<br>Sum: подсчитывает сумму числовых значений в коллекции
<br>Average: подсчитывает cреднее значение числовых значений в коллекции
<br>Min: находит минимальное значение
<br>Max: находит максимальное значение
<br>Take: выбирает определенное количество элементов
<br>Skip: пропускает определенное количество элементов
<br>TakeWhile: возвращает цепочку элементов последовательности, до тех пор, пока условие истинно
<br>SkipWhile: пропускает элементы в последовательности, пока они удовлетворяют заданному условию, и затем возвращает оставшиеся элементы
<br>Concat: объединяет две коллекции
<br>Zip: объединяет две коллекции в соответствии с определенным условием
<br>First: выбирает первый элемент коллекции
<br>FirstOrDefault: выбирает первый элемент коллекции или возвращает значение по умолчанию
<br>Single: выбирает единственный элемент коллекции, если коллекция содержит больше или меньше одного элемента, то генерируется исключение
<br>SingleOrDefault: выбирает единственный элемент коллекции. Если коллекция пуста, возвращает значение по умолчанию. Если в коллекции больше одного элемента, генерирует исключение
<br>ElementAt: выбирает элемент последовательности по определенному индексу
<br>ElementAtOrDefault: выбирает элемент коллекции по определенному индексу или возвращает значение по умолчанию, если индекс вне допустимого диапазона
<br>Last: выбирает последний элемент коллекции
<br>LastOrDefault: выбирает последний элемент коллекции или возвращает значение по умолчанию
]]></description><link>04.-literature-notes/linq-by-metanit/основы-linq.html</link><guid isPermaLink="false">04. Literature Notes/LINQ by Metanit/Основы LINQ.md</guid><pubDate>Wed, 08 May 2024 21:42:03 GMT</pubDate></item><item><title><![CDATA[Отложенное и немедленное выполнение LINQ]]></title><description><![CDATA[ 
 <br>Есть два способа выполнения запроса LINQ:&nbsp;отложенное&nbsp;(deferred) и&nbsp;немедленное&nbsp;(immediate) выполнение.<br>При отложенном выполнении LINQ-выражение не выполняется, пока не будет произведена итерация или перебор по выборке, например, в цикле foreach. Обычно подобные операции возвращают объект&nbsp;IEnumerable&lt;T&gt;&nbsp;или&nbsp;IOrderedEnumerable&lt;T&gt;. Полный список отложенных операций LINQ:<br>
<br>AsEnumerable
<br>Cast
<br>Concat
<br>DefaultIfEmpty
<br>Distinct
<br>Except
<br>GroupBy
<br>GroupJoin
<br>Intersect
<br>Join
<br>OfType
<br>OrderBy
<br>OrderByDescending
<br>Range
<br>Repeat
<br>Reverse
<br>Select
<br>SelectMany
<br>Skip
<br>SkipWhile
<br>Take
<br>TakeWhile
<br>ThenBy
<br>ThenByDescending
<br>Union
<br>Where
<br>Рассмотрим отложенное выполнение:<br>string[] people = { "Tom", "Sam", "Bob" };var selectedPeople = people.Where(s=&gt;s.Length == 3).OrderBy(s=&gt;s);// выполнение LINQ-запросаforeach (string s in selectedPeople)    Console.WriteLine(s);
Copy<br>То есть фактическое выполнение запроса происходит не в строке определения:&nbsp;var selectedPeople = people.Where..., а при переборе в цикле foreach.<br>Фактически LINQ-запрос разбивается на три этапа:<br>
<br>Получение источника данных
<br>Создание запроса
<br>Выполнение запроса и получение его результатов
<br>Как это происходит в нашем случае:<br>
<br>Получение источника данных - определение массива teams:
<br>string[] people = { "Tom", "Sam", "Bob" };
Copy<br>
<br>Создание запроса - определение переменной selectedTeams:
<br>var selectedPeople = people.Where(s=&gt;s.Length == 3).OrderBy(s=&gt;s);
Copy<br>
<br>Выполнение запроса и получение его результатов:
<br>foreach (string s in selectedPeople)    Console.WriteLine(s);
Copy<br>После определения запроса он может выполняться множество раз. И до выполнения запроса источник данных может изменяться. Чтобы более наглядно увидеть это, мы можем изменить какой-либо элемент до перебора выборки:<br>string[] people = { "Tom", "Sam", "Bob" };var selectedPeople = people.Where(s=&gt;s.Length == 3).OrderBy(s=&gt;s);people[2] = "Mike";// выполнение LINQ-запросаforeach (string s in selectedPeople)    Console.WriteLine(s);
Copy<br>Теперь выборка будет содержать два элемента, а не три, так как последний элемент после изменения не будет соответствовать условию.<br>Важно понимать, что переменная запроса сама по себе не выполняет никаких действий и не возвращает никаких данных. Она только хранит набор команд, которые необходимы для получения результатов. То есть выполнение запроса после его создания откладывается. Само получение результатов производится при переборе в цикле foreach.<br><br>С помощью ряда методов мы можем применить немедленное выполнение запроса. Это методы, которые возвращают одно атомарное значение или один элемент или данные типов Array, List и Dictionary. Полный список подобных операций в LINQ:<br>
<br>Aggregate
<br>All
<br>Any
<br>Average
<br>Contains
<br>Count
<br>ElementAt
<br>ElementAtOrDefault
<br>Empty
<br>First
<br>FirstOrDefault
<br>Last
<br>LastOrDefault
<br>LongCount
<br>Max
<br>Min
<br>SequenceEqual
<br>Single
<br>SingleOrDefault
<br>Sum
<br>ToArray
<br>ToDictionary
<br>ToList
<br>ToLookup
<br>Рассмотрим пример с методом&nbsp;Count(), который возвращает число элементов последовательности:<br>string[] people = { "Tom", "Sam", "Bob" };// определение и выполнение LINQ-запросаvar count = people.Where(s=&gt;s.Length == 3).OrderBy(s=&gt;s).Count();Console.WriteLine(count);   // 3 - до изменения коллекцииpeople[2] = "Mike";Console.WriteLine(count);   // 3 - после изменения коллекции
Copy<br>Результатом метода Count будет объект&nbsp;int, поэтому сработает немедленное выполнение.<br>Сначала создается запрос:&nbsp;people.Where(s=&gt;s.Length == 3).OrderBy(s=&gt;s). Далее к нему применяется метод&nbsp;Count(), который выполняет запрос, неявно выполняет перебор по последовательности элементов, генерируемой этим запросом, и возвращает число элементов в этой последовательности.<br>Также мы можем изменить код таким образом, чтобы метод&nbsp;Count()&nbsp;учитывал изменения и выполнялся отдельно от определения запроса:<br>string[] people = { "Tom", "Sam", "Bob" };
// определение LINQ-запроса
var selectedPeople = people.Where(s=&gt;s.Length == 3).OrderBy(s=&gt;s);
// выполнение запроса
Console.WriteLine(selectedPeople.Count());   
// 3 - до изменения коллекции
people[2] = "Mike";
// выполнение запроса
Console.WriteLine(selectedPeople.Count());   
// 2 - после изменения коллекции
Copy<br>Также для немедленного выполнения LINQ-запроса и кэширования его результатов мы можем применять методы преобразования&nbsp;ToArray&lt;T&gt;(),&nbsp;ToList&lt;T&gt;(),&nbsp;ToDictionary()&nbsp;и т.д.. Эти методы получают результат запроса в виде объектов Array, List и Dictionary соответственно. Например:<br>string[] people = { "Tom", "Sam", "Bob" };
// определение и выполнение LINQ-запроса
var selectedPeople = people
	.Where(s=&gt;s.Length == 3).OrderBy(s=&gt;s)
	.ToList(); // изменение массива никак не затронет список selectedPeoplepeople[2] = "Mike";
	// выполнение запроса
foreach (string s in selectedPeople)    
	Console.WriteLine(s);
Copy]]></description><link>04.-literature-notes/linq-by-metanit/отложенное-и-немедленное-выполнение-linq.html</link><guid isPermaLink="false">04. Literature Notes/LINQ by Metanit/Отложенное и немедленное выполнение LINQ.md</guid><pubDate>Wed, 08 May 2024 21:41:55 GMT</pubDate></item><item><title><![CDATA[Проверка наличия и получение элементов]]></title><description><![CDATA[ 
 <br>Ряд методов в LINQ позволяют проверить наличие элементов в коллекции и получить их.<br><br>Метод&nbsp;All()&nbsp;проверяет, соответствуют ли все элементы условию. Если все элементы соответствуют условию, то возвращается true. Например:<br>string[] people = { "Tom", "Tim", "Bob", "Sam" };// проверяем, все ли элементы имеют длину в 3 символаbool allHas3Chars = people.All(s =&gt; s.Length == 3);     // trueConsole.WriteLine(allHas3Chars);// проверяем, все ли строки начинаются на Tbool allStartsWithT = people.All(s =&gt; s.StartsWith("T"));   // falseConsole.WriteLine(allStartsWithT);
Copy<br>В первом случае проверяем, все ли строки в массиве people имеют длину в три символа. Поскольку это условие верно, то метод All возвращает true. Во втором случае смотрим, все ли строки начинаются с буквы “T”. это условие ложно, поэтому метод All возвращает false.<br><br>Метод&nbsp;Any()&nbsp;действует подобным образом, только возвращает true, если хотя бы один элемент коллекции определенному условию:<br>string[] people = { "Tom", "Tim", "Bob", "Sam" };// проверяем, все ли элементы имеют длину больше 3 символовbool allHasMore3Chars = people.Any(s =&gt; s.Length &gt; 3);     // falseConsole.WriteLine(allHasMore3Chars);// проверяем, все ли строки начинаются на Tbool allStartsWithT = people.Any(s =&gt; s.StartsWith("T"));   // trueConsole.WriteLine(allStartsWithT);
Copy<br>Первое выражение вернет&nbsp;false, поскольку все строки имеют длину в 3 символа. Второе выражение возвратит&nbsp;true, так как у нас есть в коллекции есть строки, которые начинаются на букву T.<br><br>Метод&nbsp;Contains()&nbsp;возвращает&nbsp;true, если коллекция содержит определенный элемент.<br>string[] people = { "Tom", "Tim", "Bob", "Sam" };// проверяем, есть ли строка Tombool hasTom = people.Contains("Tom");     // trueConsole.WriteLine(hasTom);// проверяем, есть ли строка Mikebool hasMike = people.Contains("Mike");     // falseConsole.WriteLine(hasMike);
Copy<br>Стоит отметить, что для сравнения объектов применяется реализация метода Equals. Соответственно если мы работаем с объектами своих типов, то мы можем реализовать данный метод:<br>Person[] people = { new Person("Tom"), new Person("Sam"), new Person("Bob")};var tom = new Person("Tom");var mike = new Person("Mike");// проверяем, есть ли Tombool hasTom = people.Contains(tom);     // trueConsole.WriteLine(hasTom);// проверяем, есть ли строка Mikebool hasMike = people.Contains(mike);     // falseConsole.WriteLine(hasMike);class Person{    public string Name { get;}    public Person(string name) =&gt; Name = name;    public override bool Equals(object? obj)    {        if (obj is Person person) return Name == person.Name;        return false;    }    public override int GetHashCode() =&gt; Name.GetHashCode();}
Copy<br>Но стоит отметить, что Contains не всегда может вернуть ожидаемые данные. Например:<br>string[] people = { "tom", "Tim", "bOb", "Sam" };// проверяем, есть ли строка Tombool hasTom = people.Contains("Tom");     // falseConsole.WriteLine(hasTom);// проверяем, есть ли строка Bobbool hasMike = people.Contains("Bob");     // falseConsole.WriteLine(hasMike);
Copy<br>В данном случае в массиве нет строки “Tom”, а есть строка “tom”. Поэтому вызов&nbsp;people.Contains("Tom")&nbsp;возвратит false. Но подобное поведение не всегда может быть желательным. И в этом случае мы можем задать логику сравнения с помощью реализации интерфейса IComparer и затем передать ее в качестве второго параметра в метод Contains:<br>using System.Diagnostics.CodeAnalysis;string[] people = { "tom", "Tim", "bOb", "Sam" };// проверяем, есть ли строка Tombool hasTom = people.Contains("Tom", new CustomStringComparer());     // trueConsole.WriteLine(hasTom);// проверяем, есть ли строка Bobbool hasMike = people.Contains("Bob", new CustomStringComparer());     // trueConsole.WriteLine(hasMike);class CustomStringComparer : IEqualityComparer&lt;string&gt;{    public bool Equals(string? x, string? y)    {        if (x is null || y is null) return false;        return x.ToLower() == y.ToLower();    }    public int GetHashCode(string obj) =&gt; obj.ToLower().GetHashCode();}
Copy<br>Интерфейс IEqualityComparer типизируется типом сравниваемых данных (в данном случае типом String). Для реализации этого интерфейса необходимо определить методы Equals и GetHashCode. В методе Equals сравниваем строки в нижнем регистре, а в методе GetHashCode возвращаем возвращаем хеш-код строки в нижнем регистре.<br><br>Метод&nbsp;First()&nbsp;возвращает первый элемент последовательности:<br>string[] people = { "Tom", "Bob", "Tim", "Sam" };// проверяем, есть ли строка Tomvar first = people.First();  // TomConsole.WriteLine(first);
Copy<br>Также в метод First можно передать метод, который представляет условие. В этом случае метод возвращает первый элемент, который соответствует условию:<br>string[] people = { "Tom", "Bob", "Kate", "Tim", "Mike", "Sam" };// первая строка, длина которой равна 4 символамvar firstWith4Chars = people.First(s=&gt; s.Length == 4);  // KateConsole.WriteLine(firstWith4Chars);
Copy<br>Здесь выбираем первый элемент, длина которого - 4 символа.<br>Стоит учитывать, что если коллекция пуста или в коллекции нет элементов, который соответствуют условию, то будет сгенерировано исключение.<br>string[] people = { "Tom", "Bob", "Kate", "Tim", "Mike", "Sam" };// первая строка, длина которой равна 5 символамvar firstWith5Chars = people.First(s =&gt; s.Length == 5);  // ! исключениеConsole.WriteLine(firstWith5Chars);var first = new string[] {}.First();  // ! исключениеConsole.WriteLine(first);
Copy<br><br>Метод&nbsp;FirstOrDefault()&nbsp;также возвращает первый элемент и также может принимать условие, только если коллекция пуста или в коллекции не окажется элементов, которые соответствуют условию, то метод возвращает значение по умолчанию:<br>string[] people = { "Tom", "Bob", "Kate", "Tim", "Mike", "Sam" };// первый элементvar first = people.FirstOrDefault();  // TomConsole.WriteLine(first);// первая строка, длина которой равна 4 символамvar firstWith4Chars = people.FirstOrDefault(s =&gt; s.Length == 4);  // KateConsole.WriteLine(firstWith4Chars);// первый элемент из пустой коллекцииvar firstOrDefault = new string[] {}.FirstOrDefault();Console.WriteLine(firstOrDefault);  // null
Copy<br>Стоит учитывать, что для коллекций ссылочных типов FirstOrDefault возвращает значение типа T? (в примере выше - string?), то есть значение, которое может быть равно null, а значение по умолчанию - null. Для коллекций числовых типов возвращается непосредственно значение типа T, а значение по умолчанию - 0.<br>Но мы можем настроить значение по умолчанию, передав его в качестве одного из аргументов:<br>string[] people = { "Tom", "Bob", "Kate", "Tim", "Mike", "Sam" };string? firstWith5Chars = people.FirstOrDefault(s =&gt; s.Length == 5, "Undefined");Console.WriteLine(firstWith5Chars); // Undefined// первый элемент из пустой коллекции строкstring? firstOrDefault = new string[] {}.FirstOrDefault("hello"); // hello - значение по умолчаниюConsole.WriteLine(firstOrDefault);  // hello// первый элемент из пустой коллекции intint firstNumber = new int[] {}.FirstOrDefault(100); // 100 - значение по умолчаниюConsole.WriteLine(firstNumber); // 100
Copy<br><br>Метод&nbsp;Last()&nbsp;аналогичен по работе методу First, только возвращает последний элемент. Если коллекция не содержит элемент, который соответствуют условию, или вообще пуста, то метод генерирует исключение.<br>string[] people = { "Tom", "Bob", "Kate", "Tim", "Mike", "Sam" };string last = people.Last();Console.WriteLine(last); // Samstring lastWith4Chars = people.Last(s =&gt; s.Length == 4);Console.WriteLine(lastWith4Chars); // Mike
Copy<br>Метод&nbsp;LastOrDefault()&nbsp;возвращает последний элемент или значение по умолчанию, если коллекция не содержит элемент, который соответствуют условию, или вообще пуста:<br>string[] people = { "Tom", "Bob", "Kate", "Tim", "Mike", "Sam" };string? last = people.LastOrDefault();Console.WriteLine(last); // Samstring? lastWith4Chars = people.LastOrDefault(s =&gt; s.Length == 4);Console.WriteLine(lastWith4Chars); // Mikestring? lastWith5Chars = people.LastOrDefault(s =&gt; s.Length == 5);Console.WriteLine(lastWith5Chars); // nullstring? lastWith5CharsOrDefault = people.LastOrDefault(s =&gt; s.Length == 5, "Undefined");Console.WriteLine(lastWith5CharsOrDefault); // Undefined// первый элемент из пустой коллекции строкstring? lastOrDefault = new string[] {}.LastOrDefault("hello");Console.WriteLine(lastOrDefault);  // hello
Copy]]></description><link>04.-literature-notes/linq-by-metanit/проверка-наличия-и-получение-элементов.html</link><guid isPermaLink="false">04. Literature Notes/LINQ by Metanit/Проверка наличия и получение элементов.md</guid><pubDate>Wed, 08 May 2024 21:41:50 GMT</pubDate></item><item><title><![CDATA[Проекция данных]]></title><description><![CDATA[ 
 <br>Проекция позволяет преобразовать объект одного типа в объект другого типа. Для проекции используется оператор&nbsp;select. Допустим, у нас есть набор объектов следующего класса, представляющего пользователя:<br>record class Person(string Name, int Age);
Copy<br>Но, допустим, нам нужен не весь объект, а только его свойство Name:<br>var people = new List&lt;Person&gt; {
    new Person ("Tom", 23),
    new Person ("Bob", 27),
    new Person ("Sam", 29),
    new Person ("Alice", 24)
};

var names = from p in people select p.Name;

foreach (string n in names)
    Console.WriteLine(n);
Copy<br>Результат выражения LINQ будет представлять набор строк, поскольку выражение&nbsp;select p.Name&nbsp;выбирает в результирующую выборку только значения свойства Name.<br>Tom
Bob
Sam
Alice
Copy<br>В качестве альтернативы мы могли бы использовать метод расширения&nbsp;Select():<br>Select(Func&lt;TSource,TResult&gt; selector)
Copy<br>Этот метод принимает функцию преобразования в виде делегата Func&lt;TSource,TResult&gt;. Функция преобразования получает каждый объект выборки типа TSource и с его помощью создает объект TResult. Метод Select возвращает коллекцию преобразованных объектов.<br>Перепишем предыдущий пример с применением метода Select:<br>var people = new List&lt;Person&gt;{
	new Person ("Tom", 23),    
	new Person ("Bob", 27),    
	new Person ("Sam", 29),    
	new Person ("Alice", 24)};
var names = people.Select(u =&gt; u.Name);
foreach (string n in names)
	Console.WriteLine(n);
Copy<br>Аналогично можно создать объекты другого типа, в том числе анонимного:<br>var people = new List&lt;Person&gt;{    new Person ("Tom", 23),    new Person ("Bob", 27)};var personel = from p in people            select new            {                FirstName = p.Name,                Year = DateTime.Now.Year - p.Age            };foreach (var p in personel)    Console.WriteLine($"{p.FirstName} - {p.Year}");record class Person(string Name, int Age);
Copy<br>Здесь оператор&nbsp;select&nbsp;создает объект анонимного типа, используя текущий объект Person. И теперь результат будет содержать набор объектов данного анонимного типа, в котором определены два свойства: FirstName и Year (год рождения). Консольный вывод программы:<br>Tom - 1999
Bob - 1995
Copy<br>В качестве альтернативы мы могли бы использовать метод расширения&nbsp;Select():<br>// проекция на объекты анонимного типаvar personel = people.Select(p =&gt; new{    FirstName = p.Name,    Year = DateTime.Now.Year - p.Age});
Copy<br><br>Иногда возникает необходимость произвести в запросах LINQ какие-то дополнительные промежуточные вычисления. Для этих целей мы можем задать в запросах свои переменные с помощью оператора&nbsp;let:<br>var people = new List&lt;Person&gt;{    new Person ("Tom", 23),    new Person ("Bob", 27)};var personnel = from p in people               let name = $"Mr. {p.Name}"               let year = DateTime.Now.Year - p.Age               select new            {                Name = name,                Year = year            };foreach (var p in personnel)    Console.WriteLine($"{p.Name} - {p.Year}");record class Person(string Name, int Age);
Copy<br>В данном случае создаются две переменных. Переменная&nbsp;name, значение которой равно&nbsp;$"Mr. {p.Name}".<br>Возможность определения переменных наверное одно из главных преимуществ операторов LINQ по сравнению с методами расширения.<br><br>В LINQ можно выбирать объекты не только из одного, но и из большего количества источников. Например, возьмем классы:<br>record class Course(string Title);  // учебный курсrecord class Student(string Name);  // студент
Copy<br>Класс Course представляет учебный курс и хранит его название. Класс Student представляет студента и хранит его имя.<br>Допустим, нам надо из списка курсов и списка студентов получить набор пар студент-курс (условно говоря сущность, которая представляет учебу студента на данном курсе):<br>var courses = new List&lt;Course&gt; { new Course("C#"), new Course("Java") };var students = new List&lt;Student&gt; { new Student("Tom"), new Student("Bob") };var enrollments = from course in courses    //  выбираем по одному курсу             from student in students       //  выбираем по одному студенту             select new { Student = student.Name, Course = course.Title};   // соединяем каждого студента с каждым курсомforeach (var enrollment in enrollments)    Console.WriteLine($"{enrollment.Student} - {enrollment.Course}");record class Course(string Title);  // учебный курсrecord class Student(string Name);  // студент
Copy<br>Консольный вывод:<br>Tom - C#
Bob - C#
Tom - Java
Bob - Java
Copy<br>Таким образом, при выборке из двух источников каждый элемент из первого источника будет сопоставляться с каждым элементом из второго источника. То есть получиться 4 пары.<br><br>Метод&nbsp;SelectMany&nbsp;позволяет свести набор коллекций в одну коллекцию. Он имеет ряд перегруженных версий. Возьмем одну из них:<br>SelectMany(Func&lt;TSource, IEnumerable&lt;TResult&gt;&gt; selector);SelectMany(Func&lt;TSource, IEnumerable&lt;TCollection&gt;&gt; collectionSelector,           Func&lt;TSource,TCollection,TResult&gt; resultSelector);
Copy<br>Первая версия метода принимает функцию преобразования в виде делегата&nbsp;Func&lt;TSource,IEnumerable&lt;TResult&gt;&gt;. Функция преобразования получает каждый объект выборки типа TSource и с его помощью создает набор объектов TResult. Метод SelectMany возвращает коллекцию преобразованных объектов.<br>Вторая версия принимает функцию преобразования в виде делегата&nbsp;Func&lt;TSource,IEnumerable&lt;TResult&gt;&gt;. Функция преобразования получает каждый объект выборки типа TSource и возвращает некоторую промежуточную коллекцию типа TCollection. Второй параметр - то же функция функция преобразования в виде делегата&nbsp;Func&lt;TSource,TCollection,TResult&gt;, которая получает два параметра - каждый элемент текущей выборки и каждый элемент промежуточной коллекции и на их основе создает некоторый объект типа TResult.<br>Рассмотрим следующий пример:<br>var companies = new List&lt;Company&gt;{    new Company("Microsoft", new List&lt;Person&gt; {new Person("Tom"), new Person("Bob")}),    new Company("Google", new List&lt;Person&gt; {new Person("Sam"), new Person("Mike")}),};var employees = companies.SelectMany(c =&gt; c.Staff);foreach (var emp in employees)    Console.WriteLine($"{emp.Name}");record class Company(string Name, List&lt;Person&gt; Staff);record class Person(string Name);
Copy<br>Здесь нам дан список компаний, в каждой компании имеет набор сотрудников в виде списка объектов Person. И на выходе мы получаем список сотрудников всех компаний, то есть по сути коллекцию объектов Person. Консольный вывод:<br>Tom
Bob
Sam
Mike
Copy<br>Аналогичный пример с помощью операторов LINQ:<br>var companies = new List&lt;Company&gt;{    new Company("Microsoft", new List&lt;Person&gt; {new Person("Tom"), new Person("Bob")}),    new Company("Google", new List&lt;Person&gt; {new Person("Sam"), new Person("Mike")}),};var employees = from c in companies                from emp in c.Staff                select emp;foreach (var emp in employees)    Console.WriteLine($"{emp.Name}");record class Company(string Name, List&lt;Person&gt; Staff);record class Person(string Name);
Copy<br>Теперь добавим к сотрудникам их компанию:<br>var companies = new List&lt;Company&gt;{    new Company("Microsoft", new List&lt;Person&gt; {new Person("Tom"), new Person("Bob")}),    new Company("Google", new List&lt;Person&gt; {new Person("Sam"), new Person("Mike")}),};var employees = companies.SelectMany(c =&gt; c.Staff,                                    (c, emp)=&gt; new { Name = emp.Name, Company = c.Name });foreach (var emp in employees)    Console.WriteLine($"{emp.Name} - {emp.Company}");record class Company(string Name, List&lt;Person&gt; Staff);record class Person(string Name);
Copy<br>Здесь применяется другая версия метода SelectMany. Первый делегат в виде&nbsp;c =&gt; c.Staff&nbsp;создает промежуточную коллекцию - фактически просто возвращаем набор сотрудников каждой компании. Второй делегат -&nbsp;(c, emp)=&gt; new { Name = emp.Name, Company = c.Name }&nbsp;получает каждую компанию и каждый элемент промежуточной коллекции - объект Person и на их основе создает анонимный объект с двумя свойствами Name и Company. Консольный вывод программы:<br>Tom - Microsoft
Bob - Microsoft
Sam - Google
Mike - Google
Copy<br>Аналогичный пример с помощью операторов запросов:<br>var companies = new List&lt;Company&gt;{    new Company("Microsoft", new List&lt;Person&gt; {new Person("Tom"), new Person("Bob")}),    new Company("Google", new List&lt;Person&gt; {new Person("Sam"), new Person("Mike")}),};var employees = from c in companies             from emp in c.Staff             select new { Name = emp.Name, Company = c.Name };foreach (var emp in employees)    Console.WriteLine($"{emp.Name} - {emp.Company}");record class Company(string Name, List&lt;Person&gt; Staff);record class Person(string Name);
Copy]]></description><link>04.-literature-notes/linq-by-metanit/проекция-данных.html</link><guid isPermaLink="false">04. Literature Notes/LINQ by Metanit/Проекция данных.md</guid><pubDate>Wed, 08 May 2024 21:41:46 GMT</pubDate></item><item><title><![CDATA[Соединение коллекций]]></title><description><![CDATA[ 
 <br>Соединение в LINQ используется для объединения двух разнотипных наборов в один. Для соединения используется оператор join или метод Join(). Как правило, данная операция применяется к двум наборам, которые имеют один общий критерий.<br><br>Оператор join имеет следующий формальный синтаксис:<br>from объект1 in набор1join объект2 in набор2 on объект2.свойство2 equals объект1.свойство1
Copy<br>После оператора join идет выборка объектов из второй коллекции. После оператора on указывается критерий соединения - свойство объекта из второй выборки, а после оператора equals - свойство объекта из первой выборки, которому должно быть равно свойство объекта из второй выборки. Если эти свойства равны, то оба объекта попадают в финальный результат.<br>Например, у нас есть два класса:<br>record class Person(string Name, string Company);record class Company(string Title, string Language);
Copy<br>Класс Person представляет пользователя и хранит два свойства: Name (имя) и Company (компания пользователя). Класс Company представляет компанию и хранит два свойства: Title (название компании) и Language (основной язык программирования в компании)<br>Объекты обоих классов будет иметь один общий критерий - название компании. Соединим по этому критерию два набора этих классов:<br>Person[] people ={    new Person("Tom", "Microsoft"), new Person("Sam", "Google"),    new Person("Bob", "JetBrains"), new Person("Mike", "Microsoft"),};Company[] companies ={    new Company("Microsoft", "C#"),    new Company("Google", "Go"),    new Company("Oracle", "Java")};var employees = from p in people             join c in companies on p.Company equals c.Title             select new { Name = p.Name, Company = c.Title, Language = c.Language };foreach (var emp in employees)    Console.WriteLine($"{emp.Name} - {emp.Company} ({emp.Language})");record class Person(string Name, string Company);record class Company(string Title, string Language);
Copy<br>В итоге мы получим следующий вывод:<br>Tom - Microsoft (C#)
Sam - Google (Go)
Mike - Microsoft (C#)
Copy<br>Обратите внимание, что в массиве people есть объект new Person("Bob", "JetBrains"), но в массиве компаний компании с именем “JetBrains” нет, соответственно он не попал с результат. Аналогично в списке people нет объектов Person, которые бы соотствовали компании new Company("Oracle", "Java").<br><br>В качестве альтернативы можно было бы использовать метод Join():<br>Join(IEnumerable&lt;TInner&gt; inner,    Func&lt;TOuter,TKey&gt; outerKeySelector,    Func&lt;TInner,TKey&gt; innerKeySelector,    Func&lt;TOuter,TInner,TResult&gt; resultSelector);
Copy<br>Метод Join() принимает четыре параметра:<br>
<br>второй список, который соединяем с текущим
<br>делегат, который определяет свойство объекта из текущего списка, по которому идет соединение
<br>делегат, который определяет свойство объекта из второго списка, по которому идет соединение
<br>делегат, который определяет новый объект в результате соединения
<br>Перепишим предыдущий пример с использованием метода Join:<br>Person[] people ={    new Person("Tom", "Microsoft"), new Person("Sam", "Google"),    new Person("Bob", "JetBrains"), new Person("Mike", "Microsoft"),};Company[] companies ={    new Company("Microsoft", "C#"),    new Company("Google", "Go"),    new Company("Oracle", "Java")};var employees = people.Join(companies, // второй набор             p =&gt; p.Company, // свойство-селектор объекта из первого набора             c =&gt; c.Title, // свойство-селектор объекта из второго набора             (p, c) =&gt; new { Name = p.Name, Company = c.Title, Language = c.Language }); // результатforeach (var emp in employees)    Console.WriteLine($"{emp.Name} - {emp.Company} ({emp.Language})");record class Person(string Name, string Company);record class Company(string Title, string Language);
Copy<br><br>Метод GroupJoin() кроме соединения последовательностей также выполняет и группировку.<br>GroupJoin(IEnumerable&lt;TInner&gt; inner,        Func&lt;TOuter,TKey&gt; outerKeySelector,        Func&lt;TInner,TKey&gt; innerKeySelector,        Func&lt;TOuter, IEnumerable&lt;TInner&gt;,TResult&gt; resultSelector);
Copy<br>Метод GroupJoin() принимает четыре параметра:<br>
<br>второй список, который соединяем с текущим
<br>делегат, который определяет свойство объекта из текущей коллекции, по которому идет соединение и по которому будет идти группировка
<br>делегат, который определяет свойство объекта из второй коллекции, по которому идет соединение
<br>делегат, который определяет новый объект в результате соединения. Этот делегат получает группу - объект текущей коллекции, по которому шла группировка, и набор объектов из второй коллекции, которые сооставляют группу
<br>Например, возьмем выше определенные массивы people и companies и сгуппируем всех пользователей по компаниям:<br>Person[] people ={    new Person("Tom", "Microsoft"), new Person("Sam", "Google"),    new Person("Bob", "JetBrains"), new Person("Mike", "Microsoft"),};Company[] companies ={    new Company("Microsoft", "C#"),    new Company("Google", "Go"),    new Company("Oracle", "Java")};var personnel = companies.GroupJoin(people, // второй набор             c =&gt; c.Title, // свойство-селектор объекта из первого набора             p =&gt; p.Company, // свойство-селектор объекта из второго набора             (c, employees) =&gt; new   // результат             {                 Title = c.Title,                 Employees = employees            });foreach (var company in personnel){    Console.WriteLine(company.Title);    foreach(var emp in company.Employees)    {        Console.WriteLine(emp.Name);    }    Console.WriteLine();}record class Person(string Name, string Company);record class Company(string Title, string Language);
Copy<br>Результатом выполнения программы будет следующий вывод:<br>Microsoft
Tom
Mike

Google
Sam

Oracle
Copy<br>Метод GroupJoin, также как и метод Join, принимает все те же параметры. Только теперь в последний параметр - делегат передаются объект компании и набор пользователей этой компании.<br>Обратите внимание, что для компании “Oracle” в массиве people нет пользователей, хотя для нее также создается группа.<br>Аналогичного результата можно добитьс и с помощью оператора join:<br>var personnel = from c in companies                join p in people on c.Title equals p.Company into g                select new   // результат                {                    Title = c.Title,                    Employees = g                };
Copy<br><br>Метод Zip() последовательно объединяет соответствующие элементы текущей последовательности со второй последовательностью, которая передается в метод в качестве параметра. То есть первый элемент из первой последовательности объединяется с первым элементом из второй последовательности, второй элемент из первой последовательности соединяется со вторым элементом из второй последовательности и так далее. Результатом метода является коллекция кортежей, где каждый кортеж хранит пару соответствующих элементов из обоих последовательностей:<br>var courses = new List&lt;Course&gt; { new Course("C#"), new Course("Java") };var students = new List&lt;Student&gt; { new Student("Tom"), new Student("Bob") };var enrollments = courses.Zip(students);foreach (var enrollment in enrollments)    Console.WriteLine($"{enrollment.First} - {enrollment.Second}");record class Course(string Title);  // учебный курсrecord class Student(string Name);  // студент
Copy<br>Здесь метод Zip объединяет соответствующие элементы из списков courses и students. В результате создается новая коллекция, которая хранит набор кортежей. Каждый кортеж в ней имеет два элемента. Первый элемент из свойства First представляет объект текущей коллекции (в данном случае объект Course), а второй элемент (в свойстве Second) хранит объект второй последовательности (в данном случае объект Student). Консольный вывод:<br>Course { Title = C# } - Student { Name = Tom }
Course { Title = Java } - Student { Name = Bob }
Copy]]></description><link>04.-literature-notes/linq-by-metanit/соединение-коллекций.html</link><guid isPermaLink="false">04. Literature Notes/LINQ by Metanit/Соединение коллекций.md</guid><pubDate>Wed, 08 May 2024 21:41:40 GMT</pubDate></item><item><title><![CDATA[Сортировка]]></title><description><![CDATA[ 
 <br><br>Для сортировки набора данных в LINQ можно применять оператор&nbsp;orderby:<br>int[] numbers = { 3, 12, 4, 10};var orderedNumbers = from i in numbers                     orderby i                     select i;foreach (int i in orderedNumbers)    Console.WriteLine(i);
Copy<br>Оператор&nbsp;orderby&nbsp;принимает критерий сортировки. В данном случае в качестве критерия выступает само число. Результат работы программы:<br>3
4
10
12
Copy<br>Если числа сортируются стандартным образом, как принято в математике, то строки сортируются исходя из алфавитного порядка:<br>string[] people = { "Tom", "Bob", "Sam" };var orderedPeople = from p in people orderby p select p;foreach (var p in orderedPeople)    Console.WriteLine(p);       // Bob Sam Tom
Copy<br>Вместо оператора orderby можно применять метод расширения&nbsp;OrderBy():<br>OrderBy (Func&lt;TSource,TKey&gt; keySelector)OrderBy (Func&lt;TSource,TKey&gt; keySelector, IComparer&lt;TKey&gt;? comparer);
Copy<br>Первая версия метода получает делегат, который через параметр получает элемент коллекции и который возвращает значение, применяемое для сортировки. Вторая версия позволяет также задать принцип сортировки через реализацию интерфейса IComparer.<br>Перепишем предыдущие два примера с помощью метода OrderBy:<br>int[] numbers = { 3, 12, 4, 10 };var orderedNumbers = numbers.OrderBy(n=&gt;n);foreach (int i in orderedNumbers)    Console.WriteLine(i);string[] people = { "Tom", "Bob", "Sam" };var orderedPeople = people.OrderBy(p=&gt;p);foreach (var p in orderedPeople)    Console.WriteLine(p);
Copy<br><br>Возьмем посложнее пример. Допустим, надо отсортировать выборку сложных объектов. Тогда в качестве критерия мы можем указать свойство класса объекта:<br>var people = new List&lt;Person&gt;{    new Person("Tom", 37),    new Person("Sam", 28),    new Person("Tom", 22),    new Person("Bob", 41),};// с помощью оператора orderbyvar sortedPeople1 = from p in people                  orderby p.Name                  select p;foreach (var p in sortedPeople1)    Console.WriteLine($"{p.Name} - {p.Age}");// с помощью метода OrderByvar sortedPeople2 = people.OrderBy(p =&gt; p.Name);foreach (var p in sortedPeople2)    Console.WriteLine($"{p.Name} - {p.Age}");record class Person(string Name, int Age);
Copy<br><br>По умолчанию оператор&nbsp;orderby&nbsp;и метод OrderBy производят сортировку по возрастанию. С помощью ключевых слов&nbsp;ascending&nbsp;(сортировка по возрастанию) и&nbsp;descending&nbsp;(сортировка по убыванию) для оператора&nbsp;orderby&nbsp;можно явным образом указать направление сортировки. Например, отсортируем массив чисел по убыванию:<br>int[] numbers = { 3, 12, 4, 10 };var orderedNumbers = from i in numbers                     orderby i descending                     select i;foreach (int i in orderedNumbers)    Console.WriteLine(i);   // 12 10 4 3
Copy<br>Для сортировки по убыванию можно применять метод&nbsp;OrderByDescending(), который работает аналогично OrderBy за исключением направления сортировки:<br>int[] numbers = { 3, 12, 4, 10 };var orderedNumbers = numbers.OrderByDescending(n =&gt; n);foreach (int i in orderedNumbers)    Console.WriteLine(i);   // 12 10 4 3
Copy<br><br>В наборах сложных объектов иногда встает ситуация, когда надо отсортировать не по одному, а сразу по нескольким полям. Для этого в запросе LINQ все критерии указываются в порядке приоритета через запятую:<br>var people = new List&lt;Person&gt;{    new Person("Tom", 37),    new Person("Sam", 28),    new Person("Tom", 22),    new Person("Bob", 41),};// с помощью оператора orderbyvar sortedPeople1 = from p in people                  orderby p.Name, p.Age                  select p;foreach (var p in sortedPeople1)    Console.WriteLine($"{p.Name} - {p.Age}");
Copy<br>Результат программы:<br>Bob - 41
Sam - 28
Tom - 22
Tom - 37
Copy<br>Для разных критериев сортировки можно установить направление:<br>// с помощью оператора orderbyvar sortedPeople1 = from p in people                  orderby p.Name, p.Age descending  // сортировка по возрасту по убыванию                  select p;
Copy<br>С помощью методов расширения то же самое можно сделать через метод&nbsp;ThenBy() (для сортировки по возрастанию) и&nbsp;ThenByDescending()&nbsp;(для сортировки по убыванию):<br>var sortedPeople2 = people.OrderBy(p =&gt; p.Name)                    .ThenByDescending(p=&gt;p.Age);
Copy<br>Результат будет аналогичен предыдущему.<br><br>С помощью реализации IComparer мы можем переопределить критерии сортировки, если они нас не устраивают. Например, строки по умолчанию сортируются в алфавитном порядке. Но что, если мы хотим сортировать строки исходя из их длины? Решим данную задачу:<br>string[] people = new[]{"Kate", "Tom", "Sam", "Mike", "Alice"};var sortedPeople = people.OrderBy(p =&gt; p, new CustomStringComparer());foreach (var p in sortedPeople)    Console.WriteLine(p);// сравнение по длине строкиclass CustomStringComparer : IComparer&lt;String&gt;{    public int Compare(string? x, string? y)    {        int xLength = x?.Length ?? 0; // если x равно null, то длина 0        int yLength = y?.Length ?? 0;        return xLength - yLength;    }}
Copy<br>Интерфейс IComparer типизируется типов сортируемых данных (в данном случае типом String). Для реализации этого интерфейса необходимо определить метод Compare. Он возвращает число: если первый параметр больше второго, то число больше 0, если меньше - то число меньше 0. Если оба параметра равны, то возвращается 0.<br>В данном случае, если параметр равен null, будем считать что длина строки равна 0. И с помощью разницы длин строк из обоих параметров определяем, какой из них больше.<br>Результат программы:<br>Tom
Sam
Kate
Mike
Alice
Copy]]></description><link>04.-literature-notes/linq-by-metanit/сортировка.html</link><guid isPermaLink="false">04. Literature Notes/LINQ by Metanit/Сортировка.md</guid><pubDate>Wed, 08 May 2024 21:41:33 GMT</pubDate></item><item><title><![CDATA[Фильтрация коллекции]]></title><description><![CDATA[ 
 <br>Для выбора элементов из некоторого набора по условию используется метод&nbsp;Where:<br>Where&lt;TSource&gt; (Func&lt;TSource,bool&gt; predicate)
Copy<br>Этот метод принимает делегат&nbsp;Func&lt;TSource,bool&gt;, который в качестве параметра принимает каждый элемент последовательности и возвращает значение bool. Если элемент соответствует некоторому условию, то возвращается true, и тогда этот элемент передается в коллекцию, которая возвращается из метода Where.<br>Например, выберем все строки, длина которых равна 3:<br>string[] people = { "Tom", "Alice", "Bob", "Sam", "Tim", "Tomas", "Bill" };var selectedPeople = people.Where(p =&gt; p.Length == 3); // "Tom", "Bob", "Sam", "Tim"foreach (string person in selectedPeople)    Console.WriteLine(person);
Copy<br>Если выражение в методе Where для определенного элемента будет равно true (в данном случае выражение&nbsp;p.Length == 3), то данный элемент попадает в результирующую выборку.<br>Аналогичный запрос с помощью операторов LINQ:<br>string[] people = { "Tom", "Alice", "Bob", "Sam", "Tim", "Tomas", "Bill" };var selectedPeople = from p in people                     where p.Length == 3                     select p;
Copy<br>Другой пример - выберем все четные элементы, которые больше 10.<br>Фильтрация с помощью операторов LINQ:<br>int[] numbers = { 1, 2, 3, 4, 10, 34, 55, 66, 77, 88 };// методы расширенияvar evens1 = numbers.Where(i =&gt; i % 2 == 0 &amp;&amp; i &gt; 10);// операторы запросовvar evens2 = from i in numbers            where i%2==0 &amp;&amp; i&gt;10            select i;
Copy<br><br>Допустим, у нас есть класс пользователя:<br>record class Person(string Name, int Age, List&lt;string&gt; Languages);
Copy<br>Свойство Name представляет имя, свойство Age - возраст пользователя, а список Languages - список языков, которыми владеет пользователь.<br>Создадим набор пользователей и выберем из них тех, которым больше 25 лет:<br>var people = new List&lt;Person&gt;{    new Person ("Tom", 23, new List&lt;string&gt; {"english", "german"}),    new Person ("Bob", 27, new List&lt;string&gt; {"english", "french" }),    new Person ("Sam", 29, new List&lt;string&gt;  { "english", "spanish" }),    new Person ("Alice", 24, new List&lt;string&gt; {"spanish", "german" })};var selectedPeople = from p in people                     where p.Age &gt; 25                     select p;foreach (Person person in selectedPeople)    Console.WriteLine($"{person.Name} - {person.Age}");
Copy<br>Консольный вывод:<br>Bob - 27
Sam - 29
Copy<br>Аналогичный запрос с помощью метода расширения&nbsp;Where:<br>var selectedPeople = people.Where(p=&gt; p.Age &gt; 25);
Copy<br><br>Теперь рассмотрим более сложные фильтры. Например, в классе пользователя есть список языков, которыми владеет пользователь. Что если нам надо отфильтровать пользователей по языку:<br>var selectedPeople = from person in people                    from lang in person.Languages                    where person.Age &lt; 28                    where lang == "english"                    select person;
Copy<br>Результат:<br>Tom - 23
Bob - 27
Copy<br>Для создания аналогичного запроса с помощью методов расширения применяется метод&nbsp;SelectMany:<br>var selectedPeople = people.SelectMany(u =&gt; u.Languages,            (u, l) =&gt; new { Person = u, Lang = l })            .Where(u =&gt; u.Lang == "english" &amp;&amp; u.Person.Age &lt; 28)            .Select(u=&gt;u.Person);
Copy<br>Метод&nbsp;SelectMany()&nbsp;в качестве первого параметра принимает последовательность, которую надо проецировать, а в качестве второго параметра - функцию преобразования, которая применяется к каждому элементу. На выходе она возвращает 8 пар “пользователь - язык” (new { Person = u, Lang = l }), к которым потом применяется фильтр с помощью Where.<br><br>Дополнительный метод расширения -&nbsp;OfType()&nbsp;позволяет отфильтровать данные коллекции по определенному типу:<br>var people= new List&lt;Person&gt;{
new Student("Tom"),    new Person("Sam"),    new Student("Bob"),    new Employee("Mike")};var students = people.OfType&lt;Student&gt;();foreach (var student in students)    Console.WriteLine(student.Name);record class Person(string Name);record class Student(string Name): Person(Name);record class Employee(string Name) : Person(Name);
Copy<br>В данном случае список people содержит объекты трех типов - класса Person и производных типов Student и Employee. И в примере производится фильтрация данных типа Student - для этого метод&nbsp;OfType()&nbsp;типизируется типом Student. Консольный вывод:<br>Tom
Bob
Copy]]></description><link>04.-literature-notes/linq-by-metanit/фильтрация-коллекции.html</link><guid isPermaLink="false">04. Literature Notes/LINQ by Metanit/Фильтрация коллекции.md</guid><pubDate>Wed, 08 May 2024 21:41:28 GMT</pubDate></item><item><title><![CDATA[LINQ by Metanit]]></title><description><![CDATA[ 
 <br><br>Основы LINQ<br><br><br>LINQ&nbsp;(Language-Integrated Query) представляет простой и удобный язык запросов к источнику данных. В качестве источника данных может выступать объект, реализующий интерфейс IEnumerable (например, стандартные коллекции, массивы), набор данных DataSet, документ XML. Но вне зависимости от типа источника LINQ позволяет применить ко всем один и тот же подход для выборки данных.<br>Существует несколько разновидностей LINQ:<br>
<br>LINQ to Objects: применяется для работы с массивами и коллекциями
<br>LINQ to Entities: используется при обращении к базам данных через технологию Entity Framework
<br>LINQ to XML: применяется при работе с файлами XML
<br>LINQ to DataSet: применяется при работе с объектом DataSet
<br>Parallel LINQ (PLINQ): используется для выполнения параллельных запросов
<br>В этой главе речь пойдет прежде всего о&nbsp;LINQ to Objects, но в последующих материалах также будут затронуты и другие разновидности LINQ. Основная часть функциональности LINQ сосредоточена в пространстве имен&nbsp;System.LINQ. В проектах под .NET 6 данное пространство имен подключается по умолчанию.<br>В чем же удобство LINQ? Посмотрим на простейшем примере. Выберем из массива строки, которые начинаются на определенную букву, например, букву “T”, и отсортируем полученный список:<br>string[] people = { "Tom", "Bob", "Sam", "Tim", "Tomas", "Bill" };

// Creăm un nou List pentru rezultate
var selectedPeople = new List&lt;string&gt;();

// Parcurgem array-ul
foreach (string person in people)
{
    // Dacă string-ul începe cu litera 'T', îl adăugăm în List
    if (person.ToUpper().StartsWith("T"))
        selectedPeople.Add(person);
}

// Sortăm List-ul
selectedPeople.Sort();

foreach (string person in selectedPeople)
    Console.WriteLine(person);
Copy<br>Для отфильтрованных строк создается специальный список. Затем в цикле проходим по всем элементам массива и, если они соответствуют условию (начинаются на букву T), то добавляем их в этот список. Затем сортируем список по возрастанию. И в конце элементы полученного списка выводим на консоль:<br>Tim
Tom
Tomas
Copy<br>Хотя подобный подход вполне работает, однако LINQ позволяет значительно сократить код с помощью интуитивно понятного и краткого синтаксиса.<br>Для работы с колекциями можно использовать два способа:<br>
<br>Операторы запросов LINQ
<br>Методы расширений LINQ
<br>Рассмотрим оба способа<br><br>Операторы запросов LINQ в каком-то роде частично напоминают синтаксис запросов SQL, поэтому если вы работали когда-нибудь с sql-запросами, то будет проще понять общую концепцию. Итак, изменим предыдущий пример, применив операторы запросов LINQ:<br>string[] people = { "Tom", "Bob", "Sam", "Tim", "Tomas", "Bill" };

// Создаем новый список для результатов
var selectedPeople = from p in people  // Передаем каждый элемент из people в переменную p
                    where p.ToUpper().StartsWith("T") // Фильтрация по критерию
                    orderby p  // Упорядочиваем по возрастанию
                    select p; // Выбираем объекты в создаваемую коллекцию

foreach (string person in selectedPeople)
    Console.WriteLine(person);
Copy<br>Прежде всего, как мы видим, код стал меньше и проще, а результат будет тем же. В принципе все выражение можно было бы записать в одну строку:<br>var selectedPeople = from p in people where p.ToUpper().StartsWith("T") orderby p  select p;
Copy<br>Но для более понятной логической разбивки я поместил каждое отдельное подвыражение на отдельной строке.<br>Простейшее определение запроса LINQ выглядит следующим образом:<br>from переменная in набор_объектов select переменная;
Copy<br>Итак, что делает этот запрос LINQ? Выражение&nbsp;from p in people&nbsp;проходит по всем элементам массива people и определяет каждый элемент как&nbsp;p. Используя переменную&nbsp;p&nbsp;мы можем проводить над ней разные операции.<br>Несмотря на то, что мы не указываем тип переменной&nbsp;p, выражения LINQ являются строго типизированными. То есть среда автоматически распознает, что набор people состоит из объектов string, поэтому переменная&nbsp;p&nbsp;будет рассматриваться в качестве строки.<br>Далее с помощью оператора&nbsp;where&nbsp;проводится фильтрация объектов, и если объект соответствует критерию (в данном случае начальная буква должна быть “T”), то этот объект передается дальше.<br>Оператор&nbsp;orderby&nbsp;упорядочивает по возрастанию, то есть сортирует выбранные объекты.<br>Оператор&nbsp;select&nbsp;передает выбранные значения в результирующую выборку, которая возвращается LINQ-выражением.<br>В данном случае результатом выражения LINQ является объект&nbsp;IEnumerable&lt;T&gt;. Нередко результирующая выборка определяется с помощью ключевого слова&nbsp;var, тогда компилятор на этапе компиляции сам выводит тип.<br><br>Кроме стандартного синтаксиса&nbsp;from .. in .. select&nbsp;для создания запроса LINQ мы можем применять специальные методы расширения, которые определены для интерфейса&nbsp;IEnumerable. Как правило, эти методы реализуют ту же функциональность, что и операторы LINQ типа&nbsp;where&nbsp;или&nbsp;orderby.<br>Например:<br>string[] people = { "Tom", "Bob", "Sam", "Tim", "Tomas", "Bill" };
var selectedPeople = people.Where(p =&gt; p.ToUpper().StartsWith("T")).OrderBy(p =&gt; p);

foreach (string person in selectedPeople)
    Console.WriteLine(person);
Copy<br>Запрос&nbsp;people.Where(p=&gt;p.ToUpper().StartsWith("T")).OrderBy(p =&gt; p)&nbsp;будет аналогичен предыдущему. Он состоит из цепочки методов Where и OrderBy. В качестве аргумента эти методы принимают делегат или лямбда-выражение.<br>И хотя ряд действий мы можем реализовать как с помощью операторов запросов LINQ, так и с помощью методов расширений LINQ, но не каждый метод расширения имеет аналог среди операторов LINQ. И в этом случае можно сочетать оба подхода. Например, используем стандартный синтаксис linq и метод расширения Count(), который возвращает количество элементов в выборке:<br>int number = (from p in people where p.ToUpper().StartsWith("T") select p).Count();
Console.WriteLine(number); // 3
Copy<br><br>
<br>Select: определяет проекцию выбранных значений
<br>Where: определяет фильтр выборки
<br>OrderBy: упорядочивает элементы по возрастанию
<br>OrderByDescending: упорядочивает элементы по убыванию
<br>ThenBy: задает дополнительные критерии для упорядочивания элементов возрастанию
<br>ThenByDescending: задает дополнительные критерии для упорядочивания элементов по убыванию
<br>Join: соединяет две коллекции по определенному признаку
<br>Aggregate: применяет к элементам последовательности агрегатную функцию, которая сводит их к одному объекту
<br>GroupBy: группирует элементы по ключу
<br>ToLookup: группирует элементы по ключу, при этом все элементы добавляются в словарь
<br>GroupJoin: выполняет одновременно <a data-href="Соединение коллекций" href="04.-literature-notes/linq-by-metanit/соединение-коллекций.html" class="internal-link" target="_self" rel="noopener">Соединение коллекций</a> и группировку элементов по ключу
<br>Reverse: располагает элементы в обратном порядке
<br>All: определяет, все ли элементы коллекции удовлятворяют определенному условию
<br>Any: определяет, удовлетворяет хотя бы один элемент коллекции определенному условию
<br>Contains: определяет, содержит ли коллекция определенный элемент
<br>Distinct: удаляет дублирующиеся элементы из коллекции
<br>Except: возвращает разность двух коллекцию, то есть те элементы, которые создаются только в одной коллекции
<br>Union: объединяет две однородные коллекции
<br>Intersect: возвращает пересечение двух коллекций, то есть те элементы, которые встречаются в обоих коллекциях
<br>Count: подсчитывает количество элементов коллекции, которые удовлетворяют определенному условию
<br>Sum: подсчитывает сумму числовых значений в коллекции
<br>Average: подсчитывает cреднее значение числовых значений в коллекции
<br>Min: находит минимальное значение
<br>Max: находит максимальное значение
<br>Take: выбирает определенное количество элементов
<br>Skip: пропускает определенное количество элементов
<br>TakeWhile: возвращает цепочку элементов последовательности, до тех пор, пока условие истинно
<br>SkipWhile: пропускает элементы в последовательности, пока они удовлетворяют заданному условию, и затем возвращает оставшиеся элементы
<br>Concat: объединяет две коллекции
<br>Zip: объединяет две коллекции в соответствии с определенным условием
<br>First: выбирает первый элемент коллекции
<br>FirstOrDefault: выбирает первый элемент коллекции или возвращает значение по умолчанию
<br>Single: выбирает единственный элемент коллекции, если коллекция содержит больше или меньше одного элемента, то генерируется исключение
<br>SingleOrDefault: выбирает единственный элемент коллекции. Если коллекция пуста, возвращает значение по умолчанию. Если в коллекции больше одного элемента, генерирует исключение
<br>ElementAt: выбирает элемент последовательности по определенному индексу
<br>ElementAtOrDefault: выбирает элемент коллекции по определенному индексу или возвращает значение по умолчанию, если индекс вне допустимого диапазона
<br>Last: выбирает последний элемент коллекции
<br>LastOrDefault: выбирает последний элемент коллекции или возвращает значение по умолчанию
<br><br>Проекция данных<br><br><br>Проекция позволяет преобразовать объект одного типа в объект другого типа. Для проекции используется оператор&nbsp;select. Допустим, у нас есть набор объектов следующего класса, представляющего пользователя:<br>record class Person(string Name, int Age);
Copy<br>Но, допустим, нам нужен не весь объект, а только его свойство Name:<br>var people = new List&lt;Person&gt; {
    new Person ("Tom", 23),
    new Person ("Bob", 27),
    new Person ("Sam", 29),
    new Person ("Alice", 24)
};

var names = from p in people select p.Name;

foreach (string n in names)
    Console.WriteLine(n);
Copy<br>Результат выражения LINQ будет представлять набор строк, поскольку выражение&nbsp;select p.Name&nbsp;выбирает в результирующую выборку только значения свойства Name.<br>Tom
Bob
Sam
Alice
Copy<br>В качестве альтернативы мы могли бы использовать метод расширения&nbsp;Select():<br>Select(Func&lt;TSource,TResult&gt; selector)
Copy<br>Этот метод принимает функцию преобразования в виде делегата Func&lt;TSource,TResult&gt;. Функция преобразования получает каждый объект выборки типа TSource и с его помощью создает объект TResult. Метод Select возвращает коллекцию преобразованных объектов.<br>Перепишем предыдущий пример с применением метода Select:<br>var people = new List&lt;Person&gt;{
	new Person ("Tom", 23),    
	new Person ("Bob", 27),    
	new Person ("Sam", 29),    
	new Person ("Alice", 24)};
var names = people.Select(u =&gt; u.Name);
foreach (string n in names)
	Console.WriteLine(n);
Copy<br>Аналогично можно создать объекты другого типа, в том числе анонимного:<br>var people = new List&lt;Person&gt;{    new Person ("Tom", 23),    new Person ("Bob", 27)};var personel = from p in people            select new            {                FirstName = p.Name,                Year = DateTime.Now.Year - p.Age            };foreach (var p in personel)    Console.WriteLine($"{p.FirstName} - {p.Year}");record class Person(string Name, int Age);
Copy<br>Здесь оператор&nbsp;select&nbsp;создает объект анонимного типа, используя текущий объект Person. И теперь результат будет содержать набор объектов данного анонимного типа, в котором определены два свойства: FirstName и Year (год рождения). Консольный вывод программы:<br>Tom - 1999
Bob - 1995
Copy<br>В качестве альтернативы мы могли бы использовать метод расширения&nbsp;Select():<br>// проекция на объекты анонимного типаvar personel = people.Select(p =&gt; new{    FirstName = p.Name,    Year = DateTime.Now.Year - p.Age});
Copy<br><br>Иногда возникает необходимость произвести в запросах LINQ какие-то дополнительные промежуточные вычисления. Для этих целей мы можем задать в запросах свои переменные с помощью оператора&nbsp;let:<br>var people = new List&lt;Person&gt;{    new Person ("Tom", 23),    new Person ("Bob", 27)};var personnel = from p in people               let name = $"Mr. {p.Name}"               let year = DateTime.Now.Year - p.Age               select new            {                Name = name,                Year = year            };foreach (var p in personnel)    Console.WriteLine($"{p.Name} - {p.Year}");record class Person(string Name, int Age);
Copy<br>В данном случае создаются две переменных. Переменная&nbsp;name, значение которой равно&nbsp;$"Mr. {p.Name}".<br>Возможность определения переменных наверное одно из главных преимуществ операторов LINQ по сравнению с методами расширения.<br><br>В LINQ можно выбирать объекты не только из одного, но и из большего количества источников. Например, возьмем классы:<br>record class Course(string Title);  // учебный курсrecord class Student(string Name);  // студент
Copy<br>Класс Course представляет учебный курс и хранит его название. Класс Student представляет студента и хранит его имя.<br>Допустим, нам надо из списка курсов и списка студентов получить набор пар студент-курс (условно говоря сущность, которая представляет учебу студента на данном курсе):<br>var courses = new List&lt;Course&gt; { new Course("C#"), new Course("Java") };var students = new List&lt;Student&gt; { new Student("Tom"), new Student("Bob") };var enrollments = from course in courses    //  выбираем по одному курсу             from student in students       //  выбираем по одному студенту             select new { Student = student.Name, Course = course.Title};   // соединяем каждого студента с каждым курсомforeach (var enrollment in enrollments)    Console.WriteLine($"{enrollment.Student} - {enrollment.Course}");record class Course(string Title);  // учебный курсrecord class Student(string Name);  // студент
Copy<br>Консольный вывод:<br>Tom - C#
Bob - C#
Tom - Java
Bob - Java
Copy<br>Таким образом, при выборке из двух источников каждый элемент из первого источника будет сопоставляться с каждым элементом из второго источника. То есть получиться 4 пары.<br><br>Метод&nbsp;SelectMany&nbsp;позволяет свести набор коллекций в одну коллекцию. Он имеет ряд перегруженных версий. Возьмем одну из них:<br>SelectMany(Func&lt;TSource, IEnumerable&lt;TResult&gt;&gt; selector);SelectMany(Func&lt;TSource, IEnumerable&lt;TCollection&gt;&gt; collectionSelector,           Func&lt;TSource,TCollection,TResult&gt; resultSelector);
Copy<br>Первая версия метода принимает функцию преобразования в виде делегата&nbsp;Func&lt;TSource,IEnumerable&lt;TResult&gt;&gt;. Функция преобразования получает каждый объект выборки типа TSource и с его помощью создает набор объектов TResult. Метод SelectMany возвращает коллекцию преобразованных объектов.<br>Вторая версия принимает функцию преобразования в виде делегата&nbsp;Func&lt;TSource,IEnumerable&lt;TResult&gt;&gt;. Функция преобразования получает каждый объект выборки типа TSource и возвращает некоторую промежуточную коллекцию типа TCollection. Второй параметр - то же функция функция преобразования в виде делегата&nbsp;Func&lt;TSource,TCollection,TResult&gt;, которая получает два параметра - каждый элемент текущей выборки и каждый элемент промежуточной коллекции и на их основе создает некоторый объект типа TResult.<br>Рассмотрим следующий пример:<br>var companies = new List&lt;Company&gt;{    new Company("Microsoft", new List&lt;Person&gt; {new Person("Tom"), new Person("Bob")}),    new Company("Google", new List&lt;Person&gt; {new Person("Sam"), new Person("Mike")}),};var employees = companies.SelectMany(c =&gt; c.Staff);foreach (var emp in employees)    Console.WriteLine($"{emp.Name}");record class Company(string Name, List&lt;Person&gt; Staff);record class Person(string Name);
Copy<br>Здесь нам дан список компаний, в каждой компании имеет набор сотрудников в виде списка объектов Person. И на выходе мы получаем список сотрудников всех компаний, то есть по сути коллекцию объектов Person. Консольный вывод:<br>Tom
Bob
Sam
Mike
Copy<br>Аналогичный пример с помощью операторов LINQ:<br>var companies = new List&lt;Company&gt;{    new Company("Microsoft", new List&lt;Person&gt; {new Person("Tom"), new Person("Bob")}),    new Company("Google", new List&lt;Person&gt; {new Person("Sam"), new Person("Mike")}),};var employees = from c in companies                from emp in c.Staff                select emp;foreach (var emp in employees)    Console.WriteLine($"{emp.Name}");record class Company(string Name, List&lt;Person&gt; Staff);record class Person(string Name);
Copy<br>Теперь добавим к сотрудникам их компанию:<br>var companies = new List&lt;Company&gt;{    new Company("Microsoft", new List&lt;Person&gt; {new Person("Tom"), new Person("Bob")}),    new Company("Google", new List&lt;Person&gt; {new Person("Sam"), new Person("Mike")}),};var employees = companies.SelectMany(c =&gt; c.Staff,                                    (c, emp)=&gt; new { Name = emp.Name, Company = c.Name });foreach (var emp in employees)    Console.WriteLine($"{emp.Name} - {emp.Company}");record class Company(string Name, List&lt;Person&gt; Staff);record class Person(string Name);
Copy<br>Здесь применяется другая версия метода SelectMany. Первый делегат в виде&nbsp;c =&gt; c.Staff&nbsp;создает промежуточную коллекцию - фактически просто возвращаем набор сотрудников каждой компании. Второй делегат -&nbsp;(c, emp)=&gt; new { Name = emp.Name, Company = c.Name }&nbsp;получает каждую компанию и каждый элемент промежуточной коллекции - объект Person и на их основе создает анонимный объект с двумя свойствами Name и Company. Консольный вывод программы:<br>Tom - Microsoft
Bob - Microsoft
Sam - Google
Mike - Google
Copy<br>Аналогичный пример с помощью операторов запросов:<br>var companies = new List&lt;Company&gt;{    new Company("Microsoft", new List&lt;Person&gt; {new Person("Tom"), new Person("Bob")}),    new Company("Google", new List&lt;Person&gt; {new Person("Sam"), new Person("Mike")}),};var employees = from c in companies             from emp in c.Staff             select new { Name = emp.Name, Company = c.Name };foreach (var emp in employees)    Console.WriteLine($"{emp.Name} - {emp.Company}");record class Company(string Name, List&lt;Person&gt; Staff);record class Person(string Name);
Copy<br><br>Фильтрация коллекции<br><br><br>Для выбора элементов из некоторого набора по условию используется метод&nbsp;Where:<br>Where&lt;TSource&gt; (Func&lt;TSource,bool&gt; predicate)
Copy<br>Этот метод принимает делегат&nbsp;Func&lt;TSource,bool&gt;, который в качестве параметра принимает каждый элемент последовательности и возвращает значение bool. Если элемент соответствует некоторому условию, то возвращается true, и тогда этот элемент передается в коллекцию, которая возвращается из метода Where.<br>Например, выберем все строки, длина которых равна 3:<br>string[] people = { "Tom", "Alice", "Bob", "Sam", "Tim", "Tomas", "Bill" };var selectedPeople = people.Where(p =&gt; p.Length == 3); // "Tom", "Bob", "Sam", "Tim"foreach (string person in selectedPeople)    Console.WriteLine(person);
Copy<br>Если выражение в методе Where для определенного элемента будет равно true (в данном случае выражение&nbsp;p.Length == 3), то данный элемент попадает в результирующую выборку.<br>Аналогичный запрос с помощью операторов LINQ:<br>string[] people = { "Tom", "Alice", "Bob", "Sam", "Tim", "Tomas", "Bill" };var selectedPeople = from p in people                     where p.Length == 3                     select p;
Copy<br>Другой пример - выберем все четные элементы, которые больше 10.<br>Фильтрация с помощью операторов LINQ:<br>int[] numbers = { 1, 2, 3, 4, 10, 34, 55, 66, 77, 88 };// методы расширенияvar evens1 = numbers.Where(i =&gt; i % 2 == 0 &amp;&amp; i &gt; 10);// операторы запросовvar evens2 = from i in numbers            where i%2==0 &amp;&amp; i&gt;10            select i;
Copy<br><br>Допустим, у нас есть класс пользователя:<br>record class Person(string Name, int Age, List&lt;string&gt; Languages);
Copy<br>Свойство Name представляет имя, свойство Age - возраст пользователя, а список Languages - список языков, которыми владеет пользователь.<br>Создадим набор пользователей и выберем из них тех, которым больше 25 лет:<br>var people = new List&lt;Person&gt;{    new Person ("Tom", 23, new List&lt;string&gt; {"english", "german"}),    new Person ("Bob", 27, new List&lt;string&gt; {"english", "french" }),    new Person ("Sam", 29, new List&lt;string&gt;  { "english", "spanish" }),    new Person ("Alice", 24, new List&lt;string&gt; {"spanish", "german" })};var selectedPeople = from p in people                     where p.Age &gt; 25                     select p;foreach (Person person in selectedPeople)    Console.WriteLine($"{person.Name} - {person.Age}");
Copy<br>Консольный вывод:<br>Bob - 27
Sam - 29
Copy<br>Аналогичный запрос с помощью метода расширения&nbsp;Where:<br>var selectedPeople = people.Where(p=&gt; p.Age &gt; 25);
Copy<br><br>Теперь рассмотрим более сложные фильтры. Например, в классе пользователя есть список языков, которыми владеет пользователь. Что если нам надо отфильтровать пользователей по языку:<br>var selectedPeople = from person in people                    from lang in person.Languages                    where person.Age &lt; 28                    where lang == "english"                    select person;
Copy<br>Результат:<br>Tom - 23
Bob - 27
Copy<br>Для создания аналогичного запроса с помощью методов расширения применяется метод&nbsp;SelectMany:<br>var selectedPeople = people.SelectMany(u =&gt; u.Languages,            (u, l) =&gt; new { Person = u, Lang = l })            .Where(u =&gt; u.Lang == "english" &amp;&amp; u.Person.Age &lt; 28)            .Select(u=&gt;u.Person);
Copy<br>Метод&nbsp;SelectMany()&nbsp;в качестве первого параметра принимает последовательность, которую надо проецировать, а в качестве второго параметра - функцию преобразования, которая применяется к каждому элементу. На выходе она возвращает 8 пар “пользователь - язык” (new { Person = u, Lang = l }), к которым потом применяется фильтр с помощью Where.<br><br>Дополнительный метод расширения -&nbsp;OfType()&nbsp;позволяет отфильтровать данные коллекции по определенному типу:<br>var people= new List&lt;Person&gt;{
new Student("Tom"),    new Person("Sam"),    new Student("Bob"),    new Employee("Mike")};var students = people.OfType&lt;Student&gt;();foreach (var student in students)    Console.WriteLine(student.Name);record class Person(string Name);record class Student(string Name): Person(Name);record class Employee(string Name) : Person(Name);
Copy<br>В данном случае список people содержит объекты трех типов - класса Person и производных типов Student и Employee. И в примере производится фильтрация данных типа Student - для этого метод&nbsp;OfType()&nbsp;типизируется типом Student. Консольный вывод:<br>Tom
Bob
Copy<br><br>Методы Skip и Take<br><br>Ряд методов в LINQ позволяют получить часть коллекции, в частности, такие методы как Skip, Take, SkipWhile, TakeWhile.<br><br>Метод&nbsp;Skip()&nbsp;пропускает определенное количество элементов. Количество пропускаемых элементов передается в качестве параметра в метод:<br>string[] people = { "Tom", "Sam", "Bob", "Mike", "Kate" };// пропускаем первые два элементаvar result = people.Skip(2);    // "Bob", "Mike", "Kate"foreach (var person in result)    Console.WriteLine(person);
Copy<br>В данном случае пропускаем первые два элемента. Консольный вывод:<br>Bob
Mike
Kate
Copy<br>Если необходимо пропустить определенное количество элементов с конца коллекции, то применяется метод&nbsp;SkipLast():<br>string[] people = { "Tom", "Sam", "Bob", "Mike", "Kate" };// пропускаем последние два элементаvar result = people.SkipLast(2);    // "Tom", "Sam", "Bob"foreach (var person in result)    Console.WriteLine(person);
Copy<br>В данном случае пропускаем последние два элемента. Консольный вывод:<br>Tom
Sam
Bob
Copy<br><br>Метод&nbsp;SkipWhile()&nbsp;пропускает цепочку элементов, начиная с первого элемента, пока они удовлетворяют определенному условию:<br>SkipWhile(Func&lt;TSource, bool&gt; predicate);
Copy<br>В метод передается делегат, который представляет условие, он получает каждый элемент коллекции и возвращает значение true, если элемент соответствует условию. Например:<br>string[] people = { "Tom", "Sam", "Mike", "Kate", "Bob" };// пропускаем первые элементы, длина которых равна 3var result = people.SkipWhile(p=&gt; p.Length == 3);    // "Mike", "Kate", "Bob"foreach (var person in result)    Console.WriteLine(person);
Copy<br>Здесь метод SkipWhile пропускает элементы, длина которых равна 3 символам. Первые два элемента массива people (“Tom”, “Sam”) соответствуют этому условию и поэтому будут пропущены. На третьем элементе (“Mike”) цепочка обрывается, поэтому последний элемент (“Bob”), длина которго тоже равна 3-м символам, не будет пропущен и будет включен в выходную коллекцию:<br>Mike
Kate
Bob
Copy<br>Если в массиве первый элемент имел бы длину больше или меньше 3 символов, то цепочка пропускаемых элементов прервалась бы уже на первом элементе, и поэтому метод SkipWhile возвратил бы все элементы массива.<br><br>Метод&nbsp;Take()&nbsp;извлекает определенное число элементов. Количество извлекаемых элементов передается в метод в качестве параметра. Например, извлечем три первых элемента:<br>string[] people = { "Tom", "Sam", "Mike", "Kate", "Bob" };// извлекаем первые 3 элементаvar result = people.Take(3);    // "Tom", "Sam", "Mike"foreach (var person in result)    Console.WriteLine(person);
Copy<br>Метод&nbsp;TakeLast()&nbsp;извлекает определенное количество элементов с конце коллекции:<br>string[] people = { "Tom", "Sam", "Mike", "Kate", "Bob" };// извлекаем последние 3 элементаvar result = people.TakeLast(3);    // "Mike", "Kate", "Bob"foreach (var person in result)    Console.WriteLine(person);
Copy<br><br>Метод&nbsp;TakeWhile()&nbsp;выбирает цепочку элементов, начиная с первого элемента, пока они удовлетворяют определенному условию:<br>TakeWhile(Func&lt;TSource, bool&gt; predicate);
Copy<br>В метод передается делегат, который представляет условие, он получает каждый элемент коллекции и возвращает значение true, если элемент соответствует условию. Например:<br>string[] people = { "Tom", "Sam", "Mike", "Kate", "Bob" };// извлекаем первые элементы, длина которых равна 3var result = people.TakeWhile(p=&gt; p.Length == 3);    // "Tom", "Sam"foreach (var person in result)    Console.WriteLine(person);
Copy<br>Здесь метод TakeWhile выбирает элементы, длина которых равна 3 символам. Первые два элемента массива people (“Tom”, “Sam”) соответствуют этому условию и поэтому будут выбраны в выходную коллекцию. На третьем элементе (“Mike”) цепочка обрывается, поэтому последний элемент (“Bob”), длина которго тоже равна 3-м символам, не будет включен в выходную коллекцию:<br>Tom
Sam
Copy<br>Если бы первый элемент в массиве имел бы длину больше или меньше 3 символов, то в этом случае метод TakeWhile возвратил бы нам 0 элементов.<br><br>Совмещая оба метода - Take и Skip, мы можем выбрать определенное количество элементов начиная с определенного элемента. Например, выберем два элемента, начиная со четвертого (то есть пропустим 3 первых элемента):<br>string[] people = { "Tom", "Sam", "Mike", "Kate", "Bob", "Alice" };// пропускаем 3 элемента и выбираем 2 элементаvar result = people.Skip(3).Take(2);    // "Kate", "Bob"foreach (var person in result)    Console.WriteLine(person);
Copy<br><br>Сортировка<br><br><br><br>Для сортировки набора данных в LINQ можно применять оператор&nbsp;orderby:<br>int[] numbers = { 3, 12, 4, 10};var orderedNumbers = from i in numbers                     orderby i                     select i;foreach (int i in orderedNumbers)    Console.WriteLine(i);
Copy<br>Оператор&nbsp;orderby&nbsp;принимает критерий сортировки. В данном случае в качестве критерия выступает само число. Результат работы программы:<br>3
4
10
12
Copy<br>Если числа сортируются стандартным образом, как принято в математике, то строки сортируются исходя из алфавитного порядка:<br>string[] people = { "Tom", "Bob", "Sam" };var orderedPeople = from p in people orderby p select p;foreach (var p in orderedPeople)    Console.WriteLine(p);       // Bob Sam Tom
Copy<br>Вместо оператора orderby можно применять метод расширения&nbsp;OrderBy():<br>OrderBy (Func&lt;TSource,TKey&gt; keySelector)OrderBy (Func&lt;TSource,TKey&gt; keySelector, IComparer&lt;TKey&gt;? comparer);
Copy<br>Первая версия метода получает делегат, который через параметр получает элемент коллекции и который возвращает значение, применяемое для сортировки. Вторая версия позволяет также задать принцип сортировки через реализацию интерфейса IComparer.<br>Перепишем предыдущие два примера с помощью метода OrderBy:<br>int[] numbers = { 3, 12, 4, 10 };var orderedNumbers = numbers.OrderBy(n=&gt;n);foreach (int i in orderedNumbers)    Console.WriteLine(i);string[] people = { "Tom", "Bob", "Sam" };var orderedPeople = people.OrderBy(p=&gt;p);foreach (var p in orderedPeople)    Console.WriteLine(p);
Copy<br><br>Возьмем посложнее пример. Допустим, надо отсортировать выборку сложных объектов. Тогда в качестве критерия мы можем указать свойство класса объекта:<br>var people = new List&lt;Person&gt;{    new Person("Tom", 37),    new Person("Sam", 28),    new Person("Tom", 22),    new Person("Bob", 41),};// с помощью оператора orderbyvar sortedPeople1 = from p in people                  orderby p.Name                  select p;foreach (var p in sortedPeople1)    Console.WriteLine($"{p.Name} - {p.Age}");// с помощью метода OrderByvar sortedPeople2 = people.OrderBy(p =&gt; p.Name);foreach (var p in sortedPeople2)    Console.WriteLine($"{p.Name} - {p.Age}");record class Person(string Name, int Age);
Copy<br><br>По умолчанию оператор&nbsp;orderby&nbsp;и метод OrderBy производят сортировку по возрастанию. С помощью ключевых слов&nbsp;ascending&nbsp;(сортировка по возрастанию) и&nbsp;descending&nbsp;(сортировка по убыванию) для оператора&nbsp;orderby&nbsp;можно явным образом указать направление сортировки. Например, отсортируем массив чисел по убыванию:<br>int[] numbers = { 3, 12, 4, 10 };var orderedNumbers = from i in numbers                     orderby i descending                     select i;foreach (int i in orderedNumbers)    Console.WriteLine(i);   // 12 10 4 3
Copy<br>Для сортировки по убыванию можно применять метод&nbsp;OrderByDescending(), который работает аналогично OrderBy за исключением направления сортировки:<br>int[] numbers = { 3, 12, 4, 10 };var orderedNumbers = numbers.OrderByDescending(n =&gt; n);foreach (int i in orderedNumbers)    Console.WriteLine(i);   // 12 10 4 3
Copy<br><br>В наборах сложных объектов иногда встает ситуация, когда надо отсортировать не по одному, а сразу по нескольким полям. Для этого в запросе LINQ все критерии указываются в порядке приоритета через запятую:<br>var people = new List&lt;Person&gt;{    new Person("Tom", 37),    new Person("Sam", 28),    new Person("Tom", 22),    new Person("Bob", 41),};// с помощью оператора orderbyvar sortedPeople1 = from p in people                  orderby p.Name, p.Age                  select p;foreach (var p in sortedPeople1)    Console.WriteLine($"{p.Name} - {p.Age}");
Copy<br>Результат программы:<br>Bob - 41
Sam - 28
Tom - 22
Tom - 37
Copy<br>Для разных критериев сортировки можно установить направление:<br>// с помощью оператора orderbyvar sortedPeople1 = from p in people                  orderby p.Name, p.Age descending  // сортировка по возрасту по убыванию                  select p;
Copy<br>С помощью методов расширения то же самое можно сделать через метод&nbsp;ThenBy() (для сортировки по возрастанию) и&nbsp;ThenByDescending()&nbsp;(для сортировки по убыванию):<br>var sortedPeople2 = people.OrderBy(p =&gt; p.Name)                    .ThenByDescending(p=&gt;p.Age);
Copy<br>Результат будет аналогичен предыдущему.<br><br>С помощью реализации IComparer мы можем переопределить критерии сортировки, если они нас не устраивают. Например, строки по умолчанию сортируются в алфавитном порядке. Но что, если мы хотим сортировать строки исходя из их длины? Решим данную задачу:<br>string[] people = new[]{"Kate", "Tom", "Sam", "Mike", "Alice"};var sortedPeople = people.OrderBy(p =&gt; p, new CustomStringComparer());foreach (var p in sortedPeople)    Console.WriteLine(p);// сравнение по длине строкиclass CustomStringComparer : IComparer&lt;String&gt;{    public int Compare(string? x, string? y)    {        int xLength = x?.Length ?? 0; // если x равно null, то длина 0        int yLength = y?.Length ?? 0;        return xLength - yLength;    }}
Copy<br>Интерфейс IComparer типизируется типов сортируемых данных (в данном случае типом String). Для реализации этого интерфейса необходимо определить метод Compare. Он возвращает число: если первый параметр больше второго, то число больше 0, если меньше - то число меньше 0. Если оба параметра равны, то возвращается 0.<br>В данном случае, если параметр равен null, будем считать что длина строки равна 0. И с помощью разницы длин строк из обоих параметров определяем, какой из них больше.<br>Результат программы:<br>Tom
Sam
Kate
Mike
Alice
Copy<br><br>Объединение, пересечение и разность коллекций<br><br><br>LINQ предоставляет несколько методов для работы с коллекциями как с множествами, а именно находить их разность, объединение и пересечение.<br><br>С помощью метода&nbsp;Except()&nbsp;можно получить разность двух последовательностей:<br>string[] soft = { "Microsoft", "Google", "Apple"};string[] hard = { "Apple", "IBM", "Samsung"};// разность последовательностейvar result = soft.Except(hard);foreach (string s in result)    Console.WriteLine(s);
Copy<br>В данном случае из массива&nbsp;soft&nbsp;убираются все элементы, которые есть в массиве&nbsp;hard. Результатом операции будут два элемента:<br>Microsoft
Google
Copy<br><br>Для получения пересечения последовательностей, то есть общих для обоих наборов элементов, применяется метод&nbsp;Intersect:<br>string[] soft = { "Microsoft", "Google", "Apple"};string[] hard = { "Apple", "IBM", "Samsung"};// пересечение последовательностейvar result = soft.Intersect(hard);foreach (string s in result)    Console.WriteLine(s);
Copy<br>Так как оба набора имеют только один общий элемент, то соответственно только он и попадет в результирующую выборку:<br>Apple
Copy<br><br>Для удаления дублей в наборе используется метод&nbsp;Distinct:<br>string[] soft = { "Microsoft", "Google", "Apple", "Microsoft", "Google" };// удаление дублейvar result = soft.Distinct();foreach (string s in result)    Console.WriteLine(s);
Copy<br>Microsoft
Google
Apple
Copy<br><br>Для объединения двух последовательностей используется метод&nbsp;Union. Его результатом является новый набор, в котором имеются элементы, как из первой, так и из второй последовательности. Повторяющиеся элементы добавляются в результат только один раз:<br>string[] soft = { "Microsoft", "Google", "Apple"};string[] hard = { "Apple", "IBM", "Samsung"};// объединение последовательностейvar result = soft.Union(hard);foreach (string s in result)    Console.WriteLine(s);
Copy<br>Результатом операции будет следующий набор:<br>Microsoft
Google
Apple
IBM
Samsung
Copy<br>Если же нам нужно простое объединение двух наборов, то мы можем использовать метод&nbsp;Concat:<br>var result = soft.Concat(hard);
Copy<br>В этом случае те элементы, которые встречаются в обоих наборах, дублируются в резутирующей последовательности.<br>Последовательное применение методов Concat и Distinct будет подобно действию метода Union.<br><br>Для сравнения объектов в последовательностях применяются реализации методов GetHashCode() и Equals(). Поэтому если мы хотим работать с последовательностями, которые содержат объекты своих классов и структур, то нам необходимо определить для них подобные методы:<br>Person[] students = { new Person("Tom"), new Person("Bob"), new Person("Sam") };Person[] employees = { new Person("Tom"), new Person("Bob"), new Person("Mike") };// объединение последовательностейvar people = students.Union(employees);foreach (Person person in people)    Console.WriteLine(person.Name);class Person{    public string Name { get;}    public Person(string name) =&gt; Name = name;    public override bool Equals(object? obj)    {        if (obj is Person person) return Name == person.Name;        return false;    }    public override int GetHashCode() =&gt; Name.GetHashCode();}
Copy<br>Здесь объекты Person сравниваются исходя из значения их свойства Name - если имена равны, то и объекты Person равны. Консольный вывод:<br>Tom
Bob
Sam
Mike
Copy<br><br><br><br>Пара слов о перечисленных в статье методах. Для определения эквивалентности они используют методы GetHeshCode() &amp; Equals(). Если вам нужно работать с коллекцией объектов вашего класса, то эти методы, возможно, придется в нём переопределить.<br>class Program    {        static void Main()        {            List&lt; User&gt; users = new List&lt; User&gt;()                {                    new User { Name = "Tom", Age = 33 },                    new User { Name = "Tom", Age = 33 },                    new User { Name = "Bob", Age = 30 },                    new User { Name = "Tom", Age = 21 },                    new User { Name = "Sam", Age = 43 },                    new User { Name = "Jack", Age = 0 },                    new User { Name = "Maks", Age = 21 },                    new User { Name = "Nikita", Age = 103 },                    new User { Name = "Mike", Age = 3 }                };            foreach (User user in users)                Console.WriteLine($"{user.Name} - {user.Age}");            var distinctedUsers = users.Distinct();            Console.WriteLine("===================");            foreach (User user in distinctedUsers)                Console.WriteLine($"{user.Name} - {user.Age}");        }    }    class User    {        public string Name { get; set; }        public int Age { get; set; }        public override bool Equals(object obj)        {            return obj is User user &amp;&amp;                   Name == user.Name &amp;&amp;                   Age == user.Age;        }        public override int GetHashCode()        {            return HashCode.Combine(Name, Age);        }    }
Copy<br><br>Касательно последнего примера про выборку сложных объектов.<br>Метод Equals по умолчанию работает с object типом, из-за чего каждый раз будет происходить боксинг-анбоксинг при проверка каждого из элементов списка, что не самым лучшим образом влияет на производительность.<br>Нужно реализовать интерфейс IEquatable&lt;t&gt;, чтобы решить эту проблему (это вариант Eqauls с универсальным типом)<br>Person[] students = { new Person("Tom"), new Person("Bob"), new Person("Sam") };Person[] employees = { new Person("Tom"), new Person("Bob"), new Person("Mike") };// объединение последовательностейvar people = students.Union(employees);foreach (Person person in people)    Console.WriteLine(person.Name);class Person : IEquatable&lt;person&gt;{    public string Name { get; }    public Person(string name) =&gt; Name = name;    public bool Equals(Person? obj)    {        if (obj is null) return false;        return obj.Name == Name;    }    public override int GetHashCode() =&gt; Name.GetHashCode();}
Copy<br>В этом случае боксинг и анбоксинг происходить не будет. Вот более подробно про это -&nbsp;<a data-tooltip-position="top" aria-label="https://learn.microsoft.com/ru-ru/dotnet/api/system.linq.enumerable.union?view=net-7.0" rel="noopener" class="external-link" href="https://learn.microsoft.com/ru-ru/dotnet/api/system.linq.enumerable.union?view=net-7.0" target="_blank">https://learn.microsoft.com…</a><br><br>Агрегатные операции<br><br><br>К агрегатным операциям относят различные операции над выборкой, например, получение числа элементов, получение минимального, максимального и среднего значения в выборке, а также суммирование значений.<br><br>Метод Aggregate выполняет общую агрегацию элементов коллекции в зависимости от указанного выражения. Например:<br>int[] numbers = { 1, 2, 3, 4, 5};int query = numbers.Aggregate((x,y)=&gt; x - y);Console.WriteLine(query);   // -13
Copy<br>Переменная query будет представлять результат агрегации массива. В качестве условия агрегации используется выражение&nbsp;(x,y)=&gt; x - y, то есть вначале из первого элемента вычитается второй, потом из получившегося значения вычитается третий и так далее. То есть будет эквивалентно выражению:<br>int query = 1 - 2 - 3 - 4 - 5
Copy<br>В итоге мы получим число -13. Соответственно мы бы могли использовать любые другие операции, например, сложение:<br>int query = numbers.Aggregate((x,y)=&gt; x + y); // аналогично 1 + 2 + 3 + 4 + 5
Copy<br>Еще одна версия метода позволяет задать начальное значение, с которого начинается цепь агрегатных операций:<br>string[] words = { "Gaudeamus", "igitur", "Juvenes", "dum", "sumus" };var sentence = words.Aggregate("Text:", (first, next) =&gt; $"{first} {next}");Console.WriteLine(sentence);  // Text: Gaudeamus igitur Juvenes dum sumus
Copy<br>В данном случае объединяются все элементы массива words, но первым элемент агрегатной операции будет строка “Text:”.<br><br>Для получения числа элементов в выборке используется метод&nbsp;Count():<br>int[] numbers = { 1, 2, 3, 4, 10, 34, 55, 66, 77, 88 };int size = numbers.Count();  // 10Console.WriteLine(size);
Copy<br>Метод&nbsp;Count()&nbsp;в одной из версий также может принимать лямбда-выражение, которое устанавливает условие выборки. Поэтому мы можем в данном случае не использовать выражение&nbsp;Where:<br>int[] numbers = { 1, 2, 3, 4, 10, 34, 55, 66, 77, 88 };//  количество четных чисел, которые больше 10int size = numbers.Count(i =&gt; i % 2 == 0 &amp;&amp; i &gt; 10);Console.WriteLine(size);    // 3
Copy<br><br>Для получения суммы значений применяется метод&nbsp;Sum:<br>int[] numbers = { 1, 2, 3, 4, 10, 34, 55, 66, 77, 88 };int sum = numbers.Sum();Console.WriteLine(sum);     // 340
Copy<br>Метод&nbsp;Sum()&nbsp;имеет ряд перегрузок. В частности, если у нас набор сложных объектов, как в примере выше, то мы можем указать свойство, значения которого будут суммироваться:<br>Person[] people = { new Person("Tom", 37), new Person("Sam", 28), new Person("Bob", 41) };int ageSum = people.Sum(p =&gt; p.Age);Console.WriteLine(ageSum);     // 106record class Person(string Name, int Age);
Copy<br>В данном случае вычисляется сумма значений свойств Age объектов Person из массива people.<br><br>Для нахождения минимального значения применяется метод&nbsp;Min(), для получения максимального - метод&nbsp;Max(), а для нахождения среднего значения - метод&nbsp;Average(). Их действие похоже на методы Sum и Count:<br>int[] numbers = { 1, 2, 3, 4, 10, 34, 55, 66, 77, 88 };int min = numbers.Min();int max = numbers.Max();double average = numbers.Average();Console.WriteLine($"Min: {min}");           // Min: 1Console.WriteLine($"Max: {max}");           // Max: 88Console.WriteLine($"Average: {average}");   // Average: 34
Copy<br>Если мы работаем со сложными объектами, то в эти методы передается делегат, который принимает свойство, применяемое в вычислениях:<br>Person[] people = { new Person("Tom", 37), new Person("Sam", 28), new Person("Bob", 41) };int minAge = people.Min(p =&gt; p.Age); // минимальный возрастint maxAge = people.Max(p =&gt; p.Age); // максимальный возрастdouble averageAge = people.Average(p =&gt; p.Age); //средний возрастConsole.WriteLine($"Min Age: {minAge}");           // Min Age: 28Console.WriteLine($"Max Age: {maxAge}");           // Max Age: 41Console.WriteLine($"Average Age: {averageAge}");   // Average Age: 35,33record class Person(string Name, int Age);
Copy<br>В данном случае для вычислений применяется свойство Age, то есть вычисляется минимальный, максимальный и средний возраст.<br><br>Группировка<br><br><br>Для группировки данных по определенным параметрам применяется оператор&nbsp;group by&nbsp;и метод&nbsp;GroupBy().<br><br>Допустим, у нас есть набор из объектов следующего типа:<br>record class Person(string Name, string Company);
Copy<br>Данный класс представляет пользователя и имеет два свойства: Name (имя пользователя) и Company (компания, где работает пользователь). Сгруппируем набор пользователей по компании:<br>Person[] people ={    new Person("Tom", "Microsoft"), new Person("Sam", "Google"),    new Person("Bob", "JetBrains"), new Person("Mike", "Microsoft"),    new Person("Kate", "JetBrains"), new Person("Alice", "Microsoft"),};var companies = from person in people                group person by person.Company;foreach(var company in companies){    Console.WriteLine(company.Key);    foreach(var person in company)    {        Console.WriteLine(person.Name);    }    Console.WriteLine(); // для разделения между группами}record class Person(string Name, string Company);
Copy<br>Если в выражении LINQ последним оператором, выполняющим операции над выборкой, является&nbsp;group, то оператор&nbsp;select&nbsp;не применяется.<br>Оператор&nbsp;group&nbsp;принимает критерий по которому проводится группировка:<br>group person by person.Company
Copy<br>в данном случае группировка идет по свойству Company. Результатом оператора&nbsp;group&nbsp;является выборка, которая состоит из групп. Каждая группа представляет объект&nbsp;IGrouping&lt;K, V&gt;: параметр&nbsp;K&nbsp;указывает на тип ключа - тип свойства, по которому идет группировка (здесь это тип string). А параметр&nbsp;V&nbsp;представляет тип сгруппированных объектов - в данном случае группируем объекты Person.<br>Каждая группа имеет ключ, который мы можем получить через свойство Key:&nbsp;g.Key. Здесь это будет название компании.<br>Все элементы внутри группы можно получить с помощью дополнительной итерации. Элементы группы имеют тот же тип, что и тип объектов, которые передавались оператору&nbsp;group, то есть в данном случае объекты типа&nbsp;Person.<br>В итоге мы получим следующий вывод:<br>Microsoft
Tom
Mike
Alice

Google
Sam

JetBrains
Bob
Kate
Copy<br><br>В качестве альтернативы можно использовать метод расширения&nbsp;GroupBy. Он имеет ряд перегрузок, возьмем самую простую из них:<br>GroupBy&lt;TSource,TKey&gt; (Func&lt;TSource,TKey&gt; keySelector);
Copy<br>Данная версия получает делегат, которые в качестве параметра принимает каждый элемент коллекции и возвращает критерий группировки.<br>Перепишем предыдущий пример с помощью метода GroupBy:<br>Person[] people ={    new Person("Tom", "Microsoft"), new Person("Sam", "Google"),    new Person("Bob", "JetBrains"), new Person("Mike", "Microsoft"),    new Person("Kate", "JetBrains"), new Person("Alice", "Microsoft"),};var companies = people.GroupBy(p =&gt; p.Company);foreach(var company in companies){    Console.WriteLine(company.Key);    foreach(var person in company)    {        Console.WriteLine(person.Name);    }    Console.WriteLine(); // для разделения между группами}record class Person(string Name, string Company);
Copy<br><br>Теперь изменим запрос и создадим из группы новый объект:<br>Person[] people ={    new Person("Tom", "Microsoft"), new Person("Sam", "Google"),    new Person("Bob", "JetBrains"), new Person("Mike", "Microsoft"),    new Person("Kate", "JetBrains"), new Person("Alice", "Microsoft"),};var companies = from person in people                group person by person.Company into g                select new { Name = g.Key, Count = g.Count() }; ;foreach(var company in companies){    Console.WriteLine($"{company.Name} : {company.Count}");}record class Person(string Name, string Company);
Copy<br>Выражение<br>group person by person.Company into g
Copy<br>определяет переменную&nbsp;g, которая будет содержать группу. С помощью этой переменной мы можем затем создать новый объект анонимного типа (хотя также можно под данную задачу определить новый класс):<br>select new { Name = g.Key, Count = g.Count() }
Copy<br>Теперь результат запроса LINQ будет представлять набор объектов таких анонимных типов, у которых два свойства Name и Count.<br>Результат программы:<br>Microsoft : 3
Google : 1
JetBrains : 2
Copy<br>Аналогичная операция с помощью метода&nbsp;GroupBy():<br>var companies = people                    .GroupBy(p=&gt;p.Company)                    .Select(g =&gt; new { Name = g.Key, Count = g.Count() });
Copy<br><br>Также мы можем осуществлять вложенные запросы:<br>Person[] people ={    new Person("Tom", "Microsoft"), new Person("Sam", "Google"),    new Person("Bob", "JetBrains"), new Person("Mike", "Microsoft"),    new Person("Kate", "JetBrains"), new Person("Alice", "Microsoft"),};var companies = from person in people                group person by person.Company into g                select new                {                    Name = g.Key,                    Count = g.Count(),                    Employees = from p in g select p                };foreach (var company in companies){    Console.WriteLine($"{company.Name} : {company.Count}");    foreach(var employee in company.Employees)    {        Console.WriteLine(employee.Name);    }    Console.WriteLine(); // для разделения компаний}record class Person(string Name, string Company);
Copy<br>Здесь свойство Employees каждой группы формируется с помощью дополнительного запроса, который выбирает всех пользователей в этой группе. Консольный вывод программы:<br>Microsoft : 3
Tom
Mike
Alice

Google : 1
Sam

JetBrains : 2
Bob
Kate
Copy<br>Аналогичный запрос с помощью метода GroupBy:<br>var companies = people                    .GroupBy(p=&gt;p.Company)                    .Select(g =&gt; new                    {                        Name = g.Key,                        Count = g.Count(),                        Employees = g.Select(p=&gt; p)                    });
Copy<br><br>Соединение коллекций<br><br><br>Соединение в LINQ используется для объединения двух разнотипных наборов в один. Для соединения используется оператор join или метод Join(). Как правило, данная операция применяется к двум наборам, которые имеют один общий критерий.<br><br>Оператор join имеет следующий формальный синтаксис:<br>from объект1 in набор1join объект2 in набор2 on объект2.свойство2 equals объект1.свойство1
Copy<br>После оператора join идет выборка объектов из второй коллекции. После оператора on указывается критерий соединения - свойство объекта из второй выборки, а после оператора equals - свойство объекта из первой выборки, которому должно быть равно свойство объекта из второй выборки. Если эти свойства равны, то оба объекта попадают в финальный результат.<br>Например, у нас есть два класса:<br>record class Person(string Name, string Company);record class Company(string Title, string Language);
Copy<br>Класс Person представляет пользователя и хранит два свойства: Name (имя) и Company (компания пользователя). Класс Company представляет компанию и хранит два свойства: Title (название компании) и Language (основной язык программирования в компании)<br>Объекты обоих классов будет иметь один общий критерий - название компании. Соединим по этому критерию два набора этих классов:<br>Person[] people ={    new Person("Tom", "Microsoft"), new Person("Sam", "Google"),    new Person("Bob", "JetBrains"), new Person("Mike", "Microsoft"),};Company[] companies ={    new Company("Microsoft", "C#"),    new Company("Google", "Go"),    new Company("Oracle", "Java")};var employees = from p in people             join c in companies on p.Company equals c.Title             select new { Name = p.Name, Company = c.Title, Language = c.Language };foreach (var emp in employees)    Console.WriteLine($"{emp.Name} - {emp.Company} ({emp.Language})");record class Person(string Name, string Company);record class Company(string Title, string Language);
Copy<br>В итоге мы получим следующий вывод:<br>Tom - Microsoft (C#)
Sam - Google (Go)
Mike - Microsoft (C#)
Copy<br>Обратите внимание, что в массиве people есть объект new Person("Bob", "JetBrains"), но в массиве компаний компании с именем “JetBrains” нет, соответственно он не попал с результат. Аналогично в списке people нет объектов Person, которые бы соотствовали компании new Company("Oracle", "Java").<br><br>В качестве альтернативы можно было бы использовать метод Join():<br>Join(IEnumerable&lt;TInner&gt; inner,    Func&lt;TOuter,TKey&gt; outerKeySelector,    Func&lt;TInner,TKey&gt; innerKeySelector,    Func&lt;TOuter,TInner,TResult&gt; resultSelector);
Copy<br>Метод Join() принимает четыре параметра:<br>
<br>второй список, который соединяем с текущим
<br>делегат, который определяет свойство объекта из текущего списка, по которому идет соединение
<br>делегат, который определяет свойство объекта из второго списка, по которому идет соединение
<br>делегат, который определяет новый объект в результате соединения
<br>Перепишим предыдущий пример с использованием метода Join:<br>Person[] people ={    new Person("Tom", "Microsoft"), new Person("Sam", "Google"),    new Person("Bob", "JetBrains"), new Person("Mike", "Microsoft"),};Company[] companies ={    new Company("Microsoft", "C#"),    new Company("Google", "Go"),    new Company("Oracle", "Java")};var employees = people.Join(companies, // второй набор             p =&gt; p.Company, // свойство-селектор объекта из первого набора             c =&gt; c.Title, // свойство-селектор объекта из второго набора             (p, c) =&gt; new { Name = p.Name, Company = c.Title, Language = c.Language }); // результатforeach (var emp in employees)    Console.WriteLine($"{emp.Name} - {emp.Company} ({emp.Language})");record class Person(string Name, string Company);record class Company(string Title, string Language);
Copy<br><br>Метод GroupJoin() кроме соединения последовательностей также выполняет и группировку.<br>GroupJoin(IEnumerable&lt;TInner&gt; inner,        Func&lt;TOuter,TKey&gt; outerKeySelector,        Func&lt;TInner,TKey&gt; innerKeySelector,        Func&lt;TOuter, IEnumerable&lt;TInner&gt;,TResult&gt; resultSelector);
Copy<br>Метод GroupJoin() принимает четыре параметра:<br>
<br>второй список, который соединяем с текущим
<br>делегат, который определяет свойство объекта из текущей коллекции, по которому идет соединение и по которому будет идти группировка
<br>делегат, который определяет свойство объекта из второй коллекции, по которому идет соединение
<br>делегат, который определяет новый объект в результате соединения. Этот делегат получает группу - объект текущей коллекции, по которому шла группировка, и набор объектов из второй коллекции, которые сооставляют группу
<br>Например, возьмем выше определенные массивы people и companies и сгуппируем всех пользователей по компаниям:<br>Person[] people ={    new Person("Tom", "Microsoft"), new Person("Sam", "Google"),    new Person("Bob", "JetBrains"), new Person("Mike", "Microsoft"),};Company[] companies ={    new Company("Microsoft", "C#"),    new Company("Google", "Go"),    new Company("Oracle", "Java")};var personnel = companies.GroupJoin(people, // второй набор             c =&gt; c.Title, // свойство-селектор объекта из первого набора             p =&gt; p.Company, // свойство-селектор объекта из второго набора             (c, employees) =&gt; new   // результат             {                 Title = c.Title,                 Employees = employees            });foreach (var company in personnel){    Console.WriteLine(company.Title);    foreach(var emp in company.Employees)    {        Console.WriteLine(emp.Name);    }    Console.WriteLine();}record class Person(string Name, string Company);record class Company(string Title, string Language);
Copy<br>Результатом выполнения программы будет следующий вывод:<br>Microsoft
Tom
Mike

Google
Sam

Oracle
Copy<br>Метод GroupJoin, также как и метод Join, принимает все те же параметры. Только теперь в последний параметр - делегат передаются объект компании и набор пользователей этой компании.<br>Обратите внимание, что для компании “Oracle” в массиве people нет пользователей, хотя для нее также создается группа.<br>Аналогичного результата можно добитьс и с помощью оператора join:<br>var personnel = from c in companies                join p in people on c.Title equals p.Company into g                select new   // результат                {                    Title = c.Title,                    Employees = g                };
Copy<br><br>Метод Zip() последовательно объединяет соответствующие элементы текущей последовательности со второй последовательностью, которая передается в метод в качестве параметра. То есть первый элемент из первой последовательности объединяется с первым элементом из второй последовательности, второй элемент из первой последовательности соединяется со вторым элементом из второй последовательности и так далее. Результатом метода является коллекция кортежей, где каждый кортеж хранит пару соответствующих элементов из обоих последовательностей:<br>var courses = new List&lt;Course&gt; { new Course("C#"), new Course("Java") };var students = new List&lt;Student&gt; { new Student("Tom"), new Student("Bob") };var enrollments = courses.Zip(students);foreach (var enrollment in enrollments)    Console.WriteLine($"{enrollment.First} - {enrollment.Second}");record class Course(string Title);  // учебный курсrecord class Student(string Name);  // студент
Copy<br>Здесь метод Zip объединяет соответствующие элементы из списков courses и students. В результате создается новая коллекция, которая хранит набор кортежей. Каждый кортеж в ней имеет два элемента. Первый элемент из свойства First представляет объект текущей коллекции (в данном случае объект Course), а второй элемент (в свойстве Second) хранит объект второй последовательности (в данном случае объект Student). Консольный вывод:<br>Course { Title = C# } - Student { Name = Tom }
Course { Title = Java } - Student { Name = Bob }
Copy<br><br>Проверка наличия и получение элементов<br><br><br>Ряд методов в LINQ позволяют проверить наличие элементов в коллекции и получить их.<br><br>Метод&nbsp;All()&nbsp;проверяет, соответствуют ли все элементы условию. Если все элементы соответствуют условию, то возвращается true. Например:<br>string[] people = { "Tom", "Tim", "Bob", "Sam" };// проверяем, все ли элементы имеют длину в 3 символаbool allHas3Chars = people.All(s =&gt; s.Length == 3);     // trueConsole.WriteLine(allHas3Chars);// проверяем, все ли строки начинаются на Tbool allStartsWithT = people.All(s =&gt; s.StartsWith("T"));   // falseConsole.WriteLine(allStartsWithT);
Copy<br>В первом случае проверяем, все ли строки в массиве people имеют длину в три символа. Поскольку это условие верно, то метод All возвращает true. Во втором случае смотрим, все ли строки начинаются с буквы “T”. это условие ложно, поэтому метод All возвращает false.<br><br>Метод&nbsp;Any()&nbsp;действует подобным образом, только возвращает true, если хотя бы один элемент коллекции определенному условию:<br>string[] people = { "Tom", "Tim", "Bob", "Sam" };// проверяем, все ли элементы имеют длину больше 3 символовbool allHasMore3Chars = people.Any(s =&gt; s.Length &gt; 3);     // falseConsole.WriteLine(allHasMore3Chars);// проверяем, все ли строки начинаются на Tbool allStartsWithT = people.Any(s =&gt; s.StartsWith("T"));   // trueConsole.WriteLine(allStartsWithT);
Copy<br>Первое выражение вернет&nbsp;false, поскольку все строки имеют длину в 3 символа. Второе выражение возвратит&nbsp;true, так как у нас есть в коллекции есть строки, которые начинаются на букву T.<br><br>Метод&nbsp;Contains()&nbsp;возвращает&nbsp;true, если коллекция содержит определенный элемент.<br>string[] people = { "Tom", "Tim", "Bob", "Sam" };// проверяем, есть ли строка Tombool hasTom = people.Contains("Tom");     // trueConsole.WriteLine(hasTom);// проверяем, есть ли строка Mikebool hasMike = people.Contains("Mike");     // falseConsole.WriteLine(hasMike);
Copy<br>Стоит отметить, что для сравнения объектов применяется реализация метода Equals. Соответственно если мы работаем с объектами своих типов, то мы можем реализовать данный метод:<br>Person[] people = { new Person("Tom"), new Person("Sam"), new Person("Bob")};var tom = new Person("Tom");var mike = new Person("Mike");// проверяем, есть ли Tombool hasTom = people.Contains(tom);     // trueConsole.WriteLine(hasTom);// проверяем, есть ли строка Mikebool hasMike = people.Contains(mike);     // falseConsole.WriteLine(hasMike);class Person{    public string Name { get;}    public Person(string name) =&gt; Name = name;    public override bool Equals(object? obj)    {        if (obj is Person person) return Name == person.Name;        return false;    }    public override int GetHashCode() =&gt; Name.GetHashCode();}
Copy<br>Но стоит отметить, что Contains не всегда может вернуть ожидаемые данные. Например:<br>string[] people = { "tom", "Tim", "bOb", "Sam" };// проверяем, есть ли строка Tombool hasTom = people.Contains("Tom");     // falseConsole.WriteLine(hasTom);// проверяем, есть ли строка Bobbool hasMike = people.Contains("Bob");     // falseConsole.WriteLine(hasMike);
Copy<br>В данном случае в массиве нет строки “Tom”, а есть строка “tom”. Поэтому вызов&nbsp;people.Contains("Tom")&nbsp;возвратит false. Но подобное поведение не всегда может быть желательным. И в этом случае мы можем задать логику сравнения с помощью реализации интерфейса IComparer и затем передать ее в качестве второго параметра в метод Contains:<br>using System.Diagnostics.CodeAnalysis;string[] people = { "tom", "Tim", "bOb", "Sam" };// проверяем, есть ли строка Tombool hasTom = people.Contains("Tom", new CustomStringComparer());     // trueConsole.WriteLine(hasTom);// проверяем, есть ли строка Bobbool hasMike = people.Contains("Bob", new CustomStringComparer());     // trueConsole.WriteLine(hasMike);class CustomStringComparer : IEqualityComparer&lt;string&gt;{    public bool Equals(string? x, string? y)    {        if (x is null || y is null) return false;        return x.ToLower() == y.ToLower();    }    public int GetHashCode(string obj) =&gt; obj.ToLower().GetHashCode();}
Copy<br>Интерфейс IEqualityComparer типизируется типом сравниваемых данных (в данном случае типом String). Для реализации этого интерфейса необходимо определить методы Equals и GetHashCode. В методе Equals сравниваем строки в нижнем регистре, а в методе GetHashCode возвращаем возвращаем хеш-код строки в нижнем регистре.<br><br>Метод&nbsp;First()&nbsp;возвращает первый элемент последовательности:<br>string[] people = { "Tom", "Bob", "Tim", "Sam" };// проверяем, есть ли строка Tomvar first = people.First();  // TomConsole.WriteLine(first);
Copy<br>Также в метод First можно передать метод, который представляет условие. В этом случае метод возвращает первый элемент, который соответствует условию:<br>string[] people = { "Tom", "Bob", "Kate", "Tim", "Mike", "Sam" };// первая строка, длина которой равна 4 символамvar firstWith4Chars = people.First(s=&gt; s.Length == 4);  // KateConsole.WriteLine(firstWith4Chars);
Copy<br>Здесь выбираем первый элемент, длина которого - 4 символа.<br>Стоит учитывать, что если коллекция пуста или в коллекции нет элементов, который соответствуют условию, то будет сгенерировано исключение.<br>string[] people = { "Tom", "Bob", "Kate", "Tim", "Mike", "Sam" };// первая строка, длина которой равна 5 символамvar firstWith5Chars = people.First(s =&gt; s.Length == 5);  // ! исключениеConsole.WriteLine(firstWith5Chars);var first = new string[] {}.First();  // ! исключениеConsole.WriteLine(first);
Copy<br><br>Метод&nbsp;FirstOrDefault()&nbsp;также возвращает первый элемент и также может принимать условие, только если коллекция пуста или в коллекции не окажется элементов, которые соответствуют условию, то метод возвращает значение по умолчанию:<br>string[] people = { "Tom", "Bob", "Kate", "Tim", "Mike", "Sam" };// первый элементvar first = people.FirstOrDefault();  // TomConsole.WriteLine(first);// первая строка, длина которой равна 4 символамvar firstWith4Chars = people.FirstOrDefault(s =&gt; s.Length == 4);  // KateConsole.WriteLine(firstWith4Chars);// первый элемент из пустой коллекцииvar firstOrDefault = new string[] {}.FirstOrDefault();Console.WriteLine(firstOrDefault);  // null
Copy<br>Стоит учитывать, что для коллекций ссылочных типов FirstOrDefault возвращает значение типа T? (в примере выше - string?), то есть значение, которое может быть равно null, а значение по умолчанию - null. Для коллекций числовых типов возвращается непосредственно значение типа T, а значение по умолчанию - 0.<br>Но мы можем настроить значение по умолчанию, передав его в качестве одного из аргументов:<br>string[] people = { "Tom", "Bob", "Kate", "Tim", "Mike", "Sam" };string? firstWith5Chars = people.FirstOrDefault(s =&gt; s.Length == 5, "Undefined");Console.WriteLine(firstWith5Chars); // Undefined// первый элемент из пустой коллекции строкstring? firstOrDefault = new string[] {}.FirstOrDefault("hello"); // hello - значение по умолчаниюConsole.WriteLine(firstOrDefault);  // hello// первый элемент из пустой коллекции intint firstNumber = new int[] {}.FirstOrDefault(100); // 100 - значение по умолчаниюConsole.WriteLine(firstNumber); // 100
Copy<br><br>Метод&nbsp;Last()&nbsp;аналогичен по работе методу First, только возвращает последний элемент. Если коллекция не содержит элемент, который соответствуют условию, или вообще пуста, то метод генерирует исключение.<br>string[] people = { "Tom", "Bob", "Kate", "Tim", "Mike", "Sam" };string last = people.Last();Console.WriteLine(last); // Samstring lastWith4Chars = people.Last(s =&gt; s.Length == 4);Console.WriteLine(lastWith4Chars); // Mike
Copy<br>Метод&nbsp;LastOrDefault()&nbsp;возвращает последний элемент или значение по умолчанию, если коллекция не содержит элемент, который соответствуют условию, или вообще пуста:<br>string[] people = { "Tom", "Bob", "Kate", "Tim", "Mike", "Sam" };string? last = people.LastOrDefault();Console.WriteLine(last); // Samstring? lastWith4Chars = people.LastOrDefault(s =&gt; s.Length == 4);Console.WriteLine(lastWith4Chars); // Mikestring? lastWith5Chars = people.LastOrDefault(s =&gt; s.Length == 5);Console.WriteLine(lastWith5Chars); // nullstring? lastWith5CharsOrDefault = people.LastOrDefault(s =&gt; s.Length == 5, "Undefined");Console.WriteLine(lastWith5CharsOrDefault); // Undefined// первый элемент из пустой коллекции строкstring? lastOrDefault = new string[] {}.LastOrDefault("hello");Console.WriteLine(lastOrDefault);  // hello
Copy<br><br>Отложенное и немедленное выполнение LINQ<br><br><br>Есть два способа выполнения запроса LINQ:&nbsp;отложенное&nbsp;(deferred) и&nbsp;немедленное&nbsp;(immediate) выполнение.<br>При отложенном выполнении LINQ-выражение не выполняется, пока не будет произведена итерация или перебор по выборке, например, в цикле foreach. Обычно подобные операции возвращают объект&nbsp;IEnumerable&lt;T&gt;&nbsp;или&nbsp;IOrderedEnumerable&lt;T&gt;. Полный список отложенных операций LINQ:<br>
<br>AsEnumerable
<br>Cast
<br>Concat
<br>DefaultIfEmpty
<br>Distinct
<br>Except
<br>GroupBy
<br>GroupJoin
<br>Intersect
<br>Join
<br>OfType
<br>OrderBy
<br>OrderByDescending
<br>Range
<br>Repeat
<br>Reverse
<br>Select
<br>SelectMany
<br>Skip
<br>SkipWhile
<br>Take
<br>TakeWhile
<br>ThenBy
<br>ThenByDescending
<br>Union
<br>Where
<br>Рассмотрим отложенное выполнение:<br>string[] people = { "Tom", "Sam", "Bob" };var selectedPeople = people.Where(s=&gt;s.Length == 3).OrderBy(s=&gt;s);// выполнение LINQ-запросаforeach (string s in selectedPeople)    Console.WriteLine(s);
Copy<br>То есть фактическое выполнение запроса происходит не в строке определения:&nbsp;var selectedPeople = people.Where..., а при переборе в цикле foreach.<br>Фактически LINQ-запрос разбивается на три этапа:<br>
<br>Получение источника данных
<br>Создание запроса
<br>Выполнение запроса и получение его результатов
<br>Как это происходит в нашем случае:<br>
<br>Получение источника данных - определение массива teams:
<br>string[] people = { "Tom", "Sam", "Bob" };
Copy<br>
<br>Создание запроса - определение переменной selectedTeams:
<br>var selectedPeople = people.Where(s=&gt;s.Length == 3).OrderBy(s=&gt;s);
Copy<br>
<br>Выполнение запроса и получение его результатов:
<br>foreach (string s in selectedPeople)    Console.WriteLine(s);
Copy<br>После определения запроса он может выполняться множество раз. И до выполнения запроса источник данных может изменяться. Чтобы более наглядно увидеть это, мы можем изменить какой-либо элемент до перебора выборки:<br>string[] people = { "Tom", "Sam", "Bob" };var selectedPeople = people.Where(s=&gt;s.Length == 3).OrderBy(s=&gt;s);people[2] = "Mike";// выполнение LINQ-запросаforeach (string s in selectedPeople)    Console.WriteLine(s);
Copy<br>Теперь выборка будет содержать два элемента, а не три, так как последний элемент после изменения не будет соответствовать условию.<br>Важно понимать, что переменная запроса сама по себе не выполняет никаких действий и не возвращает никаких данных. Она только хранит набор команд, которые необходимы для получения результатов. То есть выполнение запроса после его создания откладывается. Само получение результатов производится при переборе в цикле foreach.<br><br>С помощью ряда методов мы можем применить немедленное выполнение запроса. Это методы, которые возвращают одно атомарное значение или один элемент или данные типов Array, List и Dictionary. Полный список подобных операций в LINQ:<br>
<br>Aggregate
<br>All
<br>Any
<br>Average
<br>Contains
<br>Count
<br>ElementAt
<br>ElementAtOrDefault
<br>Empty
<br>First
<br>FirstOrDefault
<br>Last
<br>LastOrDefault
<br>LongCount
<br>Max
<br>Min
<br>SequenceEqual
<br>Single
<br>SingleOrDefault
<br>Sum
<br>ToArray
<br>ToDictionary
<br>ToList
<br>ToLookup
<br>Рассмотрим пример с методом&nbsp;Count(), который возвращает число элементов последовательности:<br>string[] people = { "Tom", "Sam", "Bob" };// определение и выполнение LINQ-запросаvar count = people.Where(s=&gt;s.Length == 3).OrderBy(s=&gt;s).Count();Console.WriteLine(count);   // 3 - до изменения коллекцииpeople[2] = "Mike";Console.WriteLine(count);   // 3 - после изменения коллекции
Copy<br>Результатом метода Count будет объект&nbsp;int, поэтому сработает немедленное выполнение.<br>Сначала создается запрос:&nbsp;people.Where(s=&gt;s.Length == 3).OrderBy(s=&gt;s). Далее к нему применяется метод&nbsp;Count(), который выполняет запрос, неявно выполняет перебор по последовательности элементов, генерируемой этим запросом, и возвращает число элементов в этой последовательности.<br>Также мы можем изменить код таким образом, чтобы метод&nbsp;Count()&nbsp;учитывал изменения и выполнялся отдельно от определения запроса:<br>string[] people = { "Tom", "Sam", "Bob" };
// определение LINQ-запроса
var selectedPeople = people.Where(s=&gt;s.Length == 3).OrderBy(s=&gt;s);
// выполнение запроса
Console.WriteLine(selectedPeople.Count());   
// 3 - до изменения коллекции
people[2] = "Mike";
// выполнение запроса
Console.WriteLine(selectedPeople.Count());   
// 2 - после изменения коллекции
Copy<br>Также для немедленного выполнения LINQ-запроса и кэширования его результатов мы можем применять методы преобразования&nbsp;ToArray&lt;T&gt;(),&nbsp;ToList&lt;T&gt;(),&nbsp;ToDictionary()&nbsp;и т.д.. Эти методы получают результат запроса в виде объектов Array, List и Dictionary соответственно. Например:<br>string[] people = { "Tom", "Sam", "Bob" };
// определение и выполнение LINQ-запроса
var selectedPeople = people
	.Where(s=&gt;s.Length == 3).OrderBy(s=&gt;s)
	.ToList(); // изменение массива никак не затронет список selectedPeoplepeople[2] = "Mike";
	// выполнение запроса
foreach (string s in selectedPeople)    
	Console.WriteLine(s);
Copy<br><br>Делегаты в запросах LINQ<br><br><br>Если мы обратимся к определению многих методов расширений LINQ, то увидим, что в качестве параметра многие из них принимают делегаты например,&nbsp;Func&lt;TSource, bool&gt;, например, определение метода Where:<br>public static IEnumerable&lt;TSource&gt; Where&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, bool&gt; predicate)
Copy<br>Хотя, как правило, в качестве делегата в подобные методы удобно передавать лямбда-выражения. Но тем не менее мы также можем передать полноценные методы. Например:<br>string[] people = { "Tom", "Bob", "Kate", "Tim", "Mike", "Sam" };
var result = people.Where(LenghtIs3);
foreach (var person in result)
	Console.WriteLine(person);
bool LenghtIs3(string name) =&gt; name.Length == 3;
Copy<br>Здесь метод LenghtIs3 проверяет, равна ли длина строки 3 символам. Так как в данном случае набор элементов, к которому применяется метод Where, содержит объекты string, то в метод в качестве параметра передается объект этого типа. Возвращаемый тип должен представлять тип&nbsp;bool: если true, то объект string соответствует условию и попадает в выходную коллекцию.<br>Рассмотрим другой пример. Пусть метод&nbsp;Select()&nbsp;применяется к коллекции целых чисел и преобразует каждое число в его квадрат:<br>int[] numbers = { -2, -1, 0, 1, 2, 3, 4, 5, 6, 7 };
var result = numbers.Where(i =&gt; i &gt; 0).Select(Square);
foreach (int i in result)    
	Console.WriteLine(i);
int Square(int n) =&gt; n * n;
Copy<br>Метод Select в качестве параметра принимает тип&nbsp;Func&lt;TSource, TResult&gt; selector. Так как у нас набор объектов&nbsp;int, то входным параметром делегата также будет объект типа int. В качестве типа выходного параметра выберем int, так как здесь квадрат числа - это целочисленное значение.]]></description><link>04.-literature-notes/linq-by-metanit/linq-by-metanit.html</link><guid isPermaLink="false">04. Literature Notes/LINQ by Metanit/LINQ by Metanit.md</guid><pubDate>Thu, 09 May 2024 11:27:21 GMT</pubDate></item><item><title><![CDATA[Coverlet - Analyze code coverage]]></title><description><![CDATA[ 
 <br>URL <a rel="noopener" class="external-link" href="https://github.com/coverlet-coverage/coverlet#quick-start" target="_blank">https://github.com/coverlet-coverage/coverlet#quick-start</a><br><br><br><br>dotnet add package coverlet.msbuild
Copy<br>N.B. You&nbsp;MUST&nbsp;add package only to test projects<br><br>Coverlet also integrates with the build system to run code coverage after tests. Enabling code coverage is as simple as setting the&nbsp;CollectCoverage&nbsp;property to&nbsp;true<br>dotnet test /p:CollectCoverage=true
Copy<br>After the above command is run, a&nbsp;coverage.json&nbsp;file containing the results will be generated in the root directory of the test project. A summary of the results will also be displayed in the terminal.]]></description><link>04.-literature-notes/coverlet-analyze-code-coverage.html</link><guid isPermaLink="false">04. Literature Notes/Coverlet - Analyze code coverage.md</guid><pubDate>Wed, 08 May 2024 22:09:24 GMT</pubDate></item><item><title><![CDATA[CSharp MSTest by zetcode.com]]></title><description><![CDATA[ 
 <br>URL: <a rel="noopener" class="external-link" href="https://zetcode.com/all/#csharp" target="_blank">https://zetcode.com/all/#csharp</a><br>C Sharp MSTest tutorial shows how to do unit testing in C Sharp with MSTest framework.<br>Unit testing is a software testing where individual units (components) of a software are tested. The purpose of unit testing is to validate that each unit of the software performs as designed. A unit is the smallest testable part of any software.<br>MSTest is a unit-testing library from Microsoft. It is available for all .NET languages. There are other unit-testing libraries including XUnit and NUnit.<br>We can either place tests in the same project directory or inside a different directory. We start with a simpler option and place tests in the same project directory. In the end, we place tests in a different directory within a solution.<br>$ dotnet add package Microsoft.NET.Test.Sdk
$ dotnet add package MSTest.TestAdapter
$ dotnet add package MSTest.TestFramework

Copy<br>In order to use MSTest, we need to add these three libraries.<br><br>We start with a simple example.<br>Arith.cs<br>namespace Messages.Services;

public class Messages
{
    public static Func&lt;string&gt; msg1 = () =&gt; "Hello there!";
    public static Func&lt;string&gt; msg2 = () =&gt; "Good Morning!";
}

Copy<br>We test simple message functions.<br>We put our tests into the tests directory. MSTest automatically discovers our tests.<br>tests/MessageTest.cs<br>namespace Messages.Tests;

using Microsoft.VisualStudio.TestTools.UnitTesting;
using Messages.Services;

[TestClass]
public class MessageTest
{
    private const string Expected1 = "Hello there!";
    private const string Expected2 = "Good Morning!";

    [TestMethod]
    public void Message1()
    {
        var m1 = Messages.msg1();

        Assert.AreEqual(Expected1, m1);
    }

    [TestMethod]
    public void Message2()
    {
        var m2 = Messages.msg2();

        Assert.AreEqual(Expected2, m2);
    }
}

Copy<br>The class is annotated with the [TestClass] attribute, the test methods are annotated with the [TestMethod] attribute. We use assertions to ensure the correct output.<br>$ dotnet test
...
Starting test execution, please wait...
A total of 1 test files matched the specified pattern.

Passed!  - Failed:     0, Passed:     2, Skipped:     0, Total:     2, ...

Copy<br><br>The [DataTestMethod] attribute indicates a parameterized method. The parameters are added with the [DataRow] attribute.<br>Arith.cs<br>namespace Arithmetic.Services;

public class Basic
{
    public static Func&lt;int, int, int&gt; add = (a, b) =&gt; a + b;
    public static Func&lt;int, int, int&gt; mul = (a, b) =&gt; a * b;
    public static Func&lt;int, int, int&gt; sub = (a, b) =&gt; a - b;
    public static Func&lt;int, int, int&gt; div = (a, b) =&gt; a / b;
}

Copy<br>We are going to test simple arithmetic functions.<br>tests/ArithTest.cs<br>namespace Messages.Tests;

using Microsoft.VisualStudio.TestTools.UnitTesting;
using Arithmetic.Services;

[TestClass]
public class ArithTest
{
    [DataTestMethod]
    [DataRow(1, 2, 3)]
    [DataRow(2, 2, 4)]
    [DataRow(-1, 4, 3)]
    public void Add(int x, int y, int expected)
    {
        int r = Basic.add(x, y);
        Assert.AreEqual(r, expected);
    }

    [DataTestMethod]
    [DataRow(1, 2, -1)]
    [DataRow(2, 2, 0)]
    [DataRow(3, 2, 1)]
    public void Sub(int x, int y, int expected)
    {
        int r = Basic.sub(x, y);
        Assert.AreEqual(r, expected);
    }

    [DataTestMethod]
    [DataRow(9, 3, 27)]
    [DataRow(3, 3, 9)]
    [DataRow(-3, -3, 9)]
    public void Mul(int x, int y, int expected)
    {
        int r = Basic.mul(x, y);
        Assert.AreEqual(r, expected);
    }

    [DataTestMethod]
    [DataRow(9, 3, 3)]
    [DataRow(3, 3, 1)]
    [DataRow(8, 2, 4)]
    public void Div(int x, int y, int expected)
    {
        int r = Basic.div(x, y);
        Assert.AreEqual(r, expected);
    }
}

Copy<br>In this example, we test each method with three sets of values.<br>[DataTestMethod]
[DataRow(1, 2, 3)]
[DataRow(2, 2, 4)]
[DataRow(-1, 4, 3)]
public void Add(int x, int y, int expected)
{
    int r = Basic.add(x, y);
    Assert.AreEqual(r, expected);
}

Copy<br>We are testing the Add method. The method is tested with three sets of values given by the [DataRow] attribute. The calculated and expected values are compared with Assert.AreEqual assertion.<br><br>Test methods can be skipped with [Ignore] attribute.<br>tests/ArithTest.cs<br>namespace Arithmetic.Tests;

using Microsoft.VisualStudio.TestTools.UnitTesting;
using Arithmetic.Services;

[TestClass]
public class ArithTest
{
    [DataRow(1, 2, 3)]
    [DataRow(2, 2, 4)]
    [DataRow(-1, 4, 3)]
    [DataTestMethod]
    public void Add(int x, int y, int z)
    {
        int r = Basic.add(x, y);
        Assert.AreEqual(r, z);
    }

    [DataTestMethod]
    [DataRow(1, 2, -1)]
    [DataRow(2, 2, 0)]
    [DataRow(3, 2, 1)]
    public void Sub(int x, int y, int z)
    {
        int r = Basic.sub(x, y);
        Assert.AreEqual(r, z);
    }

    [DataTestMethod]
    [DataRow(9, 3, 27)]
    [DataRow(3, 3, 9)]
    [DataRow(-3, -3, 9)]
    [Ignore]
    public void Mul(int x, int y, int z)
    {
        int r = Basic.mul(x, y);
        Assert.AreEqual(r, z);
    }

    [DataTestMethod]
    [DataRow(9, 3, 3)]
    [DataRow(3, 3, 1)]
    [DataRow(8, 2, 4)]
    [Ignore]
    public void Div(int x, int y, int z)
    {
        int r = Basic.div(x, y);
        Assert.AreEqual(r, z);
    }
}

Copy<br>We have four test methods. Two of them are skipped using the [Ignore] attribute.<br>$ dotnet test
...
Starting test execution, please wait...
A total of 1 test files matched the specified pattern.
  Skipped Mul (9,3,27)
  Skipped Mul (3,3,9)
  Skipped Mul (-3,-3,9)
  Skipped Div (9,3,3)
  Skipped Div (3,3,1)
  Skipped Div (8,2,4)

Passed!  - Failed:     0, Passed:     6, Skipped:     6, Total:    12, Duration: 84 ms ...

Copy<br><br>With [DynamicData] attribute, we can externalize the test data into a method or a property.<br>tests/ArithTest.cs<br>namespace Messages.Tests;

using Microsoft.VisualStudio.TestTools.UnitTesting;
using Arithmetic.Services;

[TestClass]
public class Tests
{
    [DataTestMethod]
    [DynamicData(nameof(AddData), DynamicDataSourceType.Method)]
    public void Add(int x, int y, int expected)
    {
        int r = Basic.add(x, y);
        Assert.AreEqual(r, expected);
    }

    [DataTestMethod]
    [DynamicData(nameof(SubData), DynamicDataSourceType.Method)]
    public void Sub(int x, int y, int expected)
    {
        int r = Basic.sub(x, y);
        Assert.AreEqual(r, expected);
    }

    [DataTestMethod]
    [DynamicData(nameof(MulData), DynamicDataSourceType.Method)]
    public void Mul(int x, int y, int expected)
    {
        int r = Basic.mul(x, y);
        Assert.AreEqual(r, expected);
    }

    [DataTestMethod]
    [DynamicData(nameof(DivData), DynamicDataSourceType.Method)]
    public void Div(int x, int y, int expected)
    {
        int r = Basic.div(x, y);
        Assert.AreEqual(r, expected);
    }

    private static IEnumerable&lt;object[]&gt; AddData()
    {
        return new[]
        {
            new object[] { 1, 2, 3 },
            new object[] { 2, 2, 4 },
            new object[] { -1, 4, 3 }
        };
    }

    private static IEnumerable&lt;object[]&gt; SubData()
    {
        return new[]
        {
            new object[] { 1, 2, -1 },
            new object[] { 2, 2, 0 },
            new object[] { 3, 2, 1 }
        };
    }

    private static IEnumerable&lt;object[]&gt; MulData()
    {
        return new[]
        {
            new object[] { 9, 3, 27 },
            new object[] { 3, 3, 9 },
            new object[] { -3, -3, 9 }
        };
    }

    private static IEnumerable&lt;object[]&gt; DivData()
    {
        return new[]
        {
            new object[] { 9, 3, 3 },
            new object[] { 3, 3, 1 },
            new object[] { 8, 2, 4 }
        };
    }
}

Copy<br>In the example, we have test data in separate methods.<br><br>In the following example, we show how to place tests in a separate directory.<br>$ mkdir Separate
$ cd Separate
Copy<br>We create a new directory.<br>$ dotnet new sln
Copy<br>We create a new empty solution.<br>$ mkdir PalindromeService PalindromeService.Tests
Copy<br>Two directories are created.<br>$ cd PalindromeService
$ dotnet new classlib
Copy<br>We create a new library.<br>PalindromeService\\\\PalindromeService.cs<br>namespace Palindrome.Services;

using System.Globalization;

public class PalindromeService
{
    public bool IsPalindrome(string word)
    {
        IEnumerable&lt;string&gt; GraphemeClusters(string s)
        {
            var enumerator = StringInfo.GetTextElementEnumerator(s);
            while (enumerator.MoveNext())
            {
                yield return (string)enumerator.Current;
            }
        }

        var reversed = string.Join("", GraphemeClusters(word).Reverse().ToArray());

        return reversed == word;
    }
}

Copy<br>The PalindromeService contains the IsPalindrome method, which determines if a words is a palindrome.<br>$ cd ..
$ dotnet sln add PalindromeService\\PalindromeService.csproj
Copy<br>We add the PalindromeService to the solution.<br>$ cd PalindromeService.Tests
$ dotnet new mstest
$ dotnet add reference ..\\PalindromeService\\PalindromeService.csproj
Copy<br>We go to the PalindromeService.Tests directory and add the unit libraries add the reference to the PalindromeService.<br>PalindromeService.Tests\\\\PalindromeService.Tests.csproj<br>&lt;Project Sdk="Microsoft.NET.Sdk"&gt;

  &lt;PropertyGroup&gt;
    &lt;TargetFramework&gt;net6.0&lt;/TargetFramework&gt;
    &lt;Nullable&gt;enable&lt;/Nullable&gt;

    &lt;IsPackable&gt;false&lt;/IsPackable&gt;
  &lt;/PropertyGroup&gt;

  &lt;ItemGroup&gt;
    &lt;PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.1.0" /&gt;
    &lt;PackageReference Include="MSTest.TestAdapter" Version="2.2.8" /&gt;
    &lt;PackageReference Include="MSTest.TestFramework" Version="2.2.8" /&gt;
  &lt;/ItemGroup&gt;

  &lt;ItemGroup&gt;
    &lt;ProjectReference Include="..\\PalindromeService\\PalindromeService.csproj" /&gt;
  &lt;/ItemGroup&gt;
&lt;/Project&gt;

Copy<br>This is how the project file looks like.<br>PalindromeService.Tests\\\\Tests.cs<br>namespace Palindrome.Services.Tests;

using Microsoft.VisualStudio.TestTools.UnitTesting;

[TestClass]
public class Tests
{
    private PalindromeService? _palindromeService;

    [TestInitialize]
    public void SetUp()
    {
        _palindromeService = new PalindromeService();
    }

    [DataTestMethod]
    [DataRow("racecar")]
    [DataRow("level")]
    [DataRow("nun")]
    public void IsPalindrome(string word)
    {
        var r = _palindromeService!.IsPalindrome(word);
        Assert.AreEqual(r, true);
    }
}

Copy<br>We test the IsPalindrome method with three words.<br>[TestInitialize]
public void SetUp()
{
    _palindromeService = new PalindromeService();
}

Copy<br>The [TestInitialize] attribute is used to provide a common set of functions that are performed just before each test method is called. In our case, we create the PalindromeService.<br>$ cd ..
$ dotnet sln add PalindromeService.Tests\\PalindromeService.Tests.csproj
Copy<br>We add the test project to the solution.<br>$ dotnet test
Copy<br>Finally, we can run the tests.<br>In this article we have done unit testing in C Sharp with MSTest library.<br>My name is Jan Bodnar and I am a passionate programmer with many years of programming experience. I have been writing programming articles since 2007. So far, I have written over 1400 articles and 8 e-books. I have over eight years of experience in teaching programming.<br>List <a data-tooltip-position="top" aria-label="https://zetcode.com/all/#csharp" rel="noopener" class="external-link" href="https://zetcode.com/all/#csharp" target="_blank">all C Sharp tutorials</a>.]]></description><link>04.-literature-notes/csharp-mstest-by-zetcode.com.html</link><guid isPermaLink="false">04. Literature Notes/CSharp MSTest by zetcode.com.md</guid><pubDate>Wed, 08 May 2024 21:54:19 GMT</pubDate></item><item><title><![CDATA[Doxygen & Graphviz]]></title><description><![CDATA[ 
 <br>Generate documentations for projects.<br><a rel="noopener" class="external-link" href="https://graphviz.org/download/" target="_blank">https://graphviz.org/download/</a><br><a rel="noopener" class="external-link" href="https://www.doxygen.nl/download.html" target="_blank">https://www.doxygen.nl/download.html</a><br>html template for a better view:  <br>Doxygen Awesome
Custom CSS theme for doxygen html-documentation with lots of customization parameters.<br>
<a rel="noopener" class="external-link" href="https://jothepro.github.io/doxygen-awesome-css/" target="_blank">https://jothepro.github.io/doxygen-awesome-css/</a>
]]></description><link>04.-literature-notes/doxygen-&amp;-graphviz.html</link><guid isPermaLink="false">04. Literature Notes/Doxygen &amp; Graphviz.md</guid><pubDate>Wed, 08 May 2024 22:10:19 GMT</pubDate></item><item><title><![CDATA[Functional Error Handling in .NET With the Result Pattern]]></title><description><![CDATA[ 
 <br><img alt="Functional Error Handling in .NET With the Result Pattern-240509-1.jpg" src="lib/media/functional-error-handling-in-.net-with-the-result-pattern-240509-1.jpg"><br>Thank you to our sponsors who keep this newsletter free to the reader:<br><a data-tooltip-position="top" aria-label="https://www.telerik.com/campaigns/maui/migration-to-dot-net-maui?utm_medium=cpm&amp;utm_source=milanjovanovic&amp;utm_campaign=maui-ebook-mnm-na" rel="noopener" class="external-link" href="https://www.telerik.com/campaigns/maui/migration-to-dot-net-maui?utm_medium=cpm&amp;utm_source=milanjovanovic&amp;utm_campaign=maui-ebook-mnm-na" target="_blank"><strong></strong></a>Progress prepared a free eBook for you - <a data-tooltip-position="top" aria-label="https://www.telerik.com/campaigns/maui/migration-to-dot-net-maui?utm_medium=cpm&amp;utm_source=milanjovanovic&amp;utm_campaign=maui-ebook-mnm-na" rel="noopener" class="external-link" href="https://www.telerik.com/campaigns/maui/migration-to-dot-net-maui?utm_medium=cpm&amp;utm_source=milanjovanovic&amp;utm_campaign=maui-ebook-mnm-na" target="_blank"><strong></strong></a>Migration to .NET MAUI. Do you plan to start your first cross-platform app with .NET MAUI? You're in the right place. This eBook will help you examine the benefits of using .NET MAUI for the dev experience, the app and its end users, plus any downsides. <a data-tooltip-position="top" aria-label="https://www.telerik.com/campaigns/maui/migration-to-dot-net-maui?utm_medium=cpm&amp;utm_source=milanjovanovic&amp;utm_campaign=maui-ebook-mnm-na" rel="noopener" class="external-link" href="https://www.telerik.com/campaigns/maui/migration-to-dot-net-maui?utm_medium=cpm&amp;utm_source=milanjovanovic&amp;utm_campaign=maui-ebook-mnm-na" target="_blank"><strong></strong></a>Grab the free MAUI eBook here.<br><a data-tooltip-position="top" aria-label="https://u.icepanel.io/1eec0e6f" rel="noopener" class="external-link" href="https://u.icepanel.io/1eec0e6f" target="_blank"><strong></strong></a>IcePanel is a collaborative C4 model modelling &amp; diagramming tool that helps explain complex software systems. With an interactive map, you can align your software engineering &amp; product teams on technical decisions across the business. <a data-tooltip-position="top" aria-label="https://u.icepanel.io/1eec0e6f" rel="noopener" class="external-link" href="https://u.icepanel.io/1eec0e6f" target="_blank"><strong></strong></a>Check it out here.<br>How should you handle errors in your code?<br>This has been a topic of many discussions, and I want to share my opinion.<br>One school of thought suggests using exceptions for flow control. This is not a good approach because it makes the code harder to reason about. The caller must know the implementation details and which exceptions to handle.<br>Exceptions are for exceptional situations.<br>Today, I want to show you how to implement error handling using the Result pattern.<br>It's a functional approach to error handling, making your code more expressive.<br><br>Using exceptions for flow control is an approach to implement the fail-fast principle.<br>As soon as you encounter an error in the code, you throw an exception — effectively terminating the method, and making the caller responsible for handling the exception.<br>The problem is the caller must know which exceptions to handle. And this isn't obvious from the method signature alone.<br>Another common use case is throwing exceptions for validation errors.<br>Here's an example in the FollowerService:<br>public sealed class FollowerService
{
    private readonly IFollowerRepository _followerRepository;

    public FollowerService(IFollowerRepository followerRepository)
    {
        _followerRepository = followerRepository;
    }

    public async Task StartFollowingAsync(
        User user,
        User followed,
        DateTime createdOnUtc,
        CancellationToken cancellationToken = default)
    {
        if (user.Id  followed.Id)
        {
            throw new DomainException("Can't follow yourself");
        }

        if (!followed.HasPublicProfile)
        {
            throw new DomainException("Can't follow non-public profile");
        }

        if (await _followerRepository.IsAlreadyFollowingAsync(
                user.Id,
                followed.Id,
                cancellationToken))
        {
            throw new DomainException("Already following");
        }

        var follower = Follower.Create(user.Id, followed.Id, createdOnUtc);

        _followerRepository.Insert(follower);
    }
}
Copy<br><br>A rule of thumb I follow is to use exceptions for exceptional situations. Since you already expect potential errors, why not make it explicit?<br>You can group all application errors into two groups:<br>
<br>Errors you know how to handle
<br>Errors you don't know how to handle
<br>Exceptions are an excellent solution for the errors you don't know how to handle. And you should catch and handle them at the lowest level possible.<br>What about the errors you know how to handle?<br>You can handle them in a functional way with the Result pattern. It's explicit and clearly expresses the intent that the method can fail. The drawback is the caller has to manually check if the operation failed.<br><br>The first thing you will need is an Error class to represent application errors.<br>
<br>Code - unique name for the error in the application
<br>Description - contains developer-friendly details about the error
  public sealed record Error(string Code, string Description)<br>
{<br>
public static readonly Error None = new(string.Empty, string.Empty);<br>
}  
<br>Then, you can implement the Result class using the Error to describe the failure. This implementation is very bare-bones, and you could add many more features. In most cases, you also need a generic Result&lt;T&gt; class, which will wrap a value inside.<br>Here's what the Result class looks like:<br>public class Result
{
    private Result(bool isSuccess, Error error)
    {
        if (isSuccess &amp;&amp; error != Error.None ||
            !isSuccess &amp;&amp; error  Error.None)
        {
            throw new ArgumentException("Invalid error", nameof(error));
        }

        IsSuccess = isSuccess;
        Error = error;
    }

    public bool IsSuccess { get; }

    public bool IsFailure =&gt; !IsSuccess;

    public Error Error { get; }

    public static Result Success() =&gt; new(true, Error.None);

    public static Result Failure(Error error) =&gt; new(false, error);
}
Copy<br>The only way to create a Result instance is by using static methods:<br>
<br>Success - creates a success result
<br>Failure - creates a failure result with the specified Error
<br>If you want to avoid building your own Result class, take a look at the <a data-tooltip-position="top" aria-label="https://github.com/altmann/FluentResults" rel="noopener" class="external-link" href="https://github.com/altmann/FluentResults" target="_blank">FluentResults</a> library.<br><br>Now that we have the Result class let's see how to apply it in practice.<br>Here's a refactored version of the FollowerService. Notice a few things:<br>
<br>No more throwing exceptions
<br>The Result return type is explicit
<br>It's clear which errors the method returns
<br>Another benefit of error handling using the Result pattern is that it's easier to test.<br>public sealed class FollowerService
{
    private readonly IFollowerRepository _followerRepository;

    public FollowerService(IFollowerRepository followerRepository)
    {
        _followerRepository = followerRepository;
    }

    public async Task&lt;Result&gt; StartFollowingAsync(
        User user,
        User followed,
        DateTime utcNow,
        CancellationToken cancellationToken = default)
    {
        if (user.Id  followed.Id)
        {
            return Result.Failure(FollowerErrors.SameUser);
        }

        if (!followed.HasPublicProfile)
        {
            return Result.Failure(FollowerErrors.NonPublicProfile);
        }

        if (await _followerRepository.IsAlreadyFollowingAsync(
                user.Id,
                followed.Id,
                cancellationToken))
        {
            return Result.Failure(FollowerErrors.AlreadyFollowing);
        }

        var follower = Follower.Create(user.Id, followed.Id, utcNow);

        _followerRepository.Insert(follower);

        return Result.Success();
    }
}
Copy<br><br>You can use the Error class to document all possible errors in your application.<br>One approach is to create a static class called Errors. It will have nested classes inside containing the specific errors. The usage would look like Errors.Followers.NonPublicProfile.<br>However, the approach I like to use is to create a specific class containing the errors.<br>Here's the FollowerErrors class documenting the possible errors for the Follower entity:<br>public static class FollowerErrors
{
    public static readonly Error SameUser = new Error(
        "Followers.SameUser", "Can't follow yourself");

    public static readonly Error NonPublicProfile = new Error(
        "Followers.NonPublicProfile", "Can't follow non-public profiles");

    public static readonly Error AlreadyFollowing = new Error(
        "Followers.AlreadyFollowing", "Already following");
}
Copy<br>Instead of static fields, you can also use static methods returning an error. You would call this method with a concrete argument to get an Error instance.<br>public static class FollowerErrors
{
    public static Error NotFound(Guid id) =&gt; new Error(
        "Followers.NotFound", $"The follower with Id '{id}' was not found");
}
Copy<br><br>The Result object will eventually reach the Minimal API (or controller) endpoint in ASP.NET Core. Minimal APIs return an IResult response, and controllers return an IActionResult response. Regardless, you must convert the Result instance into a valid API response.<br>The straightforward approach is checking the Result state and returning an HTTP response. Here's an example where we check the Result.IsFailure flag:<br>app.MapPost(
    "users/{userId}/follow/{followedId}",
    (Guid userId, Guid followedId, FollowerService followerService) =&gt;
    {
        var result = await followerService.StartFollowingAsync(
            userId,
            followedId,
            DateTime.UtcNow);

        if (result.IsFailure)
        {
            return Results.BadRequest(result.Error);
        }

        return Results.NoContent();
    });
Copy<br>However, this is an excellent opportunity for a more functional approach. You can implement the Match extension method to provide a callback for each Result state. The Match method will execute the respective callback and return the result.<br>Here's the implementation of Match:<br>public static class ResultExtensions
{
    public static T Match(
        this Result result,
        Func&lt;T&gt; onSuccess,
        Func&lt;Error, T&gt; onFailure)
    {
        return result.IsSuccess ? onSuccess() : onFailure(result.Error);
    }
}
Copy<br>And this is how you would use the Match method in a Minimal API endpoint:<br>app.MapPost(
    "users/{userId}/follow/{followedId}",
    (Guid userId, Guid followedId, FollowerService followerService) =&gt;
    {
        var result = await followerService.StartFollowingAsync(
            userId,
            followedId,
            DateTime.UtcNow);

        return result.Match(
            onSuccess: () =&gt; Results.NoContent(),
            onFailure: error =&gt; Results.BadRequest(error));
    });
Copy<br>Much more concise. Don't you think so?<br><br>If you take one thing with you from this week's issue, it should be this: exceptions are for exceptional situations. Moreover, you should only use exceptions for errors you don't know how to handle. In all other cases, expressing the error clearly with the Result pattern is more valuable.<br>Using the Result class allows you to:<br>
<br>Express the intent that a method could fail
<br>Encapsulate an application error inside
<br>Provide a functional way to handle errors
<br>Additionally, you can document all application errors with the Error class. This is helpful for developers to know which errors they need to handle.<br>You can even convert this to actual documentation. For example, I wrote a simple program that scans the project for all Error fields. It then converts this into a table format and uploads it to a Confluence page.<br>So I encourage you to try the Result pattern and see how it can improve your code.<br>See you next week.]]></description><link>04.-literature-notes/functional-error-handling-in-.net-with-the-result-pattern.html</link><guid isPermaLink="false">04. Literature Notes/Functional Error Handling in .NET With the Result Pattern.md</guid><pubDate>Wed, 08 May 2024 21:54:26 GMT</pubDate><enclosure url="lib/media/functional-error-handling-in-.net-with-the-result-pattern-240509-1.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/functional-error-handling-in-.net-with-the-result-pattern-240509-1.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Prerequisites]]></title><description><![CDATA[ 
 <br>Abstraction:<br>
This is a final project at Cedacri International<br>Tabloul de bord al incidentelor<br>
rda-3997 Tabloul de bord al incidentelor<br><br>Dezvoltarea unei aplicatii cu utilizarea tehnologiilor .NET pe care le-ati trecut in acest curs.<br>Adaugati la proiect indiferent daca este specificat in documentie sau nu pagina&nbsp;Admin, accesata doar de utilizatorii cu rol administrator.&nbsp;Pagina de admin reprezinta o tabela care contine toti utilizatorii, unde administratorul poate sa adauge, editeze, dezactiva/activa (fara stergere) utlizatorii.<br>Când creați aplicația, trebuie să implementați următoarele puncte:<br>
<br>Utilizarea arhitecturii N-tier(N-layer), sau cu acordul responsabilului, clean architecture.
<br>Creați proiectul pe .net 5 sau mai nou.
<br>Creați baza de date folosind&nbsp;EF core code first.

<br>La crearea entitatilor BD setati marimea campurilor si adaugati constrangeri exemplu: campul email nu poate fi mai mare de 100 de caractere si este unic.


<br>Utilizați Fluent API pentru configurarea bazei de date.
<br>Utilizați Fluent Validation pentru validare.

<br>La validare specificati exact mesajul de validare exepmlu: campul nume utilizator nu poate fi mai mic de 5 caractere.


<br>Utilizați biblioteca jquery dataTables pentru tabele, tabelele trebuie să fie încărcate cu apeluri ajax, paginarea și filtrarea trebuie să fie server side.
<br>Pentru Design, utilizați Bootstrap.
<br>(opțional) Logging&nbsp;folosiți orice bibliotecă pentru logging(Nlog,log4net).
<br>Autentificare și autorizarea utilizatorilor.
<br>Single page application.
<br>(Recomandare) Incepeti crearea proiectului cu crearea&nbsp;paginilor de logare si&nbsp;admin complet funtional.
<br><br><br>Prezentul document definește specificațiile de punere în aplicare a noului program "IncidentsDashboard". Acest document definește entitățile și obiectele de gestionare ale programului, caracteristicile entităților, funcțiile și interfața grafică, precum și modelul de date (DB).<br><br>DE COMPLETAT<br>Questo documento definisce le specifiche di implementazione del nuovo &nbsp;programma&nbsp; “Cruscotto Incidenti - IncidentsDashboard”. In questo documento sono definiti le entità e ogetti di gestione del programma, le caratteristiche delle entità, le funzioni e le interfaccia grafica, anchè il modello dei dati (DB).<br>DA COMPLETARE<br><br>"Tabloul de bord al incidentelor" este un produs care permite vizualizarea incidentelor care au loc în Cedacri. Alimentarea tabelelor cu date se va face în diferite moduri, pentru fiecare tip de accident putând exista un tip propriu de import. Primele tipuri de import vor fi fișiere .csv care vor fi importate din interfața grafică. Va exista, de asemenea, un modul vizibil doar pentru administratorii programului, în care va fi posibilă gestionarea tuturor utilizatorilor și editarea manuală a tuturor incidentelor existente în baza de date.<br>“Cruscotto Incidenti” é un prodotto che permette visualizzazione dei incidenti che succedono in Cedacri. Alimentazione delle tabelle con i dati sarà in diversi modi, per ogni tipo di incidente potrebbe essere un suo tipo di import. Primi tipi di import saranno dei file .csv che saranno importati da interfaccia grafica. Sarà previsto anche un modulo visibile solo per gli amministratori del programma in cui sarà possibilie gestire tutti gli utenti e modificare a mano tutti incidenti esistenti in DB.<br><br>Au fost relevante următoarele obiecte principale de gestionare a programului:<br>
<br>Utilizator - entitatea care descrie utilizatorul programului
<br>Incident - entitatea care reprezintă obiectul de bază care este gestionat în cadrul programului. Diferite tipuri de incidente vor fi plasate în tabele diferite.
<br>Informații suplimentare - entități care vor avea informații suplimentare pentru incidente
<br>Sono stati relevati i seguenti principali oggetti di gestione del programma:<br>
<br>Utente – l’entità che descrive l’utilizzatore del programma
<br>Incidente – l’entità che rappresenta l’oggetto di base che viene gestito nel programma. Saranno diversi tipi di incidenti che saranno messi in tabelle diverse.
<br>InformazioneAddizionale – entità che avranno informazioni addizionali per gli incidenti
<br><br><br>Utilizatorul reprezintă utilizatorul programului. Există 3 grupuri de utilizatori:<br>
<br>Administrator - gestionează utilizatorii programului, editează datele manual.
<br>Operator - import de date utilizând fișiere csv.
<br>Utilizator - vizualizarea informațiilor despre incidente
<br>Utilizatorul ca obiect de gestionare este descris prin următoarele atribute:<br>
<br>Identificator - identificator unic, ghid
<br>Nume utilizator - numele de utilizator alfanumeric (nume de utilizator), maxim (7) în format CRXXXXX.
<br>Nume și prenume - Prenume Nume de familie.
<br>Adresa de e-mail - adresa de e-mail
<br>Roluri - colecție cu rolurile utilizatorilor.
<br>Activare - un indicator care arată dacă utilizatorul este activat sau dezactivat în sistem
<br>L’utente rappresenta l’utilisatore del programma. Sono previsti 3 gruppi di utenti:<br>
<br>Amministratore – gestisce gli utenti del programma, modifica dati manualmente.
<br>Operatore - importa dati utilizzando file csv.
<br>Utente – visualizza informazione sui incidenti
<br>L’utente come oggetto di gestione è descritto dai seguenti attributi:<br>
<br>Identificatore – identificatore univoco, guid
<br>Nome dell’utenza – il nome dell’utente (username) alfanumerico, massimo (7) di formato CRXXXXX.
<br>Nome Completo – Nome Cognome.
<br>Indirizzo mail – l’indirizzo dell’email
<br>Ruoli – collezzione con i ruoli dei utenti.
<br>Abilitazione – un flag che mostra se l’utente è abilitato o disabilitato nel sistema
<br><br>Incident HelpDesk reprezintă un rând cu informații preluate din Cedacri HelpDesk. Pe lângă informațiile preluate din HDS, entitatea conține informații suplimentare, preluate din diverse surse de date și apoi selectate manual de un administrator. Incidentul HelpDesk, ca obiect de gestionare, este descris de următoarele atribute:<br>
<br>Identificator - identificator unic, ghid
<br>N. Call - cod alfanumeric unic al solicitării în helpdesk de 17 carate, alfanumeric, maxim (17) - de la HDS
<br>Subsistemul Cedacri - cod text din 2 carcase de subsisteme Cedacri, maximum (2) - de la HDS
<br>Start Problem - data la care a fost creată cererea în HDS, data - din HDS
<br>End Problem - data la care cererea a fost închisă în HDS, datetime - din HDS
<br>Tip - tipul de cerere în HDS sunt 3 variante posibile (a se face enum sau a se păstra ca șir de caractere???) - din HDS
<br>Tip de aplicație - alfanumeric - de la HDS
<br>Urgență - urgența cu care trebuie rezolvată cererea - de la HDS
<br>Sub-cauză - de la HDS.
<br>Rezumatul problemei - rezumatul cererii - de la HDS.
<br>Descrierea problemei - descrierea cererii - de la HDS
<br>Soluție - descrierea soluției - de la HDS.
<br>Scenariu cod - de la Mitiga.
<br>Nume de scenariu - din Mitiga.
<br>Codul de amenințare - de la Mitiga.
<br>Name Threat - amenințarea numelui - de la Mitiga.
<br>Originea - originea problemei - din BD-ul său.
<br>Domeniu de aplicare - domeniul de aplicare a problemei, fiul de origine - din BD-ul său.
<br>Tip - tipul problemei, copil al domeniului de aplicare - din baza de date a acestuia.
<br>Terța parte - numele societății responsabile, dacă nu este Cedacri - text.
<br>Toate datele care vor fi preluate din HDS vor fi încărcate în fișierul de import .csv. Dar acestea vor putea fi editate de către administratori.<br>Doar identificatorul tipului va fi introdus în baza de date, deoarece domeniul de aplicare și originea vor fi deja preluate din linkuri.<br>Incidente HelpDesk rappresenta una riga con informazioni presi da HelpDesk Cedacri. Oltre informazioni presi dal HDS, entità contienerà informazioni addizionali, presi da diversi datasource, e poi scelti manualmente da un amministratore. L’incidente HelpDesk, come oggetto di gestione è descritto dai seguenti attibuti:<br>
<br>Identificatore – identificatore univoco, guid
<br>Chiamata – codice alfanumerico univoco della richiesta in helpdesk di 17 carrateri, alfanumerico, massimo (17) – da HDS
<br>Sottosistema Cedacri – codice testuale da 2 carrateri delle sottosisteme di Cedacri, massimo (2) – da HDS
<br>Inizio Problema – data quando è stata creata la richiesta in HDS, datetime – da HDS
<br>Fine Problema – data quando è stata chiusa la richiesta in HDS, datetime – da HDS
<br>Tipo – tipo di richiesta in HDS sono 3 varianti possibili (fare enum o tenere come stringa???) – da HDS
<br>Tipologia Applicazione – tipologia di applicazione, alfanumerico – da HDS
<br>Urgency – la urgenza con cui deve essere risolta la richiesta – da HDS
<br>Sotto Causa – la sottocausa – da HDS.
<br>Sommario Problema – il sommario della richiesta – da HDS.
<br>Descrizione Problema – la descrizione della richiesta – da HDS
<br>Soluzione – la descrizione della soluzione – da HDS.
<br>Codice Scenario – codice scenario – da Mitiga.
<br>Nome Scenario – nome scenario – da Mitiga.
<br>Codice Minaccia – codice minaccia – da Mitiga.
<br>Nome Minaccia – nome minaccia – da Mitiga.
<br>Origine – origine del problema - da suo DB.
<br>Ambito – ambito del problema, figlio di origine – da suo DB.
<br>Tipo – tipo del problema, figlio di ambito – da suo DB.
<br>Terze parti – nome dell’azienda responsabile se non è Cedacri - testo.
<br>Tutti i dati che saranno presi da HDS, saranno caricati al import del .csv. Ma saranno modificabili dai amministratori.<br>In db sarà messo solo l’identificatore del Tipo, perché Ambito ed Origine saranno già presi dai collegamenti.<br><br>Diagrama DB este reprezentată în desenul 3.3.1. Fișierul cu scriptul pentru crearea tuturor obiectelor din BD se află în desenul 3.3.2.<br><img alt="Analisi Tecnica ro-240509-1.jpg" src="lib/media/analisi-tecnica-ro-240509-1.jpg"><br>Il diagramma del DB è rappresentato nel disegno 3.3.1. Il file con lo script di create dei tutti gli oggetti nel DB si trova nell’oggetto 3.3.2.<br>Des. 3.3.1 Il diagramma del database IncidentsDashboard<br><img alt="Analisi Tecnica ro-240509-2.jpg" src="lib/media/analisi-tecnica-ro-240509-2.jpg"><br><br>DE COMPLETAT<br><br><img alt="Analisi Tecnica ro-240509-3.jpg" src="lib/media/analisi-tecnica-ro-240509-3.jpg"><br><img alt="Analisi Tecnica ro-240509-4.jpg" src="lib/media/analisi-tecnica-ro-240509-4.jpg"><br>DETALII, ADĂUGARE, ACTUALIZARE<br><img alt="Analisi Tecnica ro-240509-5.jpg" src="lib/media/analisi-tecnica-ro-240509-5.jpg">]]></description><link>04.-literature-notes/incidents-dashboard-project.html</link><guid isPermaLink="false">04. Literature Notes/Incidents Dashboard Project.md</guid><pubDate>Thu, 09 May 2024 12:09:15 GMT</pubDate><enclosure url="lib/media/analisi-tecnica-ro-240509-1.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/analisi-tecnica-ro-240509-1.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Layered Architecture with ASP.NET Core, Entity Framework Core and Razor Pages]]></title><description><![CDATA[ 
 <br><a data-tooltip-position="top" aria-label="https://miro.medium.com/v2/resize:fill:88:88/1*pgjuS7q21HmvfnpB9LMxVw.png" rel="noopener" class="external-link" href="https://miro.medium.com/v2/resize:fill:88:88/1*pgjuS7q21HmvfnpB9LMxVw.png" target="_blank"><span alt="Layered Architecture with ASP.NET Core, Entity Framework Core and Razor Pages-240509-17.jpg" src="Layered Architecture with ASP.NET Core, Entity Framework Core and Razor Pages-240509-17.jpg" class="internal-embed media-embed image-embed is-loaded"></span></a><img alt="Layered Architecture with ASP.NET Core, Entity Framework Core and Razor Pages-240509-17.jpg" src="lib/media/layered-architecture-with-asp.net-core,-entity-framework-core-and-razor-pages-240509-17.jpg"><br><a data-tooltip-position="top" aria-label="https://miro.medium.com/v2/resize:fit:1010/1*D1_QV9o5m7ZHds0_C-OUzw.png" rel="noopener" class="external-link" href="https://miro.medium.com/v2/resize:fit:1010/1*D1_QV9o5m7ZHds0_C-OUzw.png" target="_blank"><span alt="Layered Architecture with ASP.NET Core, Entity Framework Core and Razor Pages-240509-18.jpg" src="Layered Architecture with ASP.NET Core, Entity Framework Core and Razor Pages-240509-18.jpg" class="internal-embed media-embed image-embed is-loaded"></span></a><img alt="Layered Architecture with ASP.NET Core, Entity Framework Core and Razor Pages-240509-18.jpg" src="lib/media/layered-architecture-with-asp.net-core,-entity-framework-core-and-razor-pages-240509-18.jpg"><br>BONUS : Udemy Course — Microservices Architecture and Step by Step Implementation on .NET with Clean Architecture<br>This article explains <a data-tooltip-position="top" aria-label="https://github.com/aspnetrun/run-aspnetcore" rel="noopener" class="external-link" href="https://github.com/aspnetrun/run-aspnetcore" target="_blank"><em><strong></strong></em></a>aspnetrun core repository of github. This series of articles continues as per difficulty levels. This article intended for the intermediate of asp.net core. You can follow the other articles at the end of the page.<br><br>In this article we will show how to Create Layered Application with performing CRUD operations on ASP.NET Core Web application using Entity Framework and Razor Pages.<br>By the end of the article, we will have an web application which implemented NLayer Hexagonal architecture (Core, Application, Infrastructure and Presentation Layers) and Domain Driven Design (Entities, Repositories, Domain/Application Services, DTO’s…) over the CRUD operations.<br>Take a look at the final application.<br><a data-tooltip-position="top" aria-label="https://miro.medium.com/v2/resize:fit:875/1*D1_QV9o5m7ZHds0_C-OUzw.png" rel="noopener" class="external-link" href="https://miro.medium.com/v2/resize:fit:875/1*D1_QV9o5m7ZHds0_C-OUzw.png" target="_blank"><span alt="Layered Architecture with ASP.NET Core, Entity Framework Core and Razor Pages-240509-19.jpg" src="Layered Architecture with ASP.NET Core, Entity Framework Core and Razor Pages-240509-19.jpg" class="internal-embed media-embed image-embed is-loaded"></span></a><img alt="Layered Architecture with ASP.NET Core, Entity Framework Core and Razor Pages-240509-19.jpg" src="lib/media/layered-architecture-with-asp.net-core,-entity-framework-core-and-razor-pages-240509-19.jpg"><br>You’ll learn how to:<br>
<br>Create Layered Application with ASP.NET Core Web Application Project
<br>N-Layer Hexagonal architecture (Core, Application, Infrastructure and Presentation Layers)
<br>Domain Driven Design (Entities, Repositories, Domain/Application Services, DTO’s…)
<br>Clean Architecture, with applying SOLID principles
<br>Best practices like loosely-coupled, dependency-inverted architecture and using design patterns such as Dependency Injection, logging, validation, exception handling, localization and so on.
<br>Repository and Specification Design Pattern
<br>Test Driven Development (TDD) technics
<br><br>Get the <a data-tooltip-position="top" aria-label="https://github.com/aspnetrun/run-aspnetcore" rel="noopener" class="external-link" href="https://github.com/aspnetrun/run-aspnetcore" target="_blank"><strong></strong></a>Source Code from AspnetRun Github — Clone or fork this repository, if you like don’t forget the star :) If you find or ask anything you can directly open issue on repository.<br><br>
<br>Install the .NET Core 3.1 or above SDK
<br>Install Visual Studio 2019 v16.x or above
<br>Microsoft Sql Server Express (its comes with Visual Studio)
<br><br>Most of the web applications following common steps when you start a new web application. Based on that we will create an extendable base infrastructure which implemented best practices on layered architecture. So lets create our crud operations on asp.net core web application with layered architecture.<br><br>First of all, we are going to start with remembering the core concepts, principles of layered architecture design. We are going to start with small principles and continue to design patterns which all of these items are used our ASP.NET Core Layered Architecture project.<br><br>To summarize the term dependency briefly, we can explain that a class is dependent on another class, that is, a class needs another class to work. As we see in the figure below, the upper-level layer uses the lower-level layer (classes, interfaces, etc.). we can say that the level is dependent on the layer. As for the term re-usability; Firstly, we think that a class can be written and used in various parts of the project, but we can define a code that we use as a real reuse and a higher level library can be used in other projects without touching the code. We cannot do this because of the interdependence of classes in well-designed software. At this point, Dependency Inversion Principle (DIP), which is an important software principle that needs to be implemented in order to develop more flexible and reusable modules, comes into play. Briefly explain this method;<br>Upper-level modules, classes, etc., lower-level classes must not be dependent on modules. Lower-level modules must be dependent on higher-level modules (interfaces of modules). For short, we call it Dependency Inversion.<br>Let’s see how I applied this principle in the next example:<br><a data-tooltip-position="top" aria-label="https://miro.medium.com/v2/resize:fit:875/0*geE-7KHB3wCCcL3h.png" rel="noopener" class="external-link" href="https://miro.medium.com/v2/resize:fit:875/0*geE-7KHB3wCCcL3h.png" target="_blank"><span alt="Layered Architecture with ASP.NET Core, Entity Framework Core and Razor Pages-240509-20.jpg" src="Layered Architecture with ASP.NET Core, Entity Framework Core and Razor Pages-240509-20.jpg" class="internal-embed media-embed image-embed is-loaded"></span></a><img alt="Layered Architecture with ASP.NET Core, Entity Framework Core and Razor Pages-240509-20.jpg" src="lib/media/layered-architecture-with-asp.net-core,-entity-framework-core-and-razor-pages-240509-20.jpg"><br>On the left side we found an Layered Application where the Business Logic depends on the SqlDatabase implementation. It is a coupled way to write code. On the right side, by adding an IRepository and applying DIP then the SqlDatabase has its dependency pointing inwards.<br><br>SoC says that the elements in the software should be unique to them, not to share their responsibilities with other staff members. The necessity of separate responsibilities is the basic point that this principle underlines. While developing the software, the concepts we can call an boundaries “may be the clearest words that distinguish these responsibilities from one another. From the simplest, we distinguish between the concepts of layer and tier and certain responsibilities. If we enter a little more, the namespaces of our software components can also be used as limits to allocate responsibilities. The degree of adherence to the components within the software and the cohesion within the components are two important concepts for the SoC principle. It should always be preferred that the degree of commitment of the components is low and that the relationship of responsibility in a component is high. So low-coupling, high-cohesion is indispensable. If the degree of commitment is low, then the control of the software will be easier in our hand, since the liability will be distributed per component. Being close to each other in their responsibilities within the components will reveal re-usability.<br>We can give an example of SoC that development of Web UI. As you can see that UI element i.e. button needs to configure by 3 structure; HTML— CSS — JS.<br><a data-tooltip-position="top" aria-label="https://miro.medium.com/v2/resize:fit:875/0*2iNDjtrp3YKK-B22.jpg" rel="noopener" class="external-link" href="https://miro.medium.com/v2/resize:fit:875/0*2iNDjtrp3YKK-B22.jpg" target="_blank"><span alt="Layered Architecture with ASP.NET Core, Entity Framework Core and Razor Pages-240509-21.jpg" src="Layered Architecture with ASP.NET Core, Entity Framework Core and Razor Pages-240509-21.jpg" class="internal-embed media-embed image-embed is-loaded"></span></a><img alt="Layered Architecture with ASP.NET Core, Entity Framework Core and Razor Pages-240509-21.jpg" src="lib/media/layered-architecture-with-asp.net-core,-entity-framework-core-and-razor-pages-240509-21.jpg"><br><br>In the software we develop, the solutions we create as a solution must be one in the software. If we cannot prevent this, for a problem, more than one version of the same solution will find itself in the code. It develops, develops, grows and makes the code more difficult to maintain. The fact that the same validation is done with a different string operation leads to inconsistency in the software. When you write code, it is best to re-use the solution if you think that it is similar to a similar solution before. To implement the DRY principle, it will be encapsulate common solutions into unique places in your code.<br><br>Persistence Ignorance (PI) principle maintains that in a software application classes that model the field of work should not be affected by how they are persisted. Therefore, their design should reflect as closely as possible the ideal design required to solve the operational problem and should not be emphasized as to how the status of the objects are recorded and then taken. Some common Persistence Ignorance violations include domain objects that need to inherit from a given base class or must show specific properties. Sometimes insight information takes the form of properties that must be applied to the class, or it only supports certain collection types or property visibility levels. There are perspectives of ignorance, the oldest CLR Objects (POCOs) in .NET.<br><br>Although the Entities represent an object in their own right, there will be situations in real life that are often required to be done in a collaborative manner. The combination of more than one Entity related to each other to perform the rule is defined as Aggregate. When all AR (Aggregate Roots) are examined within the framework of business rules, logically the most closely related ones start to form a more clearly defined group. This grouped ARs are called “Bounded Context“. Each AR and Entity have a meaning in this cluster and have a clear responsibility.<br><br>Now, we are going to examine some of design patterns which implemented in our <a data-tooltip-position="top" aria-label="https://github.com/aspnetrun/run-aspnetcore" rel="noopener" class="external-link" href="https://github.com/aspnetrun/run-aspnetcore" target="_blank">aspnetrun-core project</a>.<br><br>Repository is a concept that is used in order to write the information of all entity and value objects in an aggregate to the database. For each AR itself, we will perform the DB operations over the Repository as a whole in the transactinal structure. Repository basically prevents database work from being moved from the workstation to a database, thus preventing query and code repetition. In other words, the main purpose is to process data and interrogations into a central structure avoiding repetitions. In this way, we stay away from writing our database operations again and again in the business layer. The Repository Design Pattern has brought the logic of the sections that make the actual work in your program and the sections that access the data from each other. That is, it acts as an interface between the data layer and the business layer that uses this layer, and it also acts as an abstraction between these two layers. AspnetRun Repository and Specification implementation. This class responsible to create queries, includes, where conditions etc..<br><a data-tooltip-position="top" aria-label="https://miro.medium.com/v2/resize:fit:400/0*nXv2nUJUbqmGZoIO.png" rel="noopener" class="external-link" href="https://miro.medium.com/v2/resize:fit:400/0*nXv2nUJUbqmGZoIO.png" target="_blank"><span alt="Layered Architecture with ASP.NET Core, Entity Framework Core and Razor Pages-240509-22.jpg" src="Layered Architecture with ASP.NET Core, Entity Framework Core and Razor Pages-240509-22.jpg" class="internal-embed media-embed image-embed is-loaded"></span></a><img alt="Layered Architecture with ASP.NET Core, Entity Framework Core and Razor Pages-240509-22.jpg" src="lib/media/layered-architecture-with-asp.net-core,-entity-framework-core-and-razor-pages-240509-22.jpg"><br><br>Specification Design Pattern is created to ensure that the logical rules in an object are received from the outside. The rules of business are in a chain of successive chains, which may also reveal a more complex business rule.<br>I want to continue with a code example to understand the pattern. In repository Specification Pattern implemented by interface definition ;<br>public interface ISpecification&lt;T&gt;
    {
        Expression&lt;Func&lt;T, bool&gt;&gt; Criteria { get; }
        List&lt;Expression&lt;Func&lt;T, object&gt;&gt;&gt; Includes { get; }
        List&lt;string&gt; IncludeStrings { get; }
        Expression&lt;Func&lt;T, object&gt;&gt; OrderBy { get; }
        Expression&lt;Func&lt;T, object&gt;&gt; OrderByDescending { get; }
        int Take { get; }
        int Skip { get; }
        bool isPagingEnabled { get; }
    }
Copy<br>These definition and below implementation located in Core Layer. Because these classes not included Entity Framework Core related dependencies.<br>public abstract class BaseSpecification&lt;T&gt; : ISpecification&lt;T&gt;
    {
        protected BaseSpecification(Expression&lt;Func&lt;T, bool&gt;&gt; criteria)
        {
            Criteria = criteria;
        }
        public Expression&lt;Func&lt;T, bool&gt;&gt; Criteria { get; }
        public List&lt;Expression&lt;Func&lt;T, object&gt;&gt;&gt; Includes { get; } = new List&lt;Expression&lt;Func&lt;T, object&gt;&gt;&gt;();
        public List&lt;string&gt; IncludeStrings { get; } = new List&lt;string&gt;();
        public Expression&lt;Func&lt;T, object&gt;&gt; OrderBy { get; private set; }
        public Expression&lt;Func&lt;T, object&gt;&gt; OrderByDescending { get; private set; }
        public int Take { get; private set; }
        public int Skip { get; private set; }
        public bool isPagingEnabled { get; private set; } = false;
        protected virtual void AddInclude(Expression&lt;Func&lt;T, object&gt;&gt; includeExpression)
        {
            Includes.Add(includeExpression);
        }
        protected virtual void AddInclude(string includeString)
        {
            IncludeStrings.Add(includeString);
        }
        protected virtual void ApplyPaging(int skip, int take)
        {
            Skip = skip;
            Take = take;
            isPagingEnabled = true;
        }
        protected virtual void ApplyOrderBy(Expression&lt;Func&lt;T, object&gt;&gt; orderByExpression)
        {
            OrderBy = orderByExpression;
        }
        protected virtual void ApplyOrderByDescending(Expression&lt;Func&lt;T, object&gt;&gt; orderByDescendingExpression)
        {
            OrderByDescending = orderByDescendingExpression;
        }
    }
Copy<br>Specification Pattern implemented from <a data-tooltip-position="top" aria-label="https://docs.microsoft.com/en-us/dotnet/standard/microservices-architecture/microservice-ddd-cqrs-patterns/infrastructure-persistence-layer-implemenation-entity-framework-core" rel="noopener" class="external-link" href="https://docs.microsoft.com/en-us/dotnet/standard/microservices-architecture/microservice-ddd-cqrs-patterns/infrastructure-persistence-layer-implemenation-entity-framework-core" target="_blank">Microsoft article.</a><br><br>Hexagonal Architecture (aka Ports and Adapters) is one strategy to decouple the use cases from the external details. It was coined by Alistar Cockburn more than 13 years ago, and this received improvements with the Onion and Clean Architectures.<br><a data-tooltip-position="top" aria-label="https://miro.medium.com/v2/resize:fit:875/0*42M0KbgU3P2EiP5N.jpg" rel="noopener" class="external-link" href="https://miro.medium.com/v2/resize:fit:875/0*42M0KbgU3P2EiP5N.jpg" target="_blank"><span alt="Layered Architecture with ASP.NET Core, Entity Framework Core and Razor Pages-240509-23.jpg" src="Layered Architecture with ASP.NET Core, Entity Framework Core and Razor Pages-240509-23.jpg" class="internal-embed media-embed image-embed is-loaded"></span></a><img alt="Layered Architecture with ASP.NET Core, Entity Framework Core and Razor Pages-240509-23.jpg" src="lib/media/layered-architecture-with-asp.net-core,-entity-framework-core-and-razor-pages-240509-23.jpg"><br>This project (<a data-tooltip-position="top" aria-label="https://github.com/aspnetrun/run-aspnetcore" rel="noopener" class="external-link" href="https://github.com/aspnetrun/run-aspnetcore" target="_blank"><strong></strong></a>AspnetRun-Core), implements NLayer Hexagonal architecture (Core, Application, Infrastructure and Presentation Layers) and Domain Driven Design (Entities, Repositories, Domain/Application Services, DTO’s…). Also implements and provides a good infrastructure to implement best practices such as Dependency Injection, logging, validation, exception handling, localization and so on. Aimed to be a Clean Architecture also called Onion Architecture, with applying SOLID principles in order to use for a project template. The below image represents aspnetrun-core approach of development architecture of run repository series;<br><a data-tooltip-position="top" aria-label="https://miro.medium.com/v2/resize:fit:605/0*fyoZ2dspRvkECMMY.png" rel="noopener" class="external-link" href="https://miro.medium.com/v2/resize:fit:605/0*fyoZ2dspRvkECMMY.png" target="_blank"><span alt="Layered Architecture with ASP.NET Core, Entity Framework Core and Razor Pages-240509-24.jpg" src="Layered Architecture with ASP.NET Core, Entity Framework Core and Razor Pages-240509-24.jpg" class="internal-embed media-embed image-embed is-loaded"></span></a><img alt="Layered Architecture with ASP.NET Core, Entity Framework Core and Razor Pages-240509-24.jpg" src="lib/media/layered-architecture-with-asp.net-core,-entity-framework-core-and-razor-pages-240509-24.jpg"><br>According to this diagram, we applied these layers and detail components in our project. So the result of the project structure occurred as below;<br><br><br>
<br>Entities
<br>Interfaces
<br>Specifications
<br>ValueObjects
<br>Exceptions
<br><br>
<br>Interfaces
<br>Services
<br>Dtos
<br>Mapper
<br>Exceptions
<br><br>
<br>Data
<br>Repository
<br>Services
<br>Migrations
<br>Logging
<br>Exceptions
<br><br>
<br>Interfaces
<br>Services
<br>Pages
<br>ViewModels
<br>Extensions
<br>Mapper
<br><br>In this article we will show how to Create Layered Application with performing CRUD operations. Before we start, we have to understand our domain even there is no much required analysis its good habit to start with domain examination. We should define our basic use case analysis.<br>We should define our basic use case analysis. In this post we will create Product — Category entities and create its relation. Our main use case is Listing Products into Product Page and able to search products. Also performed CRUD operations on Product entity. In our example Product has only 1 category.<br>As per previous headings you saw clean architecture and we are going to create 4 layer;<br>
<br>Core
<br>Application
<br>Infrastructure
<br>Web
<br><br>Development of Domain Logic with abstraction. Interfaces drives business requirements with light implementation. The Core project is the center of the Clean Architecture design, and all other project dependencies should point toward it.<br>Lets see which folders included in this Core Layer;<br><br>Includes Entity Framework Core Entities which creates sql table with Entity Framework Core Code First Approach. Some Aggregate folders holds entity and aggregates. You can see example of code-first Entity definition in Product.cs. Applying domain driven approach, Product class responsible to create Product instance.<br>The first point of implementation is definition of Entity. Because we are choosing code-first approach of Entity Framework Core and this separate this entities to Core layer in order to write only one place.<br>public class Product : BaseEntity
    {        
        public string ProductName { get; set; }
        public string QuantityPerUnit { get; set; }
        public decimal? UnitPrice { get; set; }
        public short? UnitsInStock { get; set; }
        public short? UnitsOnOrder { get; set; }
        public short? ReorderLevel { get; set; }
        public bool Discontinued { get; set; }
        public int CategoryId { get; set; }
        public Category Category { get; set; }
    public static Product Create(int productId, int categoryId, string name, decimal? unitPrice = null, short? unitsInStock = null, short? unitsOnOrder = null, short? reorderLevel = null, bool discontinued = false)
    {
      var product = new Product
      {
      Id = productId,
      CategoryId = categoryId,
      ProductName = name,
      UnitPrice = unitPrice,
      UnitsInStock = unitsInStock,
      UnitsOnOrder = unitsOnOrder,
      ReorderLevel = reorderLevel,
      Discontinued = discontinued
    };
    return product;
    }        
  }
Copy<br>As you can see that, any entity class should inherit from BaseEntity.cs. This class include Id field with int type. If you want to change Id field type, you should change only BaseEntity.cs.<br>Also Category entity should be created;<br>public class Category : BaseEntity
    {
        public Category()
        {
            Products = new HashSet&lt;Product&gt;();
        }
        public string CategoryName { get; set; }
        public string Description { get; set; }        
        public ICollection&lt;Product&gt; Products { get; private set; }        
    }
Copy<br><br>Abstraction of Repository — Domain repositories (IAsyncRepository — IProductRepository) — Specifications etc.. This interfaces include database operations without any application and UI responsibilities.<br>Core layer has Interfaces folder which basically include abstraction of dependencies. So when we create new 2 entity if we need to operate some custom database operation we should create repository classes ;<br>public interface IProductRepository : IAsyncRepository&lt;Product&gt;
    {
        Task&lt;IEnumerable&lt;Product&gt;&gt; GetProductListAsync();
        Task&lt;IEnumerable&lt;Product&gt;&gt; GetProductByNameAsync(string productName);
        Task&lt;IEnumerable&lt;Product&gt;&gt; GetProductByCategoryAsync(int categoryId);
    }
  public interface ICategoryRepository : IAsyncRepository&lt;Category&gt;
    {
        Task&lt;Category&gt; GetCategoryWithProductsAsync(int categoryId);
    }
Copy<br><br>This folder is implementation of <a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Specification_pattern" rel="noopener" class="external-link" href="https://en.wikipedia.org/wiki/Specification_pattern" target="_blank">specification pattern</a>. Creates custom scripts with using ISpecification interface. Using BaseSpecification managing Criteria, Includes, OrderBy, Paging. This specs runs when EF commands working with passing spec. This specs implemented SpecificationEvaluator.cs and creates query to AspnetRunRepository.cs in ApplySpecification method.This helps create custom queries.<br><br>Implementation of Core interfaces in this project with Entity Framework Core and other dependencies. Most of your application’s dependence on external resources should be implemented in classes defined in the Infrastructure project. These classes must implement the interfaces defined in Core. If you have a very large project with many dependencies, it may make sense to have more than one Infrastructure project (eg Infrastructure.Data), but in most projects one Infrastructure project that contains folders works well.<br>This could be includes, for example, e-mail providers, file access, web api clients, etc. For now this repository only dependent sample data access and basic domain actions, by this way there will be no direct links to your Core or UI projects.<br>Lets see which folders included in this Core Layer;<br><br>Includes Entity Framework Core Context and tables in this folder. When new entity created, it should add to context and configure in context. The Infrastructure project depends on Microsoft.EntityFrameworkCore.SqlServer and EF.Core related nuget packages, you can check nuget packages of Infrastructure layer. If you want to change your data access layer, it can easily be replaced with a lighter-weight ORM like Dapper.<br>We were choosing code-first approach of Entity Framework Core so we should add entities into Entity Framework Core Context object in order to reflect database.<br>public class AspnetRunContext : DbContext
{     
        public DbSet&lt;Product&gt; Products { get; set; }
        public DbSet&lt;Category&gt; Categories { get; set; }
}
Copy<br>At above, we added database sets of entity objects into our Entity Framework Core context. By this way we can navigate this entities with InMemory and Read Sql Server databases.<br><br>This folder includes Entity Framework Core generated migration classes which scaffolding from add-migration and update-database commands.<br><br>Repository implementations of Infrastructure layer has Entity Framework Core context, wrapper class and Repositories which perform db operations via EF Context object.<br>
Its not mandatory to create and implement repository classes, IAsyncRepository and its implementation class AspnetRunRepository.cs is cover all crud operations. So if you have custom database requirements than you should choose this way.
<br>public class ProductRepository : Repository&lt;Product&gt;, IProductRepository
    {
        public ProductRepository(AspnetRunContext dbContext) : base(dbContext)
        {
        }

        public async Task&lt;IEnumerable&lt;Product&gt;&gt; GetProductListAsync()
        {
            // return await GetAllAsync();

            var spec = new ProductWithCategorySpecification();
            return await GetAsync(spec);
        }

        public async Task&lt;IEnumerable&lt;Product&gt;&gt; GetProductByNameAsync(string productName)
        {
            var spec = new ProductWithCategorySpecification(productName);
            return await GetAsync(spec);
        }
        
        public async Task&lt;IEnumerable&lt;Product&gt;&gt; GetProductByCategoryAsync(int categoryId)
        {
            return await _dbContext.Products
                .Where(x =&gt; x.CategoryIdcategoryId)
                .ToListAsync();
        }
    }

public class CategoryRepository : Repository&lt;Category&gt;, ICategoryRepository
    {
        public CategoryRepository(AspnetRunContext dbContext) : base(dbContext)
        {            
        }

        public async Task&lt;Category&gt; GetCategoryWithProductsAsync(int categoryId)
        {            
            var spec = new CategoryWithProductsSpecification(categoryId);
            var category = (await GetAsync(spec)).FirstOrDefault();
            return category;
        }
    }
Copy<br>As you can see that these implementation classes inherit from base Repository.cs in order to use Entity Framework Core dbContext object and use benefits from db abstractions.<br><br>This folder includes custom services implementation, like email, cron jobs etc.<br><br>This layer for Development of Domain Logic with implementation. Interfaces drives business requirements and implementations in this layer. Application Layer in order to implement our business logics, use case operations. The first point of implementation is definition of Model classes.<br>
Its not mandatory to create and implement Model classes, You can use direct Core entities but its good to separate entity and application required objects.
<br>public class ProductModel: BaseModel
    {
        public string ProductName { get; set; }
        public string QuantityPerUnit { get; set; }
        public decimal? UnitPrice { get; set; }
        public short? UnitsInStock { get; set; }
        public short? UnitsOnOrder { get; set; }
        public short? ReorderLevel { get; set; }
        public bool Discontinued { get; set; }
        public int? CategoryId { get; set; }
        public CategoryModel Category { get; set; }
    }
public class CategoryModel: BaseModel
    {
        public string CategoryName { get; set; }
        public string Description { get; set; }        
    }
Copy<br>As you can see that these Model classes inherit BaseModel.cs.<br><br>The use case of projects should be handled by Application layer. So we are creating Interface and Implementation classes as below way.<br>public interface IProductAppService
{
    Task&lt;IEnumerable&lt;ProductDto&gt;&gt; GetProductList();
    Task&lt;ProductDto&gt; GetProductById(int productId);
    Task&lt;IEnumerable&lt;ProductDto&gt;&gt; GetProductByName(string productName);
    Task&lt;IEnumerable&lt;ProductDto&gt;&gt; GetProductByCategory(int categoryId);
    Task&lt;ProductDto&gt; Create(ProductDto entityDto);
    Task Update(ProductDto entityDto);
    Task Delete(ProductDto entityDto);
}
Copy<br>Also implementation located same places in order to choose different implementation at runtime when DI bootstrapped.<br>public class ProductAppService : IProductAppService
{
    private readonly IProductRepository _productRepository;
    private readonly IAppLogger&lt;ProductAppService&gt; _logger;

    public ProductAppService(IProductRepository productRepository, IAppLogger&lt;ProductAppService&gt; logger)
    {
        _productRepository = productRepository ?? throw new ArgumentNullException(nameof(productRepository));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    public async Task&lt;IEnumerable&lt;ProductDto&gt;&gt; GetProductList()
    {
        var productList = await _productRepository.GetProductListAsync();
        var mapped = ObjectMapper.Mapper.Map&lt;IEnumerable&lt;ProductDto&gt;&gt;(productList);
        return mapped;
    }
}
Copy<br>In this layer we can add validation , authorization, logging, exception handling etc. — cross cutting activities should be handled in here.<br><br>Beyond this developments, also there are main components should be handled in Application layer;<br>
<br>Authorization Management
<br>Validation Management
<br>Session Management
<br>Notification Management
<br>Exception Management
<br>So in this layer we have these cross-cutting activities which provide to manage your application. You will authorize your application in this layer, you should apply your validations in here, you should manage application session and publish notifications from application layer with exception management.<br>All validation , authorization, logging, exception handling etc. — this kind of cross cutting activities should be handled by these classes.<br><br>Development of UI Logic with implementation. Interfaces drives business requirements and implementations in this layer. The application’s main starting point is the ASP.NET Core web project. This is a classical console application, with a public static void Main method in Program.cs. It currently uses the default ASP.NET Core project template which based on Razor Pages templates. This includes appsettings.json file plus environment variables in order to stored configuration parameters, and is configured in Startup.cs.<br>The last layer is UI layer, so in this layer we consumed all other layers. Lets start with the ViewModel classes. This classes you can think that imagine of Page components and what is the required data of page.<br>public class ProductViewModel : BaseViewModel
    {
        public string ProductName { get; set; }
        public string QuantityPerUnit { get; set; }
        public decimal? UnitPrice { get; set; }
        public short? UnitsInStock { get; set; }
        public short? UnitsOnOrder { get; set; }
        public short? ReorderLevel { get; set; }
        public bool Discontinued { get; set; }
        public int? CategoryId { get; set; }
        public CategoryViewModel Category { get; set; }
    }
 public class CategoryViewModel : BaseViewModel
    {
        public string CategoryName { get; set; }
        public string Description { get; set; }
    }
Copy<br><br>Page Services provide to support Razor pages in order to implement screen logics. Its the same way we create interface and also implementation classes.<br>Web layer defines that user required actions in page services classes as below way;<br>public interface IProductPageService
    {
        Task&lt;IEnumerable&lt;ProductViewModel&gt;&gt; GetProducts(string productName);
        Task&lt;ProductViewModel&gt; GetProductById(int productId);
        Task&lt;IEnumerable&lt;ProductViewModel&gt;&gt; GetProductByCategory(int categoryId);
        Task&lt;IEnumerable&lt;CategoryViewModel&gt;&gt; GetCategories();
        Task&lt;ProductViewModel&gt; CreateProduct(ProductViewModel productViewModel);
        Task UpdateProduct(ProductViewModel productViewModel);
        Task DeleteProduct(ProductViewModel productViewModel);
    }
public interface ICategoryPageService
    {
        Task&lt;IEnumerable&lt;CategoryViewModel&gt;&gt; GetCategories();
    }
Copy<br>Also implementation located same places in order to choose different implementation at runtime when DI bootstrapped.<br>public class ProductPageService : IProductPageService
{
    private readonly IProductAppService _productAppService;
    private readonly ICategoryAppService _categoryAppService;
    private readonly IMapper _mapper;
    private readonly ILogger&lt;ProductPageService&gt; _logger;
    public ProductPageService(IProductAppService productAppService, ICategoryAppService categoryAppService, IMapper mapper, ILogger&lt;ProductPageService&gt; logger)
    {
        _productAppService = productAppService ?? throw new ArgumentNullException(nameof(productAppService));
        _categoryAppService = categoryAppService ?? throw new ArgumentNullException(nameof(categoryAppService));
        _mapper = mapper ?? throw new ArgumentNullException(nameof(mapper));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }
    public async Task&lt;IEnumerable&lt;ProductViewModel&gt;&gt; GetProducts(string productName)
    {
        if (string.IsNullOrWhiteSpace(productName))
        {
            var list = await _productAppService.GetProductList();
            var mapped = _mapper.Map&lt;IEnumerable&lt;ProductViewModel&gt;&gt;(list);
            return mapped;
        }
        var listByName = await _productAppService.GetProductByName(productName);
        var mappedByName = _mapper.Map&lt;IEnumerable&lt;ProductViewModel&gt;&gt;(listByName);
        return mappedByName;
    }
}
Copy<br><br>The final part of UI implementation is Razor Pages. So we should create a Product and Category folder into Pages folder. And in these folder, create cshtml razor pages with Index-Create-Edit-Delete pages in order to building web pages.<br>Lets create with Index page;<br>Html Part;<br>@page
@model AspnetRun.Web.Pages.Product.IndexModel

@{
    ViewData["Title"] = "Index";
}

&lt;h1&gt;Product List&lt;/h1&gt;

&lt;form method="get"&gt;
    &lt;div class="form-group"&gt;
        &lt;div class="input-group"&gt;
            &lt;input type="search" class="form-control" asp-for="SearchTerm" /&gt;
            &lt;span class="input-group-btn"&gt;
                &lt;button class="btn btn-default"&gt;
                    Search
                &lt;/button&gt;
            &lt;/span&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/form&gt;

&lt;p&gt;
    &lt;a asp-page="Create"&gt;Create New&lt;/a&gt;
&lt;/p&gt;

&lt;table class="table table-hover"&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;th scope="col"&gt;Id&lt;/th&gt;
            &lt;th scope="col"&gt;Name&lt;/th&gt;
            &lt;th scope="col"&gt;UnitPrice&lt;/th&gt;
            &lt;th scope="col"&gt;Category&lt;/th&gt;
            &lt;th scope="col"&gt;Action&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        @foreach (var product in Model.ProductList)
        {
            &lt;tr&gt;
                &lt;th scope="row"&gt;@product.Id&lt;/th&gt;
                &lt;td&gt;@product.ProductName&lt;/td&gt;
                &lt;td&gt;@product.UnitPrice&lt;/td&gt;
                &lt;td&gt;@product.Category.CategoryName&lt;/td&gt;
                &lt;td&gt;
                    &lt;a class="btn"
                       asp-page="./Details"
                       asp-route-productId="@product.Id"&gt;
                        Details
                    &lt;/a&gt;
                    &lt;a class="btn"
                       asp-page="./Edit"
                       asp-route-productId="@product.Id"&gt;
                        Edit
                    &lt;/a&gt;
                    &lt;a class="btn"
                       asp-page="./Delete"
                       asp-route-productId="@product.Id"&gt;
                        Delete
                    &lt;/a&gt;
                &lt;/td&gt;
            &lt;/tr&gt;
        }
    &lt;/tbody&gt;
&lt;/table&gt;

Copy<br>IndexModel.cs ;<br>public class IndexModel : PageModel
    {
        private readonly IProductPageService _productPageService;

        public IndexModel(IProductPageService productPageService)
        {
            _productPageService = productPageService ?? throw new ArgumentNullException(nameof(productPageService));
        }

        public IEnumerable&lt;ProductViewModel&gt; ProductList { get; set; } = new List&lt;ProductViewModel&gt;();

        [BindProperty(SupportsGet = true)]
        public string SearchTerm { get; set; }

        public async Task&lt;IActionResult&gt; OnGetAsync()
        {
            ProductList = await _productPageService.GetProducts(SearchTerm);
            return Page();
        }
    }
Copy<br><br>In order to use all implementations properly, we should add dependecies with using ASP.NET Core Default DI classes. So for this implementation we should write all dependencies in Startup.cs ConfigureAspnetRunServices method;<br>private void ConfigureAspnetRunServices(IServiceCollection services)
        {
            // Add Core Layer
            services.Configure&lt;AspnetRunSettings&gt;(Configuration);

            // Add Infrastructure Layer
            ConfigureDatabases(services);
            services.AddScoped(typeof(IAsyncRepository&lt;&gt;), typeof(AspnetRunRepository&lt;&gt;));
            services.AddScoped&lt;IProductRepository, ProductRepository&gt;();
            services.AddScoped&lt;ICategoryRepository, CategoryRepository&gt;();
            services.AddScoped(typeof(IAppLogger&lt;&gt;), typeof(LoggerAdapter&lt;&gt;));

            // Add Application Layer
            services.AddScoped&lt;IProductAppService, ProductAppService&gt;();
            services.AddScoped&lt;ICategoryAppService, CategoryAppService&gt;();

            // Add Web Layer
            services.AddAutoMapper(); // Add AutoMapper
            services.AddScoped&lt;IIndexPageService, IndexPageService&gt;();
            services.AddScoped&lt;IProductPageService, ProductPageService&gt;();
            services.AddScoped&lt;ICategoryPageService, CategoryPageService&gt;();

            // Add Miscellaneous
            services.AddHttpContextAccessor();
            services.AddHealthChecks()
                .AddCheck&lt;IndexPageHealthCheck&gt;("home_page_health_check");
        }
Copy<br>
This step is very important in order to run application. Without giving implementations Asp.Net Core can not find implemented class and will raised the error.
<br>Finally we finished all layers for Product-Category use cases. You can continue the application with create-update-delete actions. We were follow listing functions in order to show layered architecture.<br><br>For each layer, there is a test project which includes intended layer dependencies and mock classes. So that means Core-Application-Infrastructure and Web layer has their own test layer. By this way this test projects also divided by unit, functional and integration tests defined by in which layer it is implemented. Test projects using xunit and Mock libraries. xunit, because that’s what ASP.NET Core uses internally to test the product. Moq, because perform to create fake objects clearly and its very modular.<br>The test project consists of 4 different projects as in the main structure. These projects form separate test projects for each of the projects (Core-Infrastructure-Application-Web) in the existing architecture. All these projects are XUnit Project Template of Visual Studio 2019.<br>As the same way, the development of the test projects should be Core -&gt; Infrastructure -&gt; Application -&gt; Web layer in respectively.<br>So lets start to build test projects.<br><br>This project for testing project of AspnetRun.Core class library project. So it should be test includings of this AspnetRun.Core class library classes.<br>The main folder structure of AspnetRun.Core.Tests project are should have below folders;<br>
<br>Builder
<br>Entities
<br>Specifications
<br>So in example of Entities test ProductTests.cs class includes some of use case of Product entity.<br>[Fact]
public void Create_Product()
{
	var product = Product.Create(_testProductId, _testCategoryId, _testProductName, _testUnitPrice, _testQuantity, null, null, false);

	Assert.Equal(_testProductId, product.Id);
	Assert.Equal(_testCategoryId, product.CategoryId);
	Assert.Equal(_testProductName, product.ProductName);
	Assert.Equal(_testUnitPrice, product.UnitPrice);
	Assert.Equal(_testQuantity, product.UnitsInStock);
}
Copy<br>As you can see that this test classes only test for Core Project in order to ensure Product entity class Create method is working properly.<br>As the same way another test could be for Specification classes. As per the Core layer has not any dependency of database providers, we should apply Specification tests with Mock Product list provided from ProductBuilder.cs. Check the ProductSpecificationTests.cs.<br>[Fact]
public void Matches_Product_With_Category_Spec()
{
	var spec = new ProductWithCategorySpecification(ProductBuilder.ProductName1);

	var result = ProductBuilder.GetProductCollection()
		.AsQueryable()
		.FirstOrDefault(spec.Criteria);

	Assert.NotNull(result);
	Assert.Equal(ProductBuilder.ProductId1, result.Id);
}
Copy<br><br>This project for testing project of AspnetRun.Infrastructure class library project. So it should be test includings of this AspnetRun.Infrastructure class library classes.<br>The main folder structure of AspnetRun.Infrastructure.Tests project are should have below folders;<br>
<br>Builder
<br>Repositories
<br>So in example of Entities test ProductTests.cs class includes some of use case of Product repository.<br>[Fact]
public async Task Get_Existing_Product()
{
	var existingProduct = ProductBuilder.WithDefaultValues();
	_aspnetRunContext.Products.Add(existingProduct);           
	_aspnetRunContext.SaveChanges();
	var productId = existingProduct.Id;
	_output.WriteLine($"ProductId: {productId}");
	var productFromRepo = await _productRepository.GetByIdAsync(productId);
	Assert.Equal(ProductBuilder.TestProductId, productFromRepo.Id);
	Assert.Equal(ProductBuilder.TestCategoryId, productFromRepo.CategoryId);
}
Copy<br>As you can see that, in this layer of tests directly use repository without mocking this objects. That means we should create the EF.Core database providers. So before tests run in constructor of this class we bootstrapped EF.Core database provider as below code;<br>[Fact]
private readonly AspnetRunContext _aspnetRunContext;
private readonly ProductRepository _productRepository;
private readonly ITestOutputHelper _output;
public ProductTests(ITestOutputHelper output)
{
	_output = output;
	var dbOptions = new DbContextOptionsBuilder&lt;AspnetRunContext&gt;()
		.UseInMemoryDatabase(databaseName: "AspnetRun")
		.Options;
	_aspnetRunContext = new AspnetRunContext(dbOptions);
	_productRepository = new ProductRepository(_aspnetRunContext);
}
Copy<br>We used InMemoryDatabase mode in EF.Core for creating context object for testing purpose. You can check other test methods in ProductTests.cs class in AspnetRun.Infrastructure.Tests assembly like Get_Product_By_Name, Get_Product_By_Category.<br>Asp.net core is very powerful framework when it comes to test it functional way. So you can test every options of your web application.<br>Important
As the same way you can check the Application and Web Test layers in the project structure.  
<br><br>Get the <a data-tooltip-position="top" aria-label="https://github.com/aspnetrun/run-aspnetcore" rel="noopener" class="external-link" href="https://github.com/aspnetrun/run-aspnetcore" target="_blank"><strong></strong></a>Source Code from AspnetRun Github — Clone or fork this repository.<br>Press Ctrl+F5 to launch the application. It will launch because default configuration is In-Memory database option.<br>A web page will open as shown in the image below. The navigation menu on the top is showing the navigation link for the Products data page.<br><a data-tooltip-position="top" aria-label="https://miro.medium.com/v2/resize:fit:875/1*D1_QV9o5m7ZHds0_C-OUzw.png" rel="noopener" class="external-link" href="https://miro.medium.com/v2/resize:fit:875/1*D1_QV9o5m7ZHds0_C-OUzw.png" target="_blank"><span alt="Layered Architecture with ASP.NET Core, Entity Framework Core and Razor Pages-240509-19.jpg" src="Layered Architecture with ASP.NET Core, Entity Framework Core and Razor Pages-240509-19.jpg" class="internal-embed media-embed image-embed is-loaded"></span></a><img alt="Layered Architecture with ASP.NET Core, Entity Framework Core and Razor Pages-240509-19.jpg" src="lib/media/layered-architecture-with-asp.net-core,-entity-framework-core-and-razor-pages-240509-19.jpg"><br>Finally we can see the list page of products after seeding database. The search button also worked fine, you can debug code putting breakpoint on Index.cshtml.cs — OnGetAsync method.<br>You can continue with CRUD operations to develop Detail — Edit — Delete actions. To follow same steps for that actions and create pages under the Product folder.<br><br>This article demonstrate that implements clean architecture on project with ASP.NET Core &amp; Entity Framework Core which gives a base template infrastructure of your next enterprise web application with layered application. Using Domain Driven Design Layers and every layer has own test project and built-in test methods which you can continue to provide your custom use cases.<br><br>You can follow this article series with implementation of this Core repository in a real-world example.<br><a data-tooltip-position="top" aria-label="https://medium.com/aspnetrun/build-layered-architecture-with-asp-net-core-entity-framework-core-in-a-real-word-example-aa54a7ed7bef" rel="noopener" class="external-link" href="https://medium.com/aspnetrun/build-layered-architecture-with-asp-net-core-entity-framework-core-in-a-real-word-example-aa54a7ed7bef" target="_blank"><strong></strong></a>Continue with next article which explained implementation of this repository.<br><br>If you would like to see how to write quality code with hands-on, you should check this course.<br><a data-tooltip-position="top" aria-label="https://www.udemy.com/course/microservices-architecture-and-implementation-on-dotnet/?couponCode=OCTOBER2021" rel="noopener" class="external-link" href="https://www.udemy.com/course/microservices-architecture-and-implementation-on-dotnet/?couponCode=OCTOBER2021" target="_blank"><strong></strong></a>Get Udemy Course with discounted — Microservices Architecture and Implementation on .NET.<br>In this course you will see the demonstrating a layered application architecture with DDD best practices. Implements NLayer Hexagonal architecture (Core, Application, Infrastructure and Presentation Layers) and Domain Driven Design (Entities, Repositories, Domain/Application Services, DTO’s…) and aimed to be a Clean Architecture, with applying SOLID principles in order to use for a project template. Also implements best practices like loosely-coupled, dependency-inverted architecture and using design patterns such as Dependency Injection, logging, validation, exception handling and so on.<br><a data-tooltip-position="top" aria-label="https://miro.medium.com/v2/resize:fit:875/1*h74-IymBKCOrL3xJ0oi5nA.png" rel="noopener" class="external-link" href="https://miro.medium.com/v2/resize:fit:875/1*h74-IymBKCOrL3xJ0oi5nA.png" target="_blank"><span alt="06. Files/4b9fa85250f2b765466cd146763e1e34_MD5.jpg" src="06. Files/4b9fa85250f2b765466cd146763e1e34_MD5.jpg" class="internal-embed media-embed image-embed is-loaded"></span></a><img alt="06. Files/4b9fa85250f2b765466cd146763e1e34_MD5.jpg" src="lib/media/4b9fa85250f2b765466cd146763e1e34_md5.jpg"><br><a data-tooltip-position="top" aria-label="https://www.udemy.com/course/microservices-architecture-and-implementation-on-dotnet/?couponCode=OCTOBER2021" rel="noopener" class="external-link" href="https://www.udemy.com/course/microservices-architecture-and-implementation-on-dotnet/?couponCode=OCTOBER2021" target="_blank"><strong></strong></a>Get Udemy Course with discounted — Microservices Architecture and Implementation on .NET.<br>What is AspnetRun ?<br>A starter kit for your next ASP.NET Core web application. Boilerplate for ASP.NET Core reference application with Entity Framework Core, demonstrating a layered application architecture with DDD best practices.<br>There are several asp.net core repositories from beginner to senior level in order to leverage your asp.net core skills and demonstrate real-world implementations.<br><a data-tooltip-position="top" aria-label="https://github.com/aspnetrun" rel="noopener" class="external-link" href="https://github.com/aspnetrun" target="_blank"><strong></strong></a>Check all AspnetRun repositories on Github]]></description><link>04.-literature-notes/layered-architecture-with-asp.net-core,-entity-framework-core-and-razor-pages.html</link><guid isPermaLink="false">04. Literature Notes/Layered Architecture with ASP.NET Core, Entity Framework Core and Razor Pages.md</guid><pubDate>Wed, 08 May 2024 21:58:45 GMT</pubDate><enclosure url="lib/media/layered-architecture-with-asp.net-core,-entity-framework-core-and-razor-pages-240509-17.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/layered-architecture-with-asp.net-core,-entity-framework-core-and-razor-pages-240509-17.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Most popular .NET Libraries every developer should know - medium.com]]></title><description><![CDATA[ 
 <br>Best .NET libraries — Top useful libraries every .NET developers use in their projects.<br><img alt="Most popular .NET Libraries every developer should know - medium.com-240507-1.jpg" src="lib/media/most-popular-.net-libraries-every-developer-should-know-medium.com-240507-1.jpg"><br>.NET Hub: Most popular .NET Libraries<br><br>AutoMapper is a convention-based object-object mapper in .NET. It is a simple little library built to solve a deceptively complex problem — getting rid of code that mapped one object to another. This type of code is rather dreary and boring to write.<br><a data-tooltip-position="top" aria-label="https://github.com/AutoMapper/AutoMapper" rel="noopener" class="external-link" href="https://github.com/AutoMapper/AutoMapper" target="_blank">GitHub</a> ⟷ <a data-tooltip-position="top" aria-label="https://www.nuget.org/packages/AutoMapper/" rel="noopener" class="external-link" href="https://www.nuget.org/packages/AutoMapper/" target="_blank">NuGet</a> ⟷ <a data-tooltip-position="top" aria-label="https://automapper.org/" rel="noopener" class="external-link" href="https://automapper.org/" target="_blank">Website</a><br><br>FluentValidation is a popular .NET validation library for building strongly-typed validation rules. It is a small validation library for .NET that uses a fluent interface and lambda expressions for building validation rules.<br><a data-tooltip-position="top" aria-label="https://github.com/JeremySkinner/FluentValidation" rel="noopener" class="external-link" href="https://github.com/JeremySkinner/FluentValidation" target="_blank">GitHub</a> ⟷ <a data-tooltip-position="top" aria-label="https://www.nuget.org/packages/FluentValidation" rel="noopener" class="external-link" href="https://www.nuget.org/packages/FluentValidation" target="_blank">NuGet</a> ⟷ <a data-tooltip-position="top" aria-label="https://fluentvalidation.net/" rel="noopener" class="external-link" href="https://fluentvalidation.net/" target="_blank">Website</a><br><br>Simple, unambitious mediator implementation in .NET. In-process messaging with no dependencies. Supports request/response, commands, queries, notifications and events, synchronous and async with intelligent dispatching via C# generic variance. <br><a data-tooltip-position="top" aria-label="https://github.com/jbogard/MediatR" rel="noopener" class="external-link" href="https://github.com/jbogard/MediatR" target="_blank">GitHub</a> ⟷ <a data-tooltip-position="top" aria-label="https://www.nuget.org/packages/MediatR" rel="noopener" class="external-link" href="https://www.nuget.org/packages/MediatR" target="_blank">NuGet</a> ⟷ <a data-tooltip-position="top" aria-label="https://github.com/jbogard/MediatR" rel="noopener" class="external-link" href="https://github.com/jbogard/MediatR" target="_blank">Website</a><br><br>Autofac is an IoC container for Microsoft .NET. It manages the dependencies between classes so that applications stay easy to change as they grow in size and complexity. This is achieved by treating regular .NET classes as components.<br><a data-tooltip-position="top" aria-label="https://github.com/autofac/Autofac" rel="noopener" class="external-link" href="https://github.com/autofac/Autofac" target="_blank">GitHub</a> ⟷ <a data-tooltip-position="top" aria-label="https://github.com/autofac/Autofac" rel="noopener" class="external-link" href="https://github.com/autofac/Autofac" target="_blank">NuGet</a> ⟷ <a data-tooltip-position="top" aria-label="https://autofac.org/" rel="noopener" class="external-link" href="https://autofac.org/" target="_blank">Website</a><br><br>An easy way to perform background job processing in your .NET and .NET Core applications. No Windows Service or separate process required. Incredibly easy way to perform fire-and-forget, delayed and recurring jobs inside ASP.NET applications. CPU and I/O intensive, long-running and short-running jobs are supported. No Windows Service / Task Scheduler required. Backed by Redis, SQL Server, SQL Azure and MSMQ.<br><a data-tooltip-position="top" aria-label="https://github.com/HangfireIO/Hangfire" rel="noopener" class="external-link" href="https://github.com/HangfireIO/Hangfire" target="_blank">GitHub</a> ⟷ <a data-tooltip-position="top" aria-label="https://www.nuget.org/packages/Hangfire/" rel="noopener" class="external-link" href="https://www.nuget.org/packages/Hangfire/" target="_blank">NuGet</a> ⟷ <a data-tooltip-position="top" aria-label="https://www.hangfire.io/" rel="noopener" class="external-link" href="https://www.hangfire.io/" target="_blank">Website</a><br><br>Simplify API development for users, teams, and enterprises with the Swagger open source and professional toolset. Swagger tooling for API’s built with ASP.NET Core. Generate beautiful API documentation, including a UI to explore and test operations, directly from your routes, controllers and models. In addition to its Swagger 2.0 and OpenAPI 3.0 generator, Swashbuckle also provides an embedded version of the awesome swagger-ui that’s powered by the generated Swagger JSON. This means you can complement your API with living documentation that’s always in sync with the latest code. Best of all, it requires minimal coding and maintenance, allowing you to focus on building an awesome API.<br><a data-tooltip-position="top" aria-label="https://github.com/domaindrivendev/Swashbuckle.AspNetCore" rel="noopener" class="external-link" href="https://github.com/domaindrivendev/Swashbuckle.AspNetCore" target="_blank">GitHub</a> ⟷ <a data-tooltip-position="top" aria-label="https://www.nuget.org/packages/Swashbuckle/" rel="noopener" class="external-link" href="https://www.nuget.org/packages/Swashbuckle/" target="_blank">NuGet</a> ⟷ <a data-tooltip-position="top" aria-label="https://swagger.io/" rel="noopener" class="external-link" href="https://swagger.io/" target="_blank">Website</a><br><br>Simple .NET logging with fully-structured events. Serilog is a diagnostic logging library for .NET applications. It is easy to set up, has a clean API, and runs on all recent .NET platforms. While it’s useful even in the simplest applications, Serilog’s support for structured logging shines when instrumenting complex, distributed, and asynchronous applications and systems.<br><a data-tooltip-position="top" aria-label="https://github.com/serilog/serilog" rel="noopener" class="external-link" href="https://github.com/serilog/serilog" target="_blank">GitHub</a> ⟷ <a data-tooltip-position="top" aria-label="https://www.nuget.org/packages/Serilog/" rel="noopener" class="external-link" href="https://www.nuget.org/packages/Serilog/" target="_blank">NuGet</a> ⟷ <a data-tooltip-position="top" aria-label="https://serilog.net/" rel="noopener" class="external-link" href="https://serilog.net/" target="_blank">Website</a><br><br>xUnit.net is a free, open source, community-focused unit testing tool for the .NET Framework. Written by the original inventor of NUnit v2, xUnit.net is the latest technology for unit testing C#, F#, VB.NET and other .NET languages. xUnit.net works with ReSharper, CodeRush, TestDriven.NET and Xamarin.<a data-tooltip-position="top" aria-label="https://github.com/xunit/xunit" rel="noopener" class="external-link" href="https://github.com/xunit/xunit" target="_blank">GitHub</a> ⟷ <a data-tooltip-position="top" aria-label="https://www.nuget.org/packages/xunit" rel="noopener" class="external-link" href="https://www.nuget.org/packages/xunit" target="_blank">NuGet</a> ⟷ <a data-tooltip-position="top" aria-label="https://xunit.net/" rel="noopener" class="external-link" href="https://xunit.net/" target="_blank">Website</a><br><br>The most popular and friendly mocking library for .NET. Moq (pronounced “Mock-you” or just “Mock”) is the only mocking library for .NET developed from scratch to take full advantage of .NET Linq expression trees and lambda expressions, which makes it the most productive, type-safe and refactoring-friendly mocking library available. And it supports mocking interfaces as well as classes. Its API is extremely simple and straightforward, and doesn’t require any prior knowledge or experience with mocking concepts.<br><a data-tooltip-position="top" aria-label="https://github.com/Moq/moq4" rel="noopener" class="external-link" href="https://github.com/Moq/moq4" target="_blank">GitHub</a> ⟷ <a data-tooltip-position="top" aria-label="https://www.nuget.org/packages/moq/" rel="noopener" class="external-link" href="https://www.nuget.org/packages/moq/" target="_blank">NuGet</a> ⟷ <a data-tooltip-position="top" aria-label="https://github.com/Moq/moq4" rel="noopener" class="external-link" href="https://github.com/Moq/moq4" target="_blank">Website</a><br><br>Fluent Assertions is a set of .NET extension methods that allow you to more naturally specify the expected outcome of a TDD or BDD-style unit test. Write assertions that keep you and your fellow developers out of the debugger hell and clearly communicate what they are trying to accomplish.<br><a data-tooltip-position="top" aria-label="https://github.com/fluentassertions/fluentassertions" rel="noopener" class="external-link" href="https://github.com/fluentassertions/fluentassertions" target="_blank">GitHub</a> ⟷ <a data-tooltip-position="top" aria-label="https://www.nuget.org/packages/FluentAssertions/" rel="noopener" class="external-link" href="https://www.nuget.org/packages/FluentAssertions/" target="_blank">NuGet</a> ⟷ <a data-tooltip-position="top" aria-label="https://fluentassertions.com/" rel="noopener" class="external-link" href="https://fluentassertions.com/" target="_blank">Website</a><br><br>AutoFixture is an open source library for .NET designed to minimize the ‘Arrange’ phase of your unit tests in order to maximize maintainability. Its primary goal is to allow developers to focus on what is being tested rather than how to setup the test scenario, by making it easier to create object graphs containing test data. Write maintainable unit tests, faster. AutoFixture makes it easier for developers to do Test-Driven Development by automating non-relevant Test Fixture Setup, allowing the Test Developer to focus on the essentials of each test case.<br><a data-tooltip-position="top" aria-label="https://github.com/AutoFixture/AutoFixture" rel="noopener" class="external-link" href="https://github.com/AutoFixture/AutoFixture" target="_blank">GitHub</a> ⟷ <a data-tooltip-position="top" aria-label="https://www.nuget.org/packages/AutoFixture/" rel="noopener" class="external-link" href="https://www.nuget.org/packages/AutoFixture/" target="_blank">NuGet</a> ⟷ <a data-tooltip-position="top" aria-label="https://github.com/AutoFixture/AutoFixture" rel="noopener" class="external-link" href="https://github.com/AutoFixture/AutoFixture" target="_blank">Website</a><br><br>A simple fake data generator for C#, F#, and VB.NET. Bogus is fundamentally a C# port of <a data-tooltip-position="top" aria-label="https://github.com/faker-js/faker.js/" rel="noopener" class="external-link" href="https://github.com/faker-js/faker.js/" target="_blank">faker.js</a> and inspired by <a data-tooltip-position="top" aria-label="https://github.com/JeremySkinner/FluentValidation" rel="noopener" class="external-link" href="https://github.com/JeremySkinner/FluentValidation" target="_blank">FluentValidation</a>'s syntax sugar. Bogus will help you load databases, UI and apps with fake data for your testing needs.<br><a data-tooltip-position="top" aria-label="https://github.com/bchavez/Bogus" rel="noopener" class="external-link" href="https://github.com/bchavez/Bogus" target="_blank">GitHub</a> ⟷ <a data-tooltip-position="top" aria-label="https://www.nuget.org/packages/Bogus/" rel="noopener" class="external-link" href="https://www.nuget.org/packages/Bogus/" target="_blank">NuGet</a> ⟷ <a data-tooltip-position="top" aria-label="https://github.com/bchavez/Bogus/wiki" rel="noopener" class="external-link" href="https://github.com/bchavez/Bogus/wiki" target="_blank">Website</a><br><br>Polly is a .NET resilience and transient-fault-handling library that allows developers to express policies such as Retry, Circuit Breaker, Timeout, Bulkhead Isolation, and Fallback in a fluent and thread-safe manner.<br><a data-tooltip-position="top" aria-label="https://github.com/App-vNext/Polly" rel="noopener" class="external-link" href="https://github.com/App-vNext/Polly" target="_blank">GitHub</a> ⟷ <a data-tooltip-position="top" aria-label="https://www.nuget.org/packages/Polly/" rel="noopener" class="external-link" href="https://www.nuget.org/packages/Polly/" target="_blank">NuGet</a> ⟷ <a data-tooltip-position="top" aria-label="http://www.thepollyproject.org/" rel="noopener" class="external-link" href="http://www.thepollyproject.org/" target="_blank">Website</a><br><br>Simple REST and HTTP API Client for .NET. RestSharp is probably the most popular HTTP client library for .NET. Featuring automatic serialization and deserialization, request and response type detection, variety of authentications and other useful features, it is being used by hundreds of thousands of projects.<br><a data-tooltip-position="top" aria-label="https://github.com/restsharp/RestSharp" rel="noopener" class="external-link" href="https://github.com/restsharp/RestSharp" target="_blank">GitHub</a> ⟷ <a data-tooltip-position="top" aria-label="https://nuget.org/packages/RestSharp" rel="noopener" class="external-link" href="https://nuget.org/packages/RestSharp" target="_blank">NuGet</a> ⟷ <a data-tooltip-position="top" aria-label="https://restsharp.dev/" rel="noopener" class="external-link" href="https://restsharp.dev/" target="_blank">Website</a><br><br>The automatic type-safe REST library for .NET Core, Xamarin and .NET. Heavily inspired by Square’s Retrofit library, Refit turns your REST API into a live interface.<br><a data-tooltip-position="top" aria-label="https://github.com/reactiveui/refit" rel="noopener" class="external-link" href="https://github.com/reactiveui/refit" target="_blank">GitHub</a> ⟷ <a data-tooltip-position="top" aria-label="https://www.nuget.org/packages/Refit/" rel="noopener" class="external-link" href="https://www.nuget.org/packages/Refit/" target="_blank">NuGet</a> ⟷ <a data-tooltip-position="top" aria-label="https://reactiveui.github.io/refit/" rel="noopener" class="external-link" href="https://reactiveui.github.io/refit/" target="_blank">Website</a><br><br>Humanizer meets all your .NET needs for manipulating and displaying strings, enums, dates, times, timespans, numbers and quantities. It is part of the .NET Foundation.<br><a data-tooltip-position="top" aria-label="https://github.com/Humanizr/Humanizer" rel="noopener" class="external-link" href="https://github.com/Humanizr/Humanizer" target="_blank">GitHub</a> ⟷ <a data-tooltip-position="top" aria-label="https://www.nuget.org/packages/Humanizer" rel="noopener" class="external-link" href="https://www.nuget.org/packages/Humanizer" target="_blank">NuGet</a> ⟷ <a data-tooltip-position="top" aria-label="https://github.com/Humanizr/Humanizer/wiki" rel="noopener" class="external-link" href="https://github.com/Humanizr/Humanizer/wiki" target="_blank">Website</a><br><br>Noda Time is an alternative date and time API for .NET. It helps you to think about your data more clearly, and express operations on that data more precisely.<br><a data-tooltip-position="top" aria-label="https://github.com/nodatime/nodatime" rel="noopener" class="external-link" href="https://github.com/nodatime/nodatime" target="_blank">GitHub</a> ⟷ <a data-tooltip-position="top" aria-label="https://www.nuget.org/packages/NodaTime/" rel="noopener" class="external-link" href="https://www.nuget.org/packages/NodaTime/" target="_blank">NuGet</a> ⟷ <a data-tooltip-position="top" aria-label="https://nodatime.org/" rel="noopener" class="external-link" href="https://nodatime.org/" target="_blank">Website</a><br><br>BenchmarkDotNet helps you to transform methods into benchmarks, track their performance, and share reproducible measurement experiments. It’s no harder than writing unit tests! Under the hood, it performs a lot of <a data-tooltip-position="top" aria-label="https://github.com/dotnet/BenchmarkDotNet#Automation" rel="noopener" class="external-link" href="https://github.com/dotnet/BenchmarkDotNet#Automation" target="_blank">magic</a> that guarantees reliable and precise results thanks to the perfolizer statistical engine. BenchmarkDotNet protects you from popular benchmarking mistakes and warns you if something is wrong with your benchmark design or obtained measurements. The results are presented in a user-friendly form that highlights all the important facts about your experiment. The library is adopted by 6800+ projects including .NET Runtime and supported by the .NET Foundation.<br><a data-tooltip-position="top" aria-label="https://github.com/dotnet/BenchmarkDotNet" rel="noopener" class="external-link" href="https://github.com/dotnet/BenchmarkDotNet" target="_blank">GitHub</a> ⟷ <a data-tooltip-position="top" aria-label="https://www.nuget.org/packages/BenchmarkDotNet/" rel="noopener" class="external-link" href="https://www.nuget.org/packages/BenchmarkDotNet/" target="_blank">NuGet</a> ⟷ <a data-tooltip-position="top" aria-label="https://benchmarkdotnet.org/" rel="noopener" class="external-link" href="https://benchmarkdotnet.org/" target="_blank">Website</a><br><br>GenFu is a library you can use to generate realistic test data. It is composed of several property fillers that can populate commonly named properties through reflection using an internal database of values or randomly created data. You can override any of the fillers, give GenFu hints on how to fill them. GenFu is all about smartly building up objects to use for test and prototype data. It will walk your object graph and fill in the properties on your type with realistic looking data.<br>Use GenFu’s static methods to new up new objects for testing, design-time data or seeding a database.<br><a data-tooltip-position="top" aria-label="https://github.com/MisterJames/GenFu" rel="noopener" class="external-link" href="https://github.com/MisterJames/GenFu" target="_blank">GitHub</a> ⟷ <a data-tooltip-position="top" aria-label="https://www.nuget.org/packages/GenFu" rel="noopener" class="external-link" href="https://www.nuget.org/packages/GenFu" target="_blank">NuGet</a> ⟷ <a data-tooltip-position="top" aria-label="http://genfu.io/" rel="noopener" class="external-link" href="http://genfu.io/" target="_blank">Website</a><br><br>MiniProfiler is a library and UI for profiling your application. By letting you see where your time is spent, which queries are run, and any other custom timings you want to add, MiniProfiler helps you debug issues and optimize performance. A simple but effective mini-profiler for ASP.NET (and Core) websites.<br><a data-tooltip-position="top" aria-label="https://github.com/MiniProfiler/dotnet" rel="noopener" class="external-link" href="https://github.com/MiniProfiler/dotnet" target="_blank">GitHub</a> ⟷ <a data-tooltip-position="top" aria-label="https://www.nuget.org/packages/MiniProfiler/" rel="noopener" class="external-link" href="https://www.nuget.org/packages/MiniProfiler/" target="_blank">NuGet</a> ⟷ <a data-tooltip-position="top" aria-label="https://miniprofiler.com/" rel="noopener" class="external-link" href="https://miniprofiler.com/" target="_blank">Website</a><br><br>Create advanced Excel spreadsheets using .NET, without the need of interop. It had the basic functionality needed to read and write a spreadsheet. EPPlus is a .NET library that reads and writes Excel files using the Office Open XML format (xlsx). EPPlus has no dependencies other than .NET.<br><a data-tooltip-position="top" aria-label="https://github.com/JanKallman/EPPlus" rel="noopener" class="external-link" href="https://github.com/JanKallman/EPPlus" target="_blank">GitHub</a> ⟷ <a data-tooltip-position="top" aria-label="https://www.nuget.org/packages/EPPlus/" rel="noopener" class="external-link" href="https://www.nuget.org/packages/EPPlus/" target="_blank">NuGet</a> ⟷ <a data-tooltip-position="top" aria-label="https://github.com/JanKallman/EPPlus" rel="noopener" class="external-link" href="https://github.com/JanKallman/EPPlus" target="_blank">Website</a><br><br>iText 7 for .NET is the .NET version of the iText 7 library, formerly known as iTextSharp, which it replaces. iText 7 represents the next level of SDKs for developers that want to take advantage of the benefits PDF can bring. Equipped with a better document engine, high and low-level programming capabilities and the ability to create, edit, etc.<br><a data-tooltip-position="top" aria-label="https://github.com/itext/itext7-dotnet" rel="noopener" class="external-link" href="https://github.com/itext/itext7-dotnet" target="_blank">GitHub</a> ⟷ <a data-tooltip-position="top" aria-label="https://www.nuget.org/packages/itext7" rel="noopener" class="external-link" href="https://www.nuget.org/packages/itext7" target="_blank">NuGet</a> ⟷ <a data-tooltip-position="top" aria-label="https://itextpdf.com/en" rel="noopener" class="external-link" href="https://itextpdf.com/en" target="_blank">Website</a><br>View more from <a data-tooltip-position="top" aria-label="https://medium.com/dotnet-hub" rel="noopener" class="external-link" href="https://medium.com/dotnet-hub" target="_blank"><em><strong></strong></em></a>.NET Hub<br>
<br><a data-tooltip-position="top" aria-label="https://readmedium.com/top-dotnet-asp-net-core-open-source-projects-most-popular-aspnetcore-best-github-repos-6261569bdb06" rel="noopener" class="external-link" href="https://readmedium.com/top-dotnet-asp-net-core-open-source-projects-most-popular-aspnetcore-best-github-repos-6261569bdb06" target="_blank">Top .NET (ASP.NET Core) Open-Source Projects</a>
<br><a data-tooltip-position="top" aria-label="https://readmedium.com/clean-architecture-with-dotnet-and-dotnet-core-aspnetcore-overview-introduction-getting-started-ec922e53bb97" rel="noopener" class="external-link" href="https://readmedium.com/clean-architecture-with-dotnet-and-dotnet-core-aspnetcore-overview-introduction-getting-started-ec922e53bb97" target="_blank">Clean Architecture with .NET and .NET Core</a>
<br><a data-tooltip-position="top" aria-label="https://readmedium.com/use-mediatr-in-asp-net-or-asp-net-core-cqrs-and-mediator-in-dotnet-how-to-use-mediatr-cqrs-aspnetcore-5076e2f2880c" rel="noopener" class="external-link" href="https://readmedium.com/use-mediatr-in-asp-net-or-asp-net-core-cqrs-and-mediator-in-dotnet-how-to-use-mediatr-cqrs-aspnetcore-5076e2f2880c" target="_blank">Use MediatR in ASP.NET or ASP.NET Core</a>
<br><a data-tooltip-position="top" aria-label="https://readmedium.com/interception-in-entity-framework-core-862529b47f20" rel="noopener" class="external-link" href="https://readmedium.com/interception-in-entity-framework-core-862529b47f20" target="_blank">Interception in Entity Framework Core</a>
<br><a data-tooltip-position="top" aria-label="https://readmedium.com/use-azure-app-configuration-with-asp-net-core-application-6bdf0cc851e2" rel="noopener" class="external-link" href="https://readmedium.com/use-azure-app-configuration-with-asp-net-core-application-6bdf0cc851e2" target="_blank">Use Azure App Configuration with ASP.NET or ASP.NET Core Applications</a>
<br>Happy Coding!!!]]></description><link>04.-literature-notes/most-popular-.net-libraries-every-developer-should-know-medium.com.html</link><guid isPermaLink="false">04. Literature Notes/Most popular .NET Libraries every developer should know - medium.com.md</guid><pubDate>Wed, 08 May 2024 21:41:06 GMT</pubDate><enclosure url="lib/media/most-popular-.net-libraries-every-developer-should-know-medium.com-240507-1.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/most-popular-.net-libraries-every-developer-should-know-medium.com-240507-1.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Single Page Application Using ASP.NET MVC And jQuery With CRUD methods]]></title><description><![CDATA[ 
 <br><a data-tooltip-position="top" aria-label="https://www.c-sharpcorner.com/images/csharp-corner.png" rel="noopener" class="external-link" href="https://www.c-sharpcorner.com/images/csharp-corner.png" target="_blank"><span alt="Single Page Application Using ASP.NET MVC And jQuery With CRUD methods-240509-1.webp" src="Single Page Application Using ASP.NET MVC And jQuery With CRUD methods-240509-1.webp" class="internal-embed media-embed image-embed is-loaded"></span></a><img alt="Single Page Application Using ASP.NET MVC And jQuery With CRUD methods-240509-1.webp" src="lib/media/single-page-application-using-asp.net-mvc-and-jquery-with-crud-methods-240509-1.webp"><br>Introduction<br>In this article, I will tell you how to create a single page application using ASP.NET MVC and jQuery. Without using Angular, React, and other third-party JavaScripts, it is difficult to achieve SPA. In this&nbsp;article, I will explain only controller and UI level interaction. I skipped the data access layer. If you want, please download the attachment which includes the overall code of the application.<br>Note - I used code first approach for CRUD operations. After downloading the project file, restore packages and change the connection string web.config and run the update-database command in Package Manager Console.&nbsp;<br>Required Contents<br>
<br>ASP.NET MVC
<br>JQUERY
<br>Sammy.JS (for Routing)
<br>Steps<br>Create a new MVC project.<br><a data-tooltip-position="top" aria-label="https://www.c-sharpcorner.com/article/single-page-application-using-asp-net-mvc-and-jquery/Images/1.png" rel="noopener" class="external-link" href="https://www.c-sharpcorner.com/article/single-page-application-using-asp-net-mvc-and-jquery/Images/1.png" target="_blank"><span alt="Single Page Application Using ASP.NET MVC And jQuery With CRUD methods-240509-1.jpg" src="Single Page Application Using ASP.NET MVC And jQuery With CRUD methods-240509-1.jpg" class="internal-embed media-embed image-embed is-loaded"></span></a><img alt="Single Page Application Using ASP.NET MVC And jQuery With CRUD methods-240509-1.jpg" src="lib/media/single-page-application-using-asp.net-mvc-and-jquery-with-crud-methods-240509-1.jpg"><br><a data-tooltip-position="top" aria-label="https://www.c-sharpcorner.com/article/single-page-application-using-asp-net-mvc-and-jquery/Images/2.png" rel="noopener" class="external-link" href="https://www.c-sharpcorner.com/article/single-page-application-using-asp-net-mvc-and-jquery/Images/2.png" target="_blank"><span alt="Single Page Application Using ASP.NET MVC And jQuery With CRUD methods-240509-2.jpg" src="Single Page Application Using ASP.NET MVC And jQuery With CRUD methods-240509-2.jpg" class="internal-embed media-embed image-embed is-loaded"></span></a><img alt="Single Page Application Using ASP.NET MVC And jQuery With CRUD methods-240509-2.jpg" src="lib/media/single-page-application-using-asp.net-mvc-and-jquery-with-crud-methods-240509-2.jpg"><br>Add jQuery and Sammy.js reference to your layout page. Add div tag (MainContent) in which we render all the partial views.<br>&lt;head&gt;  
    &lt;meta charset="utf-8" /&gt;  
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;  
    &lt;title&gt;@ViewBag.Title - My ASP.NET Application&lt;/title&gt;  
    @Styles.Render("~/Content/css")  
    @Scripts.Render("~/bundles/modernizr")  
    &lt;script src="~/Scripts/jquery-1.10.2.js"&gt;&lt;/script&gt;  
    &lt;script src="~/Scripts/sammy-0.7.4.js"&gt;&lt;/script&gt;  
&lt;/head&gt; 
Copy<br>Create layout-routing.js file in your project which contains your application routing structure which is shown as below.<br>var mainContent;  
var titleContent;  
  
$(function () {  
    mainContent = $("\#MainContent"); /// render partial views.  
    titleContent = $("title"); // render titles.  
});  
  
var routingApp = $.sammy("\#MainContent", function () {  
    this.get("#/Student/Index", function (context) {  
        titleContent.html("Student Page");  
        $.get("/Student/Index", function (data) {  
            context.$element().html(data);  
        });  
    });  
  
    this.get("#/Student/Add", function (context) {  
        titleContent.html("Add Student");  
        //$("\#BigLoader").modal('show'); // If you want to show loader  
        $.get("/Student/Add", function (data) {  
            //$("\#BigLoader").modal('hide');  
            context.$element().html(data);  
        });  
    });  
  
    this.get("#/Student/Edit", function (context) {  
        titleContent.html("Edit Student");  
        $.get("/Student/Edit", {  
            studentID: context.params.id // pass student id  
        }, function (data) {  
            context.$element().html(data);  
        });  
    });  
  
    this.get("#/Home/About", function (context) {  
        titleContent.html("About");  
        $.get("/Home/About", function (data) {  
            context.$element().html(data);  
        });  
    });  
  
    this.get("#/Home/Contact", function (context) {  
        titleContent.html("Contact");  
        $.get("/Home/Contact", function (data) {  
            context.$element().html(data);  
        });  
    });  
});  
  
$(function () {  
    routingApp.run("#/Student/Index"); // default routing page.  
});  
  
function IfLinkNotExist(type, path) {  
    if (!(type != null &amp;&amp; path != null))  
        return false;  
  
    var isExist = true;  
  
    if (type.toLowerCase()  "get") {  
        if (routingApp.routes.get != undefined) {  
            $.map(routingApp.routes.get, function (item) {  
                if (item.path.toString().replace("/#", "#").replace(/\\/g, '').replace("$/", "").indexOf(path) &gt;= 0) {  
                    isExist = false;  
                }  
            });  
        }  
    } else if (type.toLowerCase()  "post") {  
        if (routingApp.routes.post != undefined) {  
            $.map(routingApp.routes.post, function (item) {  
                if (item.path.toString().replace("/#", "#").replace(/\\/g, '').replace("$/", "").indexOf(path) &gt;= 0) {  
                    isExist = false;  
                }  
            });  
        }  
    }  
    return isExist;  
}  
Copy<br>IfLinkNotExist() check if url should not repeat, after we will add dynamic url in routing list on page load.<br>Add layout-routing reference in _layout.cshtml page.<br>&lt;script src="~/layout-routing.js"&gt;&lt;/script&gt;  
    @*@Scripts.Render("~/bundles/jquery")*@  
    @Scripts.Render("~/bundles/bootstrap")  
    @RenderSection("scripts", required: false)  
Copy<br>Add a new controller ‘WelcomeController’ which has only one action ‘Index’.<br>namespace MvcSpaDemo.Controllers  
{  
    public class WelcomeController : Controller  
    {  
        public ActionResult Index()  
        {  
            return View();  
        }  
    }  
}  
Copy<br>Create the View of ‘Index’ action using right-click.<br>In that View, attach the layout page link. (We need&nbsp;to render the layout page for the&nbsp;first time).<br>@{  
    ViewBag.Title = "Index";  
    Layout = "~/Views/Shared/_Layout.cshtml";  
}  
  
&lt;h1&gt;Welcome&lt;/h1&gt;  
Copy<br>Now, create student Controller which includes student CRUD operation modules. (Add, update, delete, View).<br>View Students<br>public ActionResult Index()  
 {  
     return PartialView();  
 }  
  
 public ActionResult _Index()  
 {  
     var students = StudentData.GetStudents();  
     return PartialView(students);  
  }  
Copy<br>Add two Views without layout page. One for outer student contents like header, add button, etc. and another for student table.<br>Index.cshtml<br>@{  
    Layout = null;  
}  
  
&lt;h4&gt;Students&lt;/h4&gt;  
  
&lt;div class="row"&gt;  
    &lt;a href="#/Student/Add"&gt;Add Student&lt;/a&gt;  
&lt;/div&gt;  
  
&lt;div class="row"&gt;  
    &lt;div id="StudentDiv"&gt;  
    &lt;/div&gt;  
&lt;/div&gt;  
  
&lt;script&gt;  
    $(function () {  
        GetStudents();  
    });  
  
    function GetStudents() {  
        $.get("/Student/_Index/", function (data) {  
            $("\#StudentDiv").html(data);  
        });  
    }  
  
    function DeleteStudent(studentID) {  
        if (confirm("Delete student?")) {  
            $.get("/Student/Delete/", { studentID: studentID }, function (data) {  
                GetStudents();  
            });  
        }  
    }  
&lt;/script&gt;  
Copy<br>_Index.cshtml<br>@model IEnumerable&lt;MvcSpaDemo.Entities.Student&gt;  
@{  
    Layout = null;  
}  
  
&lt;table class="table table-striped table-bordered"&gt;  
    &lt;thead&gt;  
        &lt;tr&gt;  
            &lt;th&gt;ID&lt;/th&gt;  
            &lt;th&gt;Name&lt;/th&gt;  
            &lt;th&gt;Email&lt;/th&gt;  
            &lt;th&gt;Class&lt;/th&gt;  
            &lt;th&gt;Action&lt;/th&gt;  
        &lt;/tr&gt;  
    &lt;/thead&gt;  
    &lt;tbody&gt;  
        @foreach (var item in Model)  
        {  
            &lt;tr&gt;  
                &lt;td&gt;@item.StudentID&lt;/td&gt;  
                &lt;td&gt;@item.FirstName @item.LastName&lt;/td&gt;  
                &lt;td&gt;@item.Email&lt;/td&gt;  
                &lt;td&gt;@item.Class&lt;/td&gt;  
                &lt;td&gt;  
                    &lt;a href="#/Student/Edit?id=@item.StudentID"&gt;Edit&lt;/a&gt;  
                    &lt;a href="javascript::;" onclick="DeleteStudent('@item.StudentID')"&gt;Delete&lt;/a&gt;  
                &lt;/td&gt;  
            &lt;/tr&gt;  
        }  
    &lt;/tbody&gt;  
&lt;/table&gt;  
Copy<br>Change the default controller and action in RouteConfig.cs.<br>public class RouteConfig  
    {  
        public static void RegisterRoutes(RouteCollection routes)  
        {  
            routes.IgnoreRoute("{resource}.axd/{*pathInfo}");  
  
            routes.MapRoute(  
                name: "Default",  
                url: "{controller}/{action}/{id}",  
                defaults: new { controller = "Welcome", action = "Index", id = UrlParameter.Optional }  
            );  
        }  
    }  
Copy<br>Run the application using F5. Do the same routing for About and Contact page also.<br><a data-tooltip-position="top" aria-label="https://www.c-sharpcorner.com/article/single-page-application-using-asp-net-mvc-and-jquery/Images/3.png" rel="noopener" class="external-link" href="https://www.c-sharpcorner.com/article/single-page-application-using-asp-net-mvc-and-jquery/Images/3.png" target="_blank"><span alt="Single Page Application Using ASP.NET MVC And jQuery With CRUD methods-240509-3.jpg" src="Single Page Application Using ASP.NET MVC And jQuery With CRUD methods-240509-3.jpg" class="internal-embed media-embed image-embed is-loaded"></span></a><img alt="Single Page Application Using ASP.NET MVC And jQuery With CRUD methods-240509-3.jpg" src="lib/media/single-page-application-using-asp.net-mvc-and-jquery-with-crud-methods-240509-3.jpg"><br>Add Student asd<br>Now, add "Create Student Actions" in Controller.<br>public ActionResult Add()  
        {  
            var student = new Student();  
            ViewBag.Status = "Add";  
            return PartialView(student);  
        }  
  
        [HttpPost]  
        public ActionResult Create(Student student)  
        {  
            StudentData.AddStudent(student);  
            return Json(true, JsonRequestBehavior.AllowGet);  
        }  
Copy<br>We will add the add page with dynamic routing script for create or update.<br>@model MvcSpaDemo.Entities.Student  
@{  
    ViewBag.Title = "Add";  
    Layout = null;  
  
    // We use same page for add and edit.  
    var urlPostString = "/Student/Create";  
    if (ViewBag.Status  "Edit")  
    {  
        urlPostString = "/Student/Update";  
    }  
}  
  
&lt;h2&gt;@ViewBag.Status Student&lt;/h2&gt;  
  
&lt;form id="frmStudent" name="frmStudent" method="post" action="#@urlPostString"&gt;  
    @Html.HiddenFor(x =&gt; x.StudentID)  
    &lt;div class="row"&gt;  
        &lt;div class="form-group"&gt;  
            &lt;label for="Variables"&gt;First Name&lt;/label&gt;  
            @Html.TextBoxFor(x =&gt; x.FirstName, new { @class = "form-control square" })  
        &lt;/div&gt;  
        &lt;div class="form-group"&gt;  
            &lt;label for="Variables"&gt;Last Name&lt;/label&gt;  
            @Html.TextBoxFor(x =&gt; x.LastName, new { @class = "form-control square" })  
        &lt;/div&gt;  
        &lt;div class="form-group"&gt;  
            &lt;label for="Variables"&gt;Email&lt;/label&gt;  
            @Html.TextBoxFor(x =&gt; x.Email, new { @class = "form-control square" })  
        &lt;/div&gt;  
        &lt;div class="form-group"&gt;  
            &lt;label for="Variables"&gt;Class&lt;/label&gt;  
            @Html.TextBoxFor(x =&gt; x.Class, new { @class = "form-control square" })  
        &lt;/div&gt;  
        &lt;div class="form-group"&gt;  
            &lt;input type="submit" class="btn btn-primary" value="Submit" /&gt;  
        &lt;/div&gt;  
    &lt;/div&gt;  
&lt;/form&gt;  
  
&lt;script&gt;  
    $("\#frmStudent").on("submit", function (e) {  
        debugger;  
        //if ($("\#frmStudent").valid()) {  
        routingApp.runRoute('post', '#@urlPostString');  
        e.preventDefault();  
        e.stopPropagation();  
        //}  
    });  
  
    // add dynamic create or update link  
  
    debugger;  
    if (IfLinkNotExist("POST", "#@urlPostString")) {  
        routingApp.post("#@urlPostString", function (context) {  
            //$("\#BigLoader").modal('show');  
            var formData = new FormData($('\#frmStudent')[0]);  
            $.ajax({  
                url: '@urlPostString',  
                data: formData,  
                type: "POST",  
                contentType: false,  
                processData: false,  
                success: function (data) {  
                    //$("\#BigLoader").modal('hide');  
                    if (data) {  
                        if ('@ViewBag.Status'  'Add')  
                            alert("Student successfully added");  
                        else if ('@ViewBag.Status'  'Edit')  
                            alert("Student successfully updated");  
                        window.location.href = "#/Student/Index";  
                    }  
                    else {  
                        alert('Something went wrong');  
                    }  
                },  
                error: function () {  
                    alert('Something went wrong');  
                }  
            });  
        });  
    }  
  
&lt;/script&gt;  
Copy<br>Now, run the application.<br><a data-tooltip-position="top" aria-label="https://www.c-sharpcorner.com/article/single-page-application-using-asp-net-mvc-and-jquery/Images/4.png" rel="noopener" class="external-link" href="https://www.c-sharpcorner.com/article/single-page-application-using-asp-net-mvc-and-jquery/Images/4.png" target="_blank"><span alt="Single Page Application Using ASP.NET MVC And jQuery With CRUD methods-240509-4.jpg" src="Single Page Application Using ASP.NET MVC And jQuery With CRUD methods-240509-4.jpg" class="internal-embed media-embed image-embed is-loaded"></span></a><img alt="Single Page Application Using ASP.NET MVC And jQuery With CRUD methods-240509-4.jpg" src="lib/media/single-page-application-using-asp.net-mvc-and-jquery-with-crud-methods-240509-4.jpg"><br><a data-tooltip-position="top" aria-label="https://www.c-sharpcorner.com/article/single-page-application-using-asp-net-mvc-and-jquery/Images/5.png" rel="noopener" class="external-link" href="https://www.c-sharpcorner.com/article/single-page-application-using-asp-net-mvc-and-jquery/Images/5.png" target="_blank"><span alt="Single Page Application Using ASP.NET MVC And jQuery With CRUD methods-240509-5.jpg" src="Single Page Application Using ASP.NET MVC And jQuery With CRUD methods-240509-5.jpg" class="internal-embed media-embed image-embed is-loaded"></span></a><img alt="Single Page Application Using ASP.NET MVC And jQuery With CRUD methods-240509-5.jpg" src="lib/media/single-page-application-using-asp.net-mvc-and-jquery-with-crud-methods-240509-5.jpg"><br><a data-tooltip-position="top" aria-label="https://www.c-sharpcorner.com/article/single-page-application-using-asp-net-mvc-and-jquery/Images/6.png" rel="noopener" class="external-link" href="https://www.c-sharpcorner.com/article/single-page-application-using-asp-net-mvc-and-jquery/Images/6.png" target="_blank"><span alt="Single Page Application Using ASP.NET MVC And jQuery With CRUD methods-240509-6.jpg" src="Single Page Application Using ASP.NET MVC And jQuery With CRUD methods-240509-6.jpg" class="internal-embed media-embed image-embed is-loaded"></span></a><img alt="Single Page Application Using ASP.NET MVC And jQuery With CRUD methods-240509-6.jpg" src="lib/media/single-page-application-using-asp.net-mvc-and-jquery-with-crud-methods-240509-6.jpg"><br>Edit Student<br>Now, move on to Edit Module. Add Edit actions in Controller.<br>public ActionResult Edit(int studentID) // studentID nothing but parameter name which we pass in layout-routing.  
        {  
            var student = StudentData.GetStudentById(studentID);  
            ViewBag.Status = "Edit";  
            return PartialView("Add", student);  
        }  
  
        [HttpPost]  
        public ActionResult Update(Student student)  
        {  
            StudentData.UpdateStudent(student);  
            return Json(true, JsonRequestBehavior.AllowGet);  
        } 
Copy<br>We used the same partial view for add and edit, so there&nbsp; is no need to create a new View for edit.&nbsp;<br>After adding the action methods, just run the application.<br><a data-tooltip-position="top" aria-label="https://www.c-sharpcorner.com/article/single-page-application-using-asp-net-mvc-and-jquery/Images/7.png" rel="noopener" class="external-link" href="https://www.c-sharpcorner.com/article/single-page-application-using-asp-net-mvc-and-jquery/Images/7.png" target="_blank"><span alt="Single Page Application Using ASP.NET MVC And jQuery With CRUD methods-240509-7.jpg" src="Single Page Application Using ASP.NET MVC And jQuery With CRUD methods-240509-7.jpg" class="internal-embed media-embed image-embed is-loaded"></span></a><img alt="Single Page Application Using ASP.NET MVC And jQuery With CRUD methods-240509-7.jpg" src="lib/media/single-page-application-using-asp.net-mvc-and-jquery-with-crud-methods-240509-7.jpg"><br><a data-tooltip-position="top" aria-label="https://www.c-sharpcorner.com/article/single-page-application-using-asp-net-mvc-and-jquery/Images/8.png" rel="noopener" class="external-link" href="https://www.c-sharpcorner.com/article/single-page-application-using-asp-net-mvc-and-jquery/Images/8.png" target="_blank"><span alt="Single Page Application Using ASP.NET MVC And jQuery With CRUD methods-240509-8.jpg" src="Single Page Application Using ASP.NET MVC And jQuery With CRUD methods-240509-8.jpg" class="internal-embed media-embed image-embed is-loaded"></span></a><img alt="Single Page Application Using ASP.NET MVC And jQuery With CRUD methods-240509-8.jpg" src="lib/media/single-page-application-using-asp.net-mvc-and-jquery-with-crud-methods-240509-8.jpg"><br><a data-tooltip-position="top" aria-label="https://www.c-sharpcorner.com/article/single-page-application-using-asp-net-mvc-and-jquery/Images/9.png" rel="noopener" class="external-link" href="https://www.c-sharpcorner.com/article/single-page-application-using-asp-net-mvc-and-jquery/Images/9.png" target="_blank"><span alt="Single Page Application Using ASP.NET MVC And jQuery With CRUD methods-240509-9.jpg" src="Single Page Application Using ASP.NET MVC And jQuery With CRUD methods-240509-9.jpg" class="internal-embed media-embed image-embed is-loaded"></span></a><img alt="Single Page Application Using ASP.NET MVC And jQuery With CRUD methods-240509-9.jpg" src="lib/media/single-page-application-using-asp.net-mvc-and-jquery-with-crud-methods-240509-9.jpg"><br>Delete Student<br>Now, we will implement the Delete operation.<br>We have already written Delete button's code in Student Index.cshtml.<br>function GetStudents() {  
        $.get("/Student/_Index/", function (data) {  
            $("\#StudentDiv").html(data);  
        });  
    }  
  
    function DeleteStudent(studentID) {  
        if (confirm("Delete student?")) {  
            $.get("/Student/Delete/", { studentID: studentID }, function (data) {  
                GetStudents();  
            });  
        }  
    }  
Copy<br>Run the application.<br><a data-tooltip-position="top" aria-label="https://www.c-sharpcorner.com/article/single-page-application-using-asp-net-mvc-and-jquery/Images/10.png" rel="noopener" class="external-link" href="https://www.c-sharpcorner.com/article/single-page-application-using-asp-net-mvc-and-jquery/Images/10.png" target="_blank"><span alt="Single Page Application Using ASP.NET MVC And jQuery With CRUD methods-240509-10.jpg" src="Single Page Application Using ASP.NET MVC And jQuery With CRUD methods-240509-10.jpg" class="internal-embed media-embed image-embed is-loaded"></span></a><img alt="Single Page Application Using ASP.NET MVC And jQuery With CRUD methods-240509-10.jpg" src="lib/media/single-page-application-using-asp.net-mvc-and-jquery-with-crud-methods-240509-10.jpg"><br><a data-tooltip-position="top" aria-label="https://www.c-sharpcorner.com/article/single-page-application-using-asp-net-mvc-and-jquery/Images/11.png" rel="noopener" class="external-link" href="https://www.c-sharpcorner.com/article/single-page-application-using-asp-net-mvc-and-jquery/Images/11.png" target="_blank"><span alt="Single Page Application Using ASP.NET MVC And jQuery With CRUD methods-240509-11.jpg" src="Single Page Application Using ASP.NET MVC And jQuery With CRUD methods-240509-11.jpg" class="internal-embed media-embed image-embed is-loaded"></span></a><img alt="Single Page Application Using ASP.NET MVC And jQuery With CRUD methods-240509-11.jpg" src="lib/media/single-page-application-using-asp.net-mvc-and-jquery-with-crud-methods-240509-11.jpg"><br>I hope you have enjoyed this article. Your valuable feedback, questions, or comments about this article are always welcome.]]></description><link>04.-literature-notes/single-page-application-using-asp.net-mvc-and-jquery-with-crud-methods.html</link><guid isPermaLink="false">04. Literature Notes/Single Page Application Using ASP.NET MVC And jQuery With CRUD methods.md</guid><pubDate>Wed, 08 May 2024 22:00:29 GMT</pubDate><enclosure url="lib/media/single-page-application-using-asp.net-mvc-and-jquery-with-crud-methods-240509-1.webp" length="0" type="image/webp"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/single-page-application-using-asp.net-mvc-and-jquery-with-crud-methods-240509-1.webp&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Unit Testing In .NET Core Using NUnit by positiwise.com]]></title><description><![CDATA[ 
 <br>URL: <a rel="noopener" class="external-link" href="https://positiwise.com/blog/unit-testing-in-net-core-using-nunit" target="_blank">https://positiwise.com/blog/unit-testing-in-net-core-using-nunit</a><br><a data-tooltip-position="top" aria-label="https://positiwise.com/blog/wp-content/uploads/2023/10/unit-testing-in-net-core-using-nunit.jpg" rel="noopener" class="external-link" href="https://positiwise.com/blog/wp-content/uploads/2023/10/unit-testing-in-net-core-using-nunit.jpg" target="_blank"><span alt="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-1.jpg" src="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-1.jpg" class="internal-embed media-embed image-embed is-loaded"></span></a><img alt="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-1.jpg" src="lib/media/unit-testing-in-.net-core-using-nunit-by-positiwise.com-240509-1.jpg"><br>Quick Overview:<br>The blog “Unit Testing In .NET Core Using NUnit” offers a complete process to integrate the NUnit testing framework with your ASP.NET API project and test its functionality. The step-by-step process will help you create a project, add files, put relevant code, and test them using NUnit. Through this, you will grasp how to invoke the methods and confirm if they return the correct data using unit tests in NUnit.<br>Table of Contents<br>How to Use NUnit for Unit Testing in ASP.NET Core<br>What is Unit Testing?<br>The Process To Perform Unit Test in .NET Core Using NUnit<br>Phase 1: Creating the Project<br>Phase 2: Integration of NUnit and Moq (Creation of Unit Test Project)<br>Phase 3: Creation of Unit Test Case<br>Phase 4: Testing the Data Access Service Call and Mock Database<br>The Need of Dotnet Development Company for NUnit Testing<br>Wrapping Up on Unit Testing In .NET Core Using NUnit<br><br>In&nbsp;<a data-tooltip-position="top" aria-label="https://positiwise.com/technologies/dot-net-development" rel="noopener" class="external-link" href="https://positiwise.com/technologies/dot-net-development" target="_blank"><strong></strong></a>.NET development, developers widely use NUnit, one of the most popular frameworks, for unit testing multiple programs or an individual code block. Its fundamentals are based on JUnit, but its primary functioning is to test the .NET web applications and the .NET Web API project.<br>If you are a .NET developer, then you must know this framework and how to integrate and use it with ASP.NET Core applications. It will help you offer the best-in-class dotnet development services to clients.<br>So, let’s have a look at it.<br><br>Unit testing is a&nbsp;<a data-tooltip-position="top" aria-label="https://positiwise.com/blog/what-is-software-development-methodology" rel="noopener" class="external-link" href="https://positiwise.com/blog/what-is-software-development-methodology" target="_blank"><strong></strong></a>software testing methodology&nbsp;performed by developers to check the functionality of an individual code block or a set of programs. The main aim of unit testing is to identify and solve errors at the developers’ end.<br>Unit testing can reduce the time testers take to verify the functionality, compatibility, and security of .NET web applications. In addition, it will also help the developers to push streamlined and well-working code to the final product.<br><br>To learn the unit testing process with NUnit, we will create an ASP.NET Core web API project in Visual Studio. Ensure that your system has a 2019 or later version of the IDE; otherwise, compatibility issues can arise.<br>In addition, with the NUnit testing framework, this tutorial also includes a significant use of Moq. We will employ the Moq method to make the data call for testing an&nbsp;<a data-tooltip-position="top" aria-label="https://positiwise.com/hire/net-web-api-development" rel="noopener" class="external-link" href="https://positiwise.com/hire/net-web-api-development" target="_blank"><strong></strong></a>ASP.NET Web API&nbsp;call, and then we will use NUnit to test the returned value.<br>In this procedure, we divide the complete process into phases, which, in turn, break down into smaller steps. It will help you understand every process and execute it properly. So, let’s start with it.<br><br>
<br>Open your Visual Studio IDE and navigate to&nbsp;File &gt;&gt; New &gt;&gt; Project.
<br>Choose the&nbsp;ASP.NET Core Web Application&nbsp;from the available project templates, and to finalize it, left-click the&nbsp;Next&nbsp;button.
<br><a data-tooltip-position="top" aria-label="https://positiwise.com/blog/wp-content/uploads/2023/10/create-new-project-window.png" rel="noopener" class="external-link" href="https://positiwise.com/blog/wp-content/uploads/2023/10/create-new-project-window.png" target="_blank"><span alt="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-1.webp" src="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-1.webp" class="internal-embed media-embed image-embed is-loaded"></span></a><img alt="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-1.webp" src="lib/media/unit-testing-in-.net-core-using-nunit-by-positiwise.com-240509-1.webp"><br>
<br>The Visual Studio will ask for the&nbsp;project details. Fill them up and move to the next step by clicking on the&nbsp;Create&nbsp;button.
<br>The IDE will provide the option to&nbsp;select the type&nbsp;of ASP.NET Core web application project. Firstly, choose&nbsp;.NET Core&nbsp;and&nbsp;ASP.NET Core 3.1&nbsp;from the drop-down list at the top. After that, select the API similar to the following snippet.
<br><a data-tooltip-position="top" aria-label="https://positiwise.com/blog/wp-content/uploads/2023/10/select-api-option.png" rel="noopener" class="external-link" href="https://positiwise.com/blog/wp-content/uploads/2023/10/select-api-option.png" target="_blank"><span alt="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-2.webp" src="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-2.webp" class="internal-embed media-embed image-embed is-loaded"></span></a><img alt="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-2.webp" src="lib/media/unit-testing-in-.net-core-using-nunit-by-positiwise.com-240509-2.webp"><br>
<br>Click on&nbsp;Create, and your project will be displayed on the screen.
<br>Here, our first phase is completed.<br>Develop .NET Web Application with ASP.NET Technologies<br>Bring your web app ideas to ASP.NET development experts. Hire our skilled .NET developers to build secure, scalable web &amp; desktop web applications.<br><a data-tooltip-position="top" aria-label="https://positiwise.com/hire-asp-net-developers" rel="noopener" class="external-link" href="https://positiwise.com/hire-asp-net-developers" target="_blank"><strong></strong></a>Hire .NET Developers Now<br><br>
<br>Navigate to the project solution and right-click on it. From its menu, choose&nbsp;Add &gt;&gt; New Project.
<br><a data-tooltip-position="top" aria-label="https://positiwise.com/blog/wp-content/uploads/2023/10/add-a-new-project-option.png" rel="noopener" class="external-link" href="https://positiwise.com/blog/wp-content/uploads/2023/10/add-a-new-project-option.png" target="_blank"><span alt="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-3.webp" src="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-3.webp" class="internal-embed media-embed image-embed is-loaded"></span></a><img alt="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-3.webp" src="lib/media/unit-testing-in-.net-core-using-nunit-by-positiwise.com-240509-3.webp"><br>
<br>From the project templates, choose the&nbsp;NUnit Test Project (.NET Core). Click on the&nbsp;Next&nbsp;button to move further.
<br><a data-tooltip-position="top" aria-label="https://positiwise.com/blog/wp-content/uploads/2023/10/nunit-test-project.png" rel="noopener" class="external-link" href="https://positiwise.com/blog/wp-content/uploads/2023/10/nunit-test-project.png" target="_blank"><span alt="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-4.webp" src="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-4.webp" class="internal-embed media-embed image-embed is-loaded"></span></a><img alt="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-4.webp" src="lib/media/unit-testing-in-.net-core-using-nunit-by-positiwise.com-240509-4.webp"><br>
<br>Set the&nbsp;project name&nbsp;and use the&nbsp;Create&nbsp;button to finalize it. In the solutions explorer, you will see the unit test project and associated files.
<br><a data-tooltip-position="top" aria-label="https://positiwise.com/blog/wp-content/uploads/2023/10/solution-explorer-project1.jpg" rel="noopener" class="external-link" href="https://positiwise.com/blog/wp-content/uploads/2023/10/solution-explorer-project1.jpg" target="_blank"><span alt="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-2.jpg" src="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-2.jpg" class="internal-embed media-embed image-embed is-loaded"></span></a><img alt="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-2.jpg" src="lib/media/unit-testing-in-.net-core-using-nunit-by-positiwise.com-240509-2.jpg"><br>
<br>For&nbsp;Projetc1.Tests, open the NuGet package manager, and find the&nbsp;Moq. Match the result with the following snippet and integrate the correct package.
<br><a data-tooltip-position="top" aria-label="https://positiwise.com/blog/wp-content/uploads/2023/10/nuget-pack-manager.jpg" rel="noopener" class="external-link" href="https://positiwise.com/blog/wp-content/uploads/2023/10/nuget-pack-manager.jpg" target="_blank"><span alt="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-3.jpg" src="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-3.jpg" class="internal-embed media-embed image-embed is-loaded"></span></a><img alt="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-3.jpg" src="lib/media/unit-testing-in-.net-core-using-nunit-by-positiwise.com-240509-3.jpg"><br>
<br>After installation of Moq, it will be displayed in the&nbsp;Solutions Explorer.
<br><a data-tooltip-position="top" aria-label="https://positiwise.com/blog/wp-content/uploads/2023/10/installing-moq-nuget-package.jpg" rel="noopener" class="external-link" href="https://positiwise.com/blog/wp-content/uploads/2023/10/installing-moq-nuget-package.jpg" target="_blank"><span alt="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-4.jpg" src="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-4.jpg" class="internal-embed media-embed image-embed is-loaded"></span></a><img alt="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-4.jpg" src="lib/media/unit-testing-in-.net-core-using-nunit-by-positiwise.com-240509-4.jpg"><br>Here, we complete the second phase.<br><br>In this phase, we are going to test an addition program using the NUnit. The method in the program provides the addition of two numbers as a result. Also, when you&nbsp;<a data-tooltip-position="top" aria-label="https://positiwise.com/hire/hire-dot-net-core-developers" rel="noopener" class="external-link" href="https://positiwise.com/hire/hire-dot-net-core-developers" target="_blank"><strong></strong></a>hire .NET core developers, they create test cases to ensure that every component will be checked before reaching the production stage.<br>
<br>Go to&nbsp;Solutions Explorer&nbsp;and under the&nbsp;Project.Main.Test&nbsp;add a&nbsp;MathBL.cs&nbsp;file containing the&nbsp;Sum()&nbsp;method as below.
<br><a data-tooltip-position="top" aria-label="https://positiwise.com/blog/wp-content/uploads/2023/10/declaring-a-class-to-test.png" rel="noopener" class="external-link" href="https://positiwise.com/blog/wp-content/uploads/2023/10/declaring-a-class-to-test.png" target="_blank"><span alt="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-5.webp" src="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-5.webp" class="internal-embed media-embed image-embed is-loaded"></span></a><img alt="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-5.webp" src="lib/media/unit-testing-in-.net-core-using-nunit-by-positiwise.com-240509-5.webp"><br>
<br>Again, navigate to Project1.Test to&nbsp;add MathTestBL.cs&nbsp;class file.
<br>Open the MathTestBL.cs file and add the&nbsp;Setup()&nbsp;and&nbsp;TestSum()&nbsp;methods.
<br><a data-tooltip-position="top" aria-label="https://positiwise.com/blog/wp-content/uploads/2023/10/adding-a-test-method.png" rel="noopener" class="external-link" href="https://positiwise.com/blog/wp-content/uploads/2023/10/adding-a-test-method.png" target="_blank"><span alt="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-6.webp" src="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-6.webp" class="internal-embed media-embed image-embed is-loaded"></span></a><img alt="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-6.webp" src="lib/media/unit-testing-in-.net-core-using-nunit-by-positiwise.com-240509-6.webp"><br>
<br>Now, add the reference if&nbsp;Project.Main.Test to Project1.Test. By right-clicking on Project1.Test, you will get the option to add project references.
<br>In the&nbsp;MathTestBL.cs&nbsp;class file,&nbsp;include&nbsp;the below-highlighted code block.
<br><a data-tooltip-position="top" aria-label="https://positiwise.com/blog/wp-content/uploads/2023/10/defining-the-test-method.png" rel="noopener" class="external-link" href="https://positiwise.com/blog/wp-content/uploads/2023/10/defining-the-test-method.png" target="_blank"><span alt="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-7.webp" src="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-7.webp" class="internal-embed media-embed image-embed is-loaded"></span></a><img alt="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-7.webp" src="lib/media/unit-testing-in-.net-core-using-nunit-by-positiwise.com-240509-7.webp"><br>
<br>Go to&nbsp;View&nbsp;and choose&nbsp;Test Explorer&nbsp;under it. It will help you build the project and check the code.
<br><a data-tooltip-position="top" aria-label="https://positiwise.com/blog/wp-content/uploads/2023/10/opening-test-explorer.png" rel="noopener" class="external-link" href="https://positiwise.com/blog/wp-content/uploads/2023/10/opening-test-explorer.png" target="_blank"><span alt="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-8.webp" src="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-8.webp" class="internal-embed media-embed image-embed is-loaded"></span></a><img alt="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-8.webp" src="lib/media/unit-testing-in-.net-core-using-nunit-by-positiwise.com-240509-8.webp"><br>
<br>The Test Explorer will display all the methods. You have to use right-click on&nbsp;MathTestBL&nbsp;and choose the&nbsp;Run&nbsp;option. The following snippet demonstrates that the IDE will test the class file and provide results.
<br><a data-tooltip-position="top" aria-label="https://positiwise.com/blog/wp-content/uploads/2023/10/running-the-test.png" rel="noopener" class="external-link" href="https://positiwise.com/blog/wp-content/uploads/2023/10/running-the-test.png" target="_blank"><span alt="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-9.webp" src="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-9.webp" class="internal-embed media-embed image-embed is-loaded"></span></a><img alt="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-9.webp" src="lib/media/unit-testing-in-.net-core-using-nunit-by-positiwise.com-240509-9.webp"><br>The test is successful if you see all the green checks; otherwise, some error has been encountered.<br><a data-tooltip-position="top" aria-label="https://positiwise.com/blog/wp-content/uploads/2023/10/test-result.png" rel="noopener" class="external-link" href="https://positiwise.com/blog/wp-content/uploads/2023/10/test-result.png" target="_blank"><span alt="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-10.webp" src="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-10.webp" class="internal-embed media-embed image-embed is-loaded"></span></a><img alt="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-10.webp" src="lib/media/unit-testing-in-.net-core-using-nunit-by-positiwise.com-240509-10.webp"><br>Here, the phase three is completed.<br><br>This is the last phase of this tutorial of NUnit for unit testing in ASP.NET Core. We have to create a database context first with the name Customer.cs.<br>
<br>Under the&nbsp;Solutions Explorer, create the classes and add code like the following snippet.
<br><a data-tooltip-position="top" aria-label="https://positiwise.com/blog/wp-content/uploads/2023/10/customer-model-class.png" rel="noopener" class="external-link" href="https://positiwise.com/blog/wp-content/uploads/2023/10/customer-model-class.png" target="_blank"><span alt="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-11.webp" src="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-11.webp" class="internal-embed media-embed image-embed is-loaded"></span></a><img alt="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-11.webp" src="lib/media/unit-testing-in-.net-core-using-nunit-by-positiwise.com-240509-11.webp"><br><a data-tooltip-position="top" aria-label="https://positiwise.com/blog/wp-content/uploads/2023/10/customer-db-context.png" rel="noopener" class="external-link" href="https://positiwise.com/blog/wp-content/uploads/2023/10/customer-db-context.png" target="_blank"><span alt="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-12.webp" src="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-12.webp" class="internal-embed media-embed image-embed is-loaded"></span></a><img alt="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-12.webp" src="lib/media/unit-testing-in-.net-core-using-nunit-by-positiwise.com-240509-12.webp"><br>
<br>Create the data access logic. You have to implement this logic by creating an&nbsp;EntityRepository.cs&nbsp;file, having an interface named&nbsp;IEntityRepository.cs.
<br><a data-tooltip-position="top" aria-label="https://positiwise.com/blog/wp-content/uploads/2023/10/entity-repository.png" rel="noopener" class="external-link" href="https://positiwise.com/blog/wp-content/uploads/2023/10/entity-repository.png" target="_blank"><span alt="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-13.webp" src="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-13.webp" class="internal-embed media-embed image-embed is-loaded"></span></a><img alt="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-13.webp" src="lib/media/unit-testing-in-.net-core-using-nunit-by-positiwise.com-240509-13.webp"><br><a data-tooltip-position="top" aria-label="https://positiwise.com/blog/wp-content/uploads/2023/10/entity-repository-interface.png" rel="noopener" class="external-link" href="https://positiwise.com/blog/wp-content/uploads/2023/10/entity-repository-interface.png" target="_blank"><span alt="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-14.webp" src="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-14.webp" class="internal-embed media-embed image-embed is-loaded"></span></a><img alt="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-14.webp" src="lib/media/unit-testing-in-.net-core-using-nunit-by-positiwise.com-240509-14.webp"><br>
<br>Create the business logic by adding a new&nbsp;CustomerBL.cs&nbsp;file. Further, add the&nbsp;getActiveCustomer()&nbsp;and&nbsp;SaveCustomer()&nbsp;methods in the file.
<br><a data-tooltip-position="top" aria-label="https://positiwise.com/blog/wp-content/uploads/2023/10/customer-bl-class.png" rel="noopener" class="external-link" href="https://positiwise.com/blog/wp-content/uploads/2023/10/customer-bl-class.png" target="_blank"><span alt="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-15.webp" src="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-15.webp" class="internal-embed media-embed image-embed is-loaded"></span></a><img alt="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-15.webp" src="lib/media/unit-testing-in-.net-core-using-nunit-by-positiwise.com-240509-15.webp"><br>
<br>Under the Project1.Tests, create&nbsp;CustomerTestBL.cs&nbsp;and a method under the name&nbsp;TestGetActiveCustomer().
<br><a data-tooltip-position="top" aria-label="https://positiwise.com/blog/wp-content/uploads/2023/10/unit-test-case-for-customer-bl-class.jpg" rel="noopener" class="external-link" href="https://positiwise.com/blog/wp-content/uploads/2023/10/unit-test-case-for-customer-bl-class.jpg" target="_blank"><span alt="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-5.jpg" src="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-5.jpg" class="internal-embed media-embed image-embed is-loaded"></span></a><img alt="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-5.jpg" src="lib/media/unit-testing-in-.net-core-using-nunit-by-positiwise.com-240509-5.jpg"><br>
<br>Create a mock instance for&nbsp;IEntityRepository. A fixed customer list will be returned when the program uses the&nbsp;GetQueriable()&nbsp;method. Below is the code for it that you need to implement.
<br><a data-tooltip-position="top" aria-label="https://positiwise.com/blog/wp-content/uploads/2023/10/mock-and-test-code.png" rel="noopener" class="external-link" href="https://positiwise.com/blog/wp-content/uploads/2023/10/mock-and-test-code.png" target="_blank"><span alt="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-16.webp" src="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-16.webp" class="internal-embed media-embed image-embed is-loaded"></span></a><img alt="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-16.webp" src="lib/media/unit-testing-in-.net-core-using-nunit-by-positiwise.com-240509-16.webp"><br>
<br>Open the&nbsp;View&nbsp;menu and select&nbsp;Test Explorer&nbsp;to view the test case list.
<br>From the available test cases, open the options for&nbsp;TestGetActiveRecords&nbsp;by right-clicking on it.
<br><a data-tooltip-position="top" aria-label="https://positiwise.com/blog/wp-content/uploads/2023/10/running-the-test-cases.jpg" rel="noopener" class="external-link" href="https://positiwise.com/blog/wp-content/uploads/2023/10/running-the-test-cases.jpg" target="_blank"><span alt="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-6.jpg" src="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-6.jpg" class="internal-embed media-embed image-embed is-loaded"></span></a><img alt="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-6.jpg" src="lib/media/unit-testing-in-.net-core-using-nunit-by-positiwise.com-240509-6.jpg"><br>
<br>The Test Explorer will display the results. NUnit provides all these results, as we are using it for unit testing.
<br><a data-tooltip-position="top" aria-label="https://positiwise.com/blog/wp-content/uploads/2023/10/project1-tests-result.jpg" rel="noopener" class="external-link" href="https://positiwise.com/blog/wp-content/uploads/2023/10/project1-tests-result.jpg" target="_blank"><span alt="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-7.jpg" src="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-7.jpg" class="internal-embed media-embed image-embed is-loaded"></span></a><img alt="Unit Testing In .NET Core Using NUnit by positiwise.com-240509-7.jpg" src="lib/media/unit-testing-in-.net-core-using-nunit-by-positiwise.com-240509-7.jpg"><br><br>To avail of the benefits of NUnit, you need a&nbsp;<a data-tooltip-position="top" aria-label="https://positiwise.com/technologies/dot-net-development" rel="noopener" class="external-link" href="https://positiwise.com/technologies/dot-net-development" target="_blank"><strong></strong></a>dot NET development&nbsp;services company. Such firms provide you with the right team of developers, experienced in building .NET applications, creating test cases, and ensuring software functionality, compatibility, and security.<br>In addition, the .NET development company leverages extended support to maintain your business software and test every component before deployment. They even help with patching loopholes and removing errors and bugs after deployment. But, you should make sure to collaborate with a trustworthy and .NET expert company like Positiwise Software Pvt Ltd.<br><br>NUnit is a top choice of .NET developers for unit testing the application. This framework allows testing applications written in all .NET-compatible languages. We integrated our ASP.NET Core web API in this tutorial and tested the call function. In addition, we have also used Moq with NUnit to help with testing the dependencies.<br>The complete procedure is divided into four phases. The first two phases represent the steps for creating an ASP.NET project and integrating the required testing framework. The next two phases provide the step for testing the API calls using the NUnit and mocking framework. Completing all these phases will help you understand the implementation and working of NUnit in .NET.]]></description><link>04.-literature-notes/unit-testing-in-.net-core-using-nunit-by-positiwise.com.html</link><guid isPermaLink="false">04. Literature Notes/Unit Testing In .NET Core Using NUnit by positiwise.com.md</guid><pubDate>Wed, 08 May 2024 22:02:16 GMT</pubDate><enclosure url="lib/media/unit-testing-in-.net-core-using-nunit-by-positiwise.com-240509-1.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/unit-testing-in-.net-core-using-nunit-by-positiwise.com-240509-1.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Use MediatR in ASP.NET or ASP.NET Core]]></title><description><![CDATA[ 
 <br>Getting started with MediatR and CQRS Pattern — How to use MediatR in .NET and .NET Core?<br><a data-tooltip-position="top" aria-label="https://cdn-images-1.readmedium.com/v2/resize:fit:800/1*3mnrvcn3ufD9zddjWJozXg.png" rel="noopener" class="external-link" href="https://cdn-images-1.readmedium.com/v2/resize:fit:800/1*3mnrvcn3ufD9zddjWJozXg.png" target="_blank"><span alt="Use MediatR in ASP.NET or ASP.NET Core-240509-1.jpg" src="Use MediatR in ASP.NET or ASP.NET Core-240509-1.jpg" class="internal-embed media-embed image-embed is-loaded"></span></a><img alt="Use MediatR in ASP.NET or ASP.NET Core-240509-1.jpg" src="lib/media/use-mediatr-in-asp.net-or-asp.net-core-240509-1.jpg"><br>MediatR in .NET<br><br><a data-tooltip-position="top" aria-label="https://github.com/jbogard/MediatR" rel="noopener" class="external-link" href="https://github.com/jbogard/MediatR" target="_blank"><strong></strong></a>MediatR facilitates CQRS and Mediator patterns in .NET. It is a low-ambition library trying to solve a simple problem — decoupling the in-process sending of messages from handling messages.<br>MediatR supports request/response, commands, queries, notifications and events, synchronous and async with intelligent dispatching via C# generic variance. It also supports a publisher/subscriber pattern.<br><a data-tooltip-position="top" aria-label="https://readmedium.com/most-popular-c-net-core-libraries-every-developer-should-know-5e38c1a63830" rel="noopener" class="external-link" href="https://readmedium.com/most-popular-c-net-core-libraries-every-developer-should-know-5e38c1a63830" target="_blank">Most popular .NET Libraries every developer should know.</a><br><br>The mediator pattern is a behavioral design pattern that helps to reduce chaotic dependencies between objects. The pattern restricts direct communications between the objects and forces them to collaborate only via a mediator object. Mediator is used to reduce communication complexity between multiple objects or classes. This pattern provides a mediator class which normally handles all the communications between different classes and supports easy maintenance of the code by loose coupling.<br><br>dfdfdfddfdf<br><br>CQRS stands for Command and Query Responsibility Segregation, a pattern that separates read and update operations for a data store. Implementing CQRS in your application can maximize its performance, scalability, and security. The flexibility created by migrating to CQRS allows a system to better evolve over time and prevents update commands from causing merge conflicts at the domain level.<br>MediatR has two kinds of messages:<br>
<br>Request/response messages, dispatched to a single handler.
<br>Notification messages, dispatched to multiple handlers.
<br><br><br>Requests describe your commands and queries behavior. Requests are very simple request-response style messages, where a single request is synchronously handled by a single handler. For example, returning something from a database.<br>There are two flavors of requests in MediatR — ones that return a value, and ones that do not. Often this corresponds to reads/queries (returning a value) and writes/commands (usually doesn’t return a value).<br>
<br>IRequest&lt;T&gt; - the request returns a value.
<br>IRequest - the request does not return a value.
<br><br>When a request is created, you will need a handler to solve request. Each request type has its own handler interface, as well as some helper base classes/interfaces. They depends on two parameters. i) request. ii) response.<br>
<br>IRequestHandler&lt;T, U&gt; - implement this and return Task&lt;U&gt;
<br>RequestHandler&lt;T, U&gt; - inherit this and return U
<br><br>A single request being handled by a single handler. What if we want to handle a single request by multiple handlers? That is where notifications come in. In these situations, usually multiple independent operations that need to occur after some event.<br>For example, when new Customer is registered, you want to send email to customer and send SMS to administrator.<br>For notifications, first create your notification message and next, create zero or more handlers for your notification.<br><br>
<br>NuGet: To use MediatR, you need to install below NuGet packages.
<br>PM&gt; Install-Package MediatR
PM&gt; Install-Package MediatR.Extensions.Microsoft.DependencyInjection
Copy<br>
<br>Configuration: MediatR has no dependencies. You need to configure a single factory delegate, used to instantiate all handlers, pipeline behaviors, and pre/post-processors. Then let MediatR know in what assemblies are those profiles defined by calling the IServiceCollection extension method AddMediatR at startup. This extension method, allowing you to register all handlers and pre/post-processors in a given assembly.
<br>public class Startup
{
    public void ConfigureServices(IServiceCollection services)
    {
        // Register MediatR services
        services.AddMediatR(typeof(Startup));

        // Way-2
        //services.AddMediatR(Assembly.GetExecutingAssembly());

        // Register MediatR services from multiple assembly.
        //services.AddMediatR(Assembly.GetExecutingAssembly(), typeof(ICustomerService).Assembly);
    }
}
Copy<br><br>The request (query and command) inherit from IRequest&lt;T&gt; interface, where T indicates the return value. If you don’t have a return value, then inherit from IRequest.<br>The send method sends the object to the CreateCustomerCommmandHandler. The handler inherits from IRequestHandler&lt;TRequest, TResponse&gt; and implements a Handle method. This Handle method processes the CreateCustomerCommand.<br>// Command
public class CreateCustomerCommand : IRequest&lt;Customer&gt;
{
    public Customer Customer { get; set; }
}


// Command Handler
public class CreateCustomerCommandHandler : IRequestHandler&lt;CreateCustomerCommand, Customer&gt;
{
    private readonly IRepository&lt;Customer&gt; _repository;

    public CreateCustomerCommandHandler(IRepository&lt;Customer&gt; repository)
    {
        _repository = repository;
    }

    public async Task&lt;Customer&gt; Handle(CreateCustomerCommand request, CancellationToken cancellationToken)
    {
        return await _repository.AddAsync(request.Customer);
    }
}
Copy<br>// Query
public class GetCustomerByIdQuery : IRequest&lt;Customer&gt;
{
    public Guid Id { get; set; }
}

// Query Handler
public class GetCustomerByIdQueryHandler : IRequestHandler&lt;GetCustomerByIdQuery, Customer&gt;
{
    private readonly IRepository&lt;Customer&gt; _repository;

    public GetCustomerByIdQueryHandler(IRepository&lt;Customer&gt; repository)
    {
        _repository = repository;
    }

    public async Task&lt;Customer&gt; Handle(GetCustomerByIdQuery request, CancellationToken cancellationToken)
    {
        return _repository.GetAll().FirstOrDefault(x =&gt; x.Id  request.Id);
    }
}
Copy<br>// Domain Entity
public class Customer
{
    public Guid Id { get; set; }

    public string FirstName { get; set; }

    public string LastName { get; set; }

    public DateTime? Birthday { get; set; }

    public int? Age { get; set; }

    public string Phone { get; set; }
}

// Create model
public class CreateCustomerModel
{
    [Required]
    public string FirstName { get; set; }

    [Required]
    public string LastName { get; set; }

    public DateTime? Birthday { get; set; }

    public int? Age { get; set; }

    public string Phone { get; set; }
}

// Update model
public class UpdateCustomerModel
{
    [Required]
    public Guid Id { get; set; }

    [Required]
    public string FirstName { get; set; }

    [Required]
    public string LastName { get; set; }

    public DateTime? Birthday { get; set; }

    public int? Age { get; set; }

    public string Phone { get; set; }
}
Copy<br>
<br>Usage: You are done with MediatR configuration. Set the IMediator object with dependency injection in controllers and send the query.
<br>public class CustomerController : ControllerBase
{
    private readonly IMediator _mediator;

    public CustomerController(IMediator mediator)
    {
        _mediator = mediator;
    }

    [HttpGet("all")]
    public async Task&lt;IActionResult&gt; GetAll()
    {
        var result = await _mediator.Send(new GetCustomersQuery());

        return Ok(result);
    }

    [HttpGet("{id}")]
    public async Task&lt;IActionResult&gt; Get([FromRoute] Guid id)
    {
        var result = await _mediator.Send(new GetCustomerByIdQuery
        {
            Id = id
        });

        return Ok(result);
    }

    [HttpPost("add")]
    public async Task&lt;IActionResult&gt; Add([FromBody] CreateCustomerModel createCustomerModel)
    {
        //TODO: Use AutoMapper for mappings

        var customer = new Customer()
        {
            FirstName = createCustomerModel.FirstName,
            LastName = createCustomerModel.LastName,
            Birthday = createCustomerModel.Birthday,
            Age = createCustomerModel.Age,
            Phone = createCustomerModel.Phone,
        };

        var result = await _mediator.Send(new CreateCustomerCommand
        {
            Customer = customer
        });

        return Ok(result);
    }

    [HttpPut("update")]
    public async Task&lt;IActionResult&gt; Update([FromBody] UpdateCustomerModel updateCustomerModel)
    {
        //TODO: Use AutoMapper for mappings

        var existCustomer = await _mediator.Send(new GetCustomerByIdQuery
        {
            Id = updateCustomerModel.Id
        });

        if (existCustomer  null)
        {
            return BadRequest($"No customer found with the id {updateCustomerModel.Id}");
        }

        var customer = new Customer()
        {
            Id = updateCustomerModel.Id,
            FirstName = updateCustomerModel.FirstName,
            LastName = updateCustomerModel.LastName,
            Birthday = updateCustomerModel.Birthday,
            Age = updateCustomerModel.Age,
            Phone = updateCustomerModel.Phone,
        };

        var result = await _mediator.Send(new UpdateCustomerCommand
        {
            Customer = customer
        });

        return Ok(result);
    }
}
Copy<br>Sample source code on <a data-tooltip-position="top" aria-label="https://github.com/a-patel/dotnet-labs/tree/main/libraries/MediatR" rel="noopener" class="external-link" href="https://github.com/a-patel/dotnet-labs/tree/main/libraries/MediatR" target="_blank"><em></em></a>GitHub.<br><br>MediatR is simple mediator pattern implementation in .NET. It keeps things separated and helps to keep Single Responsible Principle. It helps to decouple command/query and event-handling code.<br>View more from <a data-tooltip-position="top" aria-label="https://medium.com/dotnet-hub" rel="noopener" class="external-link" href="https://medium.com/dotnet-hub" target="_blank"><em><strong></strong></em></a>.NET Hub<br>
<br><a data-tooltip-position="top" aria-label="https://readmedium.com/clean-architecture-with-dotnet-and-dotnet-core-aspnetcore-overview-introduction-getting-started-ec922e53bb97" rel="noopener" class="external-link" href="https://readmedium.com/clean-architecture-with-dotnet-and-dotnet-core-aspnetcore-overview-introduction-getting-started-ec922e53bb97" target="_blank">Clean Architecture with .NET and .NET Core</a>
<br><a data-tooltip-position="top" aria-label="https://readmedium.com/most-popular-c-net-core-libraries-every-developer-should-know-5e38c1a63830" rel="noopener" class="external-link" href="https://readmedium.com/most-popular-c-net-core-libraries-every-developer-should-know-5e38c1a63830" target="_blank">Most popular .NET Libraries every developer should know</a>
<br><a data-tooltip-position="top" aria-label="https://readmedium.com/interception-in-entity-framework-core-862529b47f20" rel="noopener" class="external-link" href="https://readmedium.com/interception-in-entity-framework-core-862529b47f20" target="_blank">Interception in Entity Framework Core</a>
<br><a data-tooltip-position="top" aria-label="https://readmedium.com/use-azure-app-configuration-with-asp-net-core-application-6bdf0cc851e2" rel="noopener" class="external-link" href="https://readmedium.com/use-azure-app-configuration-with-asp-net-core-application-6bdf0cc851e2" target="_blank">Use Azure App Configuration with ASP.NET or ASP.NET Core Applications</a>
<br><a data-tooltip-position="top" aria-label="https://readmedium.com/health-check-in-asp-net-core-4b38f3c01f6" rel="noopener" class="external-link" href="https://readmedium.com/health-check-in-asp-net-core-4b38f3c01f6" target="_blank">Health Checks in ASP.NET Core</a>
<br>Happy Coding!!!]]></description><link>04.-literature-notes/use-mediatr-in-asp.net-or-asp.net-core.html</link><guid isPermaLink="false">04. Literature Notes/Use MediatR in ASP.NET or ASP.NET Core.md</guid><pubDate>Wed, 08 May 2024 22:03:54 GMT</pubDate><enclosure url="lib/media/use-mediatr-in-asp.net-or-asp.net-core-240509-1.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/use-mediatr-in-asp.net-or-asp.net-core-240509-1.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item></channel></rss>